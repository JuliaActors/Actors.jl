<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Actor Behavior · Actors.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Actors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Actors.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Actors Documentation</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro/">Getting Started with Actors</a></li><li><a class="tocitem" href="../basics/">Actor Model</a></li><li><a class="tocitem" href="../actors/">Actors and Julia</a></li><li class="is-active"><a class="tocitem" href>Actor Behavior</a><ul class="internal"><li><a class="tocitem" href="#Behavior-Representation-in-Julia"><span>Behavior Representation in Julia</span></a></li><li><a class="tocitem" href="#Actor-Operation"><span>Actor Operation</span></a></li><li><a class="tocitem" href="#stack"><span>Agha&#39;s Stack example</span></a></li><li><a class="tocitem" href="#Setting-and-Changing-Behavior"><span>Setting and Changing Behavior</span></a></li><li><a class="tocitem" href="#Don&#39;t-Share-Mutable-Variables"><span>Don&#39;t Share Mutable Variables</span></a></li><li><a class="tocitem" href="#Instead-Share-Actors"><span>Instead Share Actors</span></a></li></ul></li><li><a class="tocitem" href="../protocol/">Messaging Protocol</a></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Error Handling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../errors/">Error Handling Overview</a></li><li><a class="tocitem" href="../connections/">Connections</a></li><li><a class="tocitem" href="../monitors/">Monitors</a></li><li><a class="tocitem" href="../supervisors/">Supervisors</a></li><li><a class="tocitem" href="../node_failures/">Node Failures</a></li><li><a class="tocitem" href="../checkpoints/">Checkpointing</a></li><li><a class="tocitem" href="../fault_tolerance/">Fault Tolerance</a></li></ul></li><li><a class="tocitem" href="../registry/">Actor Registry</a></li><li><a class="tocitem" href="../infrastructure/">More Useful Stuff</a></li><li><a class="tocitem" href="../glossary/">A Glossary of Actor Terms</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/dining_phil/">Dining Philosophers</a></li><li><a class="tocitem" href="../examples/prod_cons/">Producer-Consumer Problem</a></li><li><a class="tocitem" href="../examples/examples/">Further Examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../diag/">Diagnostics</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../messages/">Messages</a></li><li><a class="tocitem" href="../interface/">Interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Actor Behavior</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Actor Behavior</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaActors/Actors.jl/blob/master/docs/src/behaviors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Actor-Behavior"><a class="docs-heading-anchor" href="#Actor-Behavior">Actor Behavior</a><a id="Actor-Behavior-1"></a><a class="docs-heading-anchor-permalink" href="#Actor-Behavior" title="Permalink"></a></h1><p>An actor embodies the essential elements of  computation: 1) processing, 2) storage and 3) communication.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> Its behavior therefore can be described as <span>$f(a)[c]$</span>,  representing </p><ol><li><span>$f$</span>: a function, <em>processing</em>,</li><li><span>$a$</span>: acquaintances, <em>storage</em>, data that it has,</li><li><span>$c$</span>: <em>communication</em>, a message.</li></ol><p>It processes an incoming message <span>$c$</span> with its behavior function <span>$f$</span> based on its acquaintances <span>$a$</span>.</p><blockquote><p>When an Actor receives a message, it can concurrently:</p><ul><li>send messages to ... addresses of Actors that it has;</li><li>create new Actors;</li><li>designate how to handle the next message it receives. <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></li></ul></blockquote><p>Gul Agha described the <em>behavior</em> as a ...</p><blockquote><p>... function of the incoming communication.</p><p>Two lists of identifiers are used in a behavior definition. Values for the first list of parameters must be specified when the actor is created. This list is called the <em>acquaintance list</em>. The second list of parameters, called the <em>communication list</em>, gets its bindings from an incoming communication. <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup></p></blockquote><p>A behavior then maps the incoming communication to a three tuple of messages sent, new actors created and the replacement behavior:</p><p class="math-container">\[\begin{array}{lrl}
f_i(a_i)[c_i] &amp; \rightarrow &amp;\{\{\mu_u,\mu_v, ...\},\;\{\alpha_x,\alpha_y,...\},\;f_{i+1}(a_{i+1})\} \quad\\
\textrm{with} &amp; f: &amp; \textrm{behavior function} \\
 &amp; a: &amp; \textrm{acquaintances,} \\
 &amp; c: &amp; \textrm{communication,} \\
 &amp; \mu: &amp; \textrm{messages sent,} \\
 &amp; \alpha: &amp; \textrm{actors created.} \\
\end{array}\]</p><h2 id="Behavior-Representation-in-Julia"><a class="docs-heading-anchor" href="#Behavior-Representation-in-Julia">Behavior Representation in Julia</a><a id="Behavior-Representation-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Behavior-Representation-in-Julia" title="Permalink"></a></h2><p><code>Actors</code> expresses actor behavior in a functional style. Actors are basically function servers.</p><p>A behavior is a <a href="https://en.wikipedia.org/wiki/Partial_application">partial application</a> of a callable object <span>$f(a...,c...)$</span> to acquaintances <span>$a...$</span>, that is, a closure over <span>$f(a...)$</span>. If the actor receives a communication <span>$c...$</span>, the closure invokes <span>$f(a...,c...)$</span>. The <a href="https://docs.julialang.org/en/v1.6/manual/faq/#What-does-the-...-operator-do?"><code>...</code>-operator</a> allows us to use multiple acquaintance and communication arguments (i.e. lists).</p><pre><code class="language-julia-repl">julia&gt; f(a, c) = a + c         # define a function
f (generic function with 1 method)

julia&gt; partial(f, a...; kw...) = (c...) -&gt; f(a..., c...; kw...)
partial (generic function with 1 method)

julia&gt; bhv = partial(f, 1)     # partially apply f to 1, return a closure
#2 (generic function with 1 method)

julia&gt; bhv(2)                  # execute f(1,2)
3</code></pre><p>Similar to the <code>partial</code> above, <a href="../api/#Actors.Bhv"><code>Bhv</code></a> is a convenience function to create a partial application <code>ϕ(a...; kw...)</code> with optional keyword arguments, which can be executed with communication arguments <code>c...</code>:</p><pre><code class="language-julia-repl">julia&gt; using Actors, .Threads

julia&gt; import Actors: spawn, newLink

julia&gt; f(s, t; w=1, x=1) = s + t + w + x   # a function
f (generic function with 1 method)

julia&gt; bhv = Bhv(f, 2, w=2, x=2);          # create a behavior of f and acquaintances

julia&gt; bhv(2)                              # execute it with a communication parameter
8</code></pre><h3 id="Object-oriented-Style"><a class="docs-heading-anchor" href="#Object-oriented-Style">Object-oriented Style</a><a id="Object-oriented-Style-1"></a><a class="docs-heading-anchor-permalink" href="#Object-oriented-Style" title="Permalink"></a></h3><p>Alternatively we define an object with acquaintance parameters and make it <a href="https://en.wikipedia.org/wiki/Function_object">callable (as a functor)</a> with communication parameters:</p><pre><code class="language-julia-repl">julia&gt; struct A                            # define an object
           s; w; x                         # with acquaintances
       end

julia&gt; (a::A)(t) = a.s + a.w + a.x + t     # make it a functor, executable with a communication parameter t

julia&gt; bhv = A(2, 2, 2)                    # create an instance
Main.ex-bhv.A(2, 2, 2)

julia&gt; bhv(2)                              # execute it with a parameter
8</code></pre><h2 id="Actor-Operation"><a class="docs-heading-anchor" href="#Actor-Operation">Actor Operation</a><a id="Actor-Operation-1"></a><a class="docs-heading-anchor-permalink" href="#Actor-Operation" title="Permalink"></a></h2><p>When we create an actor with a behavior by using <a href="../api/#ActorInterfaces.Classic.spawn"><code>spawn</code></a>, it is ready to receive communication arguments and to process them:</p><ol><li>You can create an actor with anything callable as behavior regardless whether it contains acquaintances or not.</li><li>Over its <a href="../api/#Actors.Link"><code>Link</code></a> you can <a href="../api/#ActorInterfaces.Classic.send"><code>send</code></a> it communication arguments and cause the actor to execute its behavior with them. <a href="../api/#Actors.call"><code>call</code></a>, <a href="../api/#Actors.exec"><code>exec</code></a> and similar <a href="../api/">API</a> functions are just wrappers around <code>send</code> and <a href="../api/#Actors.receive"><code>receive</code></a> using a <a href="../protocol/">protocol</a> to communicate with an actor.</li><li>If we send an actor wrong/unspecified communication arguments, it will fail with a <code>MethodError</code> when calling its behavior with those.</li><li>With <a href="../api/#Actors.become!"><code>become!</code></a> and <a href="../api/#ActorInterfaces.Classic.become"><code>become</code></a> we can change an actor&#39;s behavior.</li></ol><pre><code class="language-julia-repl">julia&gt; myactor = spawn(threadid)                     # create an actor with a parameterless behavior function
Link{Channel{Any}}(Channel{Any}(32), 1, :default)

julia&gt; call(myactor)                                 # call it without arguments
1

julia&gt; become!(myactor, (lk, x, y) -&gt; send(lk, x^y)) # an anonymous function with communication arguments
Actors.Become(Main.ex-bhv.var&quot;#2#3&quot;())

julia&gt; me = newLink()
Link{Channel{Any}}(Channel{Any}(32), 1, :local)

julia&gt; send(myactor, me, 123, 456)                   # send it arguments
(Link{Channel{Any}}(Channel{Any}(32), 1, :local), 123, 456)

julia&gt; receive(me)                                   # receive the result
2409344748064316129</code></pre><p>In setting actor behavior you are free to mix the functional and object oriented approaches. For example you can give functors further acquaintance parameters (as for the players in the <a href="../basics/#table-tennis">table-tennis example</a>). Of course you can give objects containing acquaintances as parameters to a function and create a partial application with <code>Bhv</code> on them and much more.</p><h2 id="stack"><a class="docs-heading-anchor" href="#stack">Agha&#39;s Stack example</a><a id="stack-1"></a><a class="docs-heading-anchor-permalink" href="#stack" title="Permalink"></a></h2><p>Now more realistically for actor behavior we reproduce Agha&#39;s example 3.2.1:</p><blockquote><p>We implement a stack as a collection of actors with uniform behavior. ... [A] linked list consists of a collection of nodes each of which stores a value and knows the mail address of the &quot;next&quot; actor in the chain. ... Two kinds of operations may be requested of a <em>stack-node</em>: a <em>push</em> or a <em>pop</em>. In the first case, the new content to be pushed must be given, and in the second, the customer to which the value stored in the <em>stack-node</em> can be sent. <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>:</p></blockquote><pre><code class="language-julia">mutable struct StackNode{T,L}  # a stack node object
    content::T
    link::L
end

struct Pop{L}                  # a pop message
    customer::L
end

struct Push{T}                 # a push message
    content::T
end

# now three behavior methods
forwarder = send
function (sn::StackNode)(msg::Pop)
    isnothing(sn.content) || become(forwarder, sn.link)
    send(msg.customer, Response(sn.content))
end
(sn::StackNode)(msg::Push) = become(StackNode(msg.content, spawn(sn)))</code></pre><p>Here we use both the functional and the object oriented style:</p><ul><li><code>forwarder</code> is a function (<code>send</code>) which we put together with <code>sn.link</code> into a behavior. After <code>become(forwarder, sn.link)</code> the actor will forward any received message to <code>sn.link</code>.</li><li><code>StackNode</code> is a functor with two methods.</li></ul><blockquote><p>The top of the stack is the only receptionist in the stack system and was the only actor of the stack system created externally. It is created with a NIL content which is assumed to be the bottom of the stack marker. Notice that no mail address of a stack node ist ever communicated by any node to an external actor. Therefore no actor outside the configuration defined above can effect any of the actors inside the stack except by sending the receptionist a communication. When a <em>pop</em> operation is done, the actor on top of the stack simply becomes a <em>forwarder</em> to the next actor in the link. This means that all communications received by the top of the stack are now forwarded to the next element. <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup></p></blockquote><p>Now we can operate the stack:</p><pre><code class="language-julia">julia&gt; mystack = spawn(StackNode(nothing, newLink())) # create the top of the stack
Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)

julia&gt; response = newLink()                           # create a response link
Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :local)

julia&gt; for i ∈ 1:5
           send(mystack, Push(i))
       end

julia&gt; for i ∈ 1:5
           send(mystack, Pop(response))
           println(receive(response).y)
       end
5
4
3
2
1</code></pre><h2 id="Setting-and-Changing-Behavior"><a class="docs-heading-anchor" href="#Setting-and-Changing-Behavior">Setting and Changing Behavior</a><a id="Setting-and-Changing-Behavior-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-and-Changing-Behavior" title="Permalink"></a></h2><p>An actor&#39;s behavior is set with <a href="../api/#ActorInterfaces.Classic.spawn"><code>spawn</code></a> and gets changed with <a href="../api/#Actors.become!"><code>become!</code></a>. Inside a behavior function an actor can change its own behavior with <a href="../api/#ActorInterfaces.Classic.become"><code>become</code></a>. In both cases a callable object together with acquaintance arguments can be specified as new behavior. This is effective when the next message gets processed.</p><h2 id="Don&#39;t-Share-Mutable-Variables"><a class="docs-heading-anchor" href="#Don&#39;t-Share-Mutable-Variables">Don&#39;t Share Mutable Variables</a><a id="Don&#39;t-Share-Mutable-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Don&#39;t-Share-Mutable-Variables" title="Permalink"></a></h2><p>As you have seen, you are very free in how you define behaviors, but you must be very careful in passing mutable variables as acquaintances to actors as they could be accessed by other actors on other threads concurrently causing race conditions. </p><h2 id="Instead-Share-Actors"><a class="docs-heading-anchor" href="#Instead-Share-Actors">Instead Share Actors</a><a id="Instead-Share-Actors-1"></a><a class="docs-heading-anchor-permalink" href="#Instead-Share-Actors" title="Permalink"></a></h2><p>It is thread-safe to share actors between threads or other actors. Each call to the shared actor is a communication.</p><ul><li>In the <a href="../basics/#table-tennis">table-tennis</a> example we shared a print server actor between player actors working on different threads.</li><li>In the <a href="../actors/#dict-server">Dict-server</a> example a dictionary gets served by an actor to parallel threads.</li><li>You can wrap mutable variables into a <a href="https://github.com/JuliaActors/Guards.jl"><code>:guard</code></a> actor, which will manage access to them.</li><li>In more complicated cases of resource sharing you can use a <a href="https://github.com/JuliaActors/GenServers.jl"><code>:genserver</code></a> actor.</li></ul><p>As those examples show, it is surprisingly easy to avoid race conditions by using actors.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="http://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask">Hewitt, Meijer and Szyperski: The Actor Model (everything you wanted to know, but were afraid to ask)</a>, Microsoft Channel 9. April 9, 2012.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Carl Hewitt. Actor Model of Computation: Scalable Robust Information Systems.- <a href="https://arxiv.org/abs/1008.1459">arXiv:1008.1459</a>.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Gul Agha 1986. <em>Actors. a model of concurrent computation in distributed systems</em>, MIT.- p. 30</li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>ibid. p. 34f</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../actors/">« Actors and Julia</a><a class="docs-footer-nextpage" href="../protocol/">Messaging Protocol »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 14 April 2021 07:31">Wednesday 14 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
