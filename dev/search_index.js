var documenterSearchIndex = {"docs":
[{"location":"api/#Actor-API","page":"Actor API","title":"Actor API","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"CurrentModule = Actors","category":"page"},{"location":"api/#Installation","page":"Actor API","title":"Installation","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors\nActors.version","category":"page"},{"location":"api/#Actors.Actors","page":"Actor API","title":"Actors.Actors","text":"Actors\n\nA Julia library implementing the classical Actor Model.\n\nThe current stable, registered version is installed with\n\npkg> add Actors\n\nThe development version is installed with:\n\npkg> add \"https://github.com/JuliaActors/Actors.jl\"\n\n\n\n\n\n","category":"module"},{"location":"api/#Actors.version","page":"Actor API","title":"Actors.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"api/","page":"Actor API","title":"Actor API","text":"using Actors\nActors.version","category":"page"},{"location":"api/#Types","page":"Actor API","title":"Types","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"The following types are needed for using and extending Actors:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Msg\nRequest\nResponse\nLink\nFunc\n_ACT","category":"page"},{"location":"api/#Actors.Msg","page":"Actor API","title":"Actors.Msg","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Request","page":"Actor API","title":"Actors.Request","text":"Request(x, from::Link)\n\nA generic Msg for user requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Response","page":"Actor API","title":"Actors.Response","text":"Response(y, from::Link=self())\n\nA Msg representing a response to requests.\n\nFields\n\ny: response content,\nfrom::Link: sender link.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Link","page":"Actor API","title":"Actors.Link","text":"Link{C}(chn::C, pid::Int, type::Symbol)\n\nA mailbox for communicating with actors. A concrete type of this must be returned by an actor on creation with spawn.\n\nFields/Parameters\n\nchn::C: C can be any type and characterizes the interface   to an actor,\npid::Int: the pid of the actor, \ntype::Symbol: an arbitrary symbol characterizing the actor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Func","page":"Actor API","title":"Actors.Func","text":"Func(func, args...; kwargs...)\n\nA structure to represent an actor behavior.\n\nParameters\n\nfunc: a callable object (function, functor ...),\nargs...: arguments to func. Those can be no, partial   or full arguments. Eventually missing arguments must be   sent with a message in order to execute func with all   needed arguments.\nkwargs...: keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors._ACT","page":"Actor API","title":"Actors._ACT","text":"_ACT()\n\nInternal actor status variable.\n\nFields\n\nbhv::Func : the behavior function and its internal arguments,\ninit::Func: the init function and its arguments,\nterm::Func: the terminate function and its arguments,\nself::Link: the actor's (local or remote) self,\nname::Symbol: the actor's registered name.\nres::Any: the result of the last behavior execution,\nsta::Any: a variable for representing state,\nusr::Any: user variable for plugging in something.\n\nsee also: Func, Link\n\n\n\n\n\n","category":"type"},{"location":"api/#Starting-Actors,-creating-links","page":"Actor API","title":"Starting Actors, creating links","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors.jl doesn't export its functions to start actors and to create links. Thus other libraries building on it can implement their own actors and links.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"To use Actors's actors and links you import them explicitly:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"using Actors\nimport Actors: spawn, newLink","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Then you can create them with the following functions:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"spawn\nnewLink","category":"page"},{"location":"api/#Actors.spawn","page":"Actor API","title":"Actors.spawn","text":"spawn(bhv::Func; pid=myid(), thrd=false, sticky=false, taskref=nothing)\nspawn(m::Val(:Actors), args...; kwargs...)\nspawn(m::Module, args...; kwargs...)\n\nStart a function bhv as an actor and return a Link to it.\n\nParameters\n\nbhv::Func: behavior function,\npid=myid(): pid of worker process the actor should be started on,\nthrd=false: thread number the actor should be started on or false,\nsticky=false: if true the actor is started on the current thread,\ntaskref=nothing: if a Ref{Task}() is given here, it gets the started Task,\nm::Module: the Module implementing spawn.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.newLink","page":"Actor API","title":"Actors.newLink","text":"newLink(size=32; remote=false)\n\nCreate a local Link with a buffered Channel size ≥ 1.\n\nParameters\n\nsize=32: the size of the channel buffer,\nremote=false: should a remote link be created,\npid=myid(): optional pid of the remote worker.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actor-Primitives","page":"Actor API","title":"Actor Primitives","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"The following primitives characterize actors in the classical Actor Model:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"send!\nbecome!\nbecome\nself\nstop\nonmessage","category":"page"},{"location":"api/#Actors.send!","page":"Actor API","title":"Actors.send!","text":"send!(lk::Link, msg)\n\nSend a message to an actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.become!","page":"Actor API","title":"Actors.become!","text":"become!(lk::Link, bhv::Func)\nbecome!(lk::Link, func, args1...; kwargs...)\n\nCause an actor to change behavior.\n\nArguments\n\nlk::Link actor link,\nbhv: Func implementing the new behavior,\nfunc: callable object,\nargs1...: (partial) arguments to func,\nkwargs...: keyword arguments to func.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.become","page":"Actor API","title":"Actors.become","text":"become(bhv::Func)\nbecome(func, args...; kwargs...)\n\nCause your actor to take on a new behavior. This can only be called from inside an actor/behavior.\n\nArguments\n\nbhv::Func: Func implementing the new behavior,\nfunc: callable object,\nargs1...: (partial) arguments to func,\nkwargs...: keyword arguments to func.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.self","page":"Actor API","title":"Actors.self","text":"self()\n\nGet the Link of your actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.stop","page":"Actor API","title":"Actors.stop","text":"stop(reason::Symbol)\n\nCause your actor to stop with a reason.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.onmessage","page":"Actor API","title":"Actors.onmessage","text":"onmessage(A::_ACT, msg)\n\nAn actor executes this function when a message arrives. An application can extend this by further methods and must use it to plugin the Actors.jl API.\n\n\n\n\n\n","category":"function"},{"location":"api/#API-Primitives","page":"Actor API","title":"API Primitives","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"To receive messages from actors the following two functions for synchronous and asynchronous communication are useful:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"receive!\nrequest!","category":"page"},{"location":"api/#Actors.receive!","page":"Actor API","title":"Actors.receive!","text":"receive!(lk; timeout=5.0)\nreceive!(lk, from; timeout=5.0)\nreceive!(lk, M; timeout=5.0)\nreceive!(lk, M, from; timeout=5.0)\n\nReceive a message over a link lk.\n\nIf M or from are provided, receive! returns only a  matching message. Other messages in lk are restored to it in their previous order.\n\nParameters\n\nlk::Link: local or remote link over which the message is received,\nM::Type{<:Msg}: Msg type,\nfrom::Link: local or remote link of sender. If from is   provided, only messages with a from field can be matched.\ntimeout::Real=5.0: maximum waiting time in seconds.\nIf timeout==0, lk is scanned only for existing messages.\nSet timeout=Inf if you don't want to timeout. \n\nReturns\n\nreceived message or Timeout().\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.request!","page":"Actor API","title":"Actors.request!","text":"request!(lk::Link, msg::Msg; full=false, timeout::Real=5.0)\nrequest!(lk::Link, M::Type{<:Msg}, args...; kwargs...)\n\nSend a message to an actor, block, receive and return the result.\n\nArguments\n\nlk::Link: actor link, or name::Symbol (if registered),\nmsg::Msg: a message,\nMsg::Type{<:Msg}: a message type,\nargs...: optional arguments to Msg, \nfull: if true return the full Response message.\ntimeout::Real=5.0: timeout in seconds after which a    Timeout is returned,\nkwargs...: full or timeout.\n\n\n\n\n\n","category":"function"},{"location":"api/#User-API","page":"Actor API","title":"User API","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors has a user interface allowing you to control actors:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"call!\ncast!\nexec!\nexit!\nquery!\nupdate!","category":"page"},{"location":"api/#Actors.call!","page":"Actor API","title":"Actors.call!","text":"call!(lk::Link, [from::Link,] args2...; timeout::Real=5.0)\n\nCall an actor to execute its behavior and to send a  Response with the result. \n\nArguments\n\nlk::Link: actor link, \nfrom::Link: sender link, \nargs2...: remaining arguments to the actor.\ntimeout::Real=5.0: timeout in seconds.\n\nNote: If from is omitted, call! blocks and returns the result\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.cast!","page":"Actor API","title":"Actors.cast!","text":"cast!(lk::Link, args2...)\n\nCast args2... to the actor lk to execute its behavior  without sending a response. \n\nNote: you can prompt the returned value with query!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.exec!","page":"Actor API","title":"Actors.exec!","text":"exec!(lk::Link, from::Link, func, args...; kwargs...)\nexec!(lk::Link, from::Link, f::Func)\nexec!(lk::Link, f::Func; timeout::Real=5.0)\n\nAsk an actor lk (or name if registered) to execute an  arbitrary function and to send the returned value as  Response.\n\nArguments\n\nlk::Link: actor link,\nfrom::Link: the link a Response should be sent to.\nfunc: a callable object,\nargs...; kwargs...: arguments and keyword arguments to it,\nfu::Func: a Func with a callable object and   its arguments,\ntimeout::Real=5.0: timeout in seconds. Set timeout=Inf    if you don't want to timeout.\n\nNote: If from is ommitted, exec! blocks, waits and  returns the result (with a timeout).\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.exit!","page":"Actor API","title":"Actors.exit!","text":"exit!(lk::Link, reason=:ok)\n\nTell an actor lk to exit. If it has a term  function, it calls it with reason as last argument. \n\nnote: This behavior is not yet fully implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.query!","page":"Actor API","title":"Actors.query!","text":"query!(lk::Link, [from::Link,] s::Symbol; timeout::Real=5.0)\n\nQuery the lk actor about an internal state variable s. \n\nParameters\n\nlk::Link: actor link,\nfrom::Link: sender link,\ns::Symbol can be one of :bhv, :res, :sta.\ntimeout::Real=5.0: \n\nNote: If from is omitted, query! blocks and returns  the response. In that case there is a timeout.\n\nExamples\n\njulia> f(x, y; u=0, v=0) = x+y+u+v  # implement a behavior\nf (generic function with 1 method)\n\njulia> fact = Actor(f, 1)     # start an actor with it\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> cast!(fact, 1)         # cast a second parameter to it\nYAActL.Cast{Tuple{Int64}}((1,))\n\njulia> query!(fact, :res)     # query the result\n2\n\njulia> query!(fact, :bhv)     # query the behavior\nf (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.update!","page":"Actor API","title":"Actors.update!","text":"update!(lk::Link, x; s::Symbol=:sta)\nupdate!(lk::Link, arg::Args)\n\nUpdate an actor's internal state s with args....\n\nArguments\n\nlk::Link an actor link,\nx: value/variable to update the choosen state with,\narg::Args: arguments to update,\ns::Symbol: can be one of :sta, :dsp, :arg, :self, :name.\n\nNote: If you want to update the stored arguments to the  behavior function with s=:arg, you must pass an Args  to arg. If Args has keyword arguments, they are merged  with existing keyword arguments to the behavior function.\n\nExample\n\njulia> update!(fact, 5)       # note that fact is in state dispatch\nYAActL.Update{Int64}(:sta, 5)\n\njulia> call!(fact, 5)         # call it with 5\n10\n\njulia> update!(fact, Args(0, u=5));  # update arguments\n\njulia> call!(fact, 5)         # add the last result, 5 and u=5\n20\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"The following is needed for updating arguments:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Args","category":"page"},{"location":"api/#Actors.Args","page":"Actor API","title":"Actors.Args","text":"Args(args...; kwargs...)\n\nA structure for updating arguments to an actor's behavior.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actor-Registry","page":"Actor API","title":"Actor Registry","text":"","category":"section"},{"location":"api/#Actor-Supervision","page":"Actor API","title":"Actor Supervision","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"This is not yet implemented.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"init!\nterm!","category":"page"},{"location":"api/#Actors.init!","page":"Actor API","title":"Actors.init!","text":"init!(lk::Link, func, args...; kwargs...)\n\nTell an actor lk to save the func with the given  arguments as an init function and to execute  it.\n\nThe init function will be called at actor restart.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.term!","page":"Actor API","title":"Actors.term!","text":"term!(lk::Link, func, args1...; kwargs...)\n\nTell an actor lk to execute func with the given partial arguments when it terminates. This is added by the actor to args1...  when it exit!s.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Diagnosis","page":"Actor API","title":"Diagnosis","text":"","category":"section"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Actors","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This example shows the basic primitives of Actors:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"spawn: create an actor and get a Link to it,\nsend!: send it a message,\nbecome!: cause it to change its behavior.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> using Actors, Printf\n\njulia> import Actors: spawn                 # this has to be imported\n\njulia> function pr(msg)                     # define two functions for printing a message\n           print(@sprintf(\"%s\\n\", msg))\n           become(pr, \"Next\") # change behavior\n       end\npr (generic function with 1 method)\n\njulia> pr(info, msg) = print(@sprintf(\"%s: %s\\n\", info, msg))\npr (generic function with 2 methods)\n\njulia> calc(op, x, y) = op(x, y)            # a function for doing arithmetic\ncalc (generic function with 1 method)\n\njulia> myactor = spawn(Func(pr))            # start an actor with the first behavior\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :local)\n\njulia> send!(myactor, \"My first actor\");    # send a message to it\nMy first actor\n\njulia> send!(myactor, \"Something else\")     # send again a message\nNext: Something else\n\njulia> become!(myactor, pr, \"New behavior\");# change the behavior to another one\n\njulia> send!(myactor, \"bla bla bla\")        # and send again a message\nNew behavior: bla bla bla\n\njulia> become!(myactor, calc, +, 10);       # become a machine for adding to 10\n\njulia> request!(myactor, 5)                 # send a request to add 5\n15\n\njulia> become!(myactor, ^);                 # become a exponentiation machine\n\njulia> request!(myactor, 123, 456)          # try it\n2409344748064316129","category":"page"},{"location":"actors/#Actors","page":"Actors","title":"Actors","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"CurrentModule = Actors","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors implements the classical Actor Model [1]. Actors are created as Julia tasks running on a computer or in a network and are represented by links over which they can send messages [2]. If they receive a message, they execute a behavior function. ","category":"page"},{"location":"actors/#Start","page":"Actors","title":"Start","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"To create an actor we spawn it with a behavior function:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"julia> using Actors, .Threads\n\njulia> import Actors: spawn\n\njulia> act1 = spawn(Func(threadid))             # start an actor which returns its threadid\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :local)\n\njulia> request!(act1)                           # call it\n2\n\njulia> using Distributed\n\njulia> addprocs(1);\n\njulia> @everywhere using Actors\n\njulia> act2 = spawn(Func(println), pid=2)       # start a remote actor on pid 2 with a println behavior\nLink{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 232), 2, :remote)\n\njulia> request!(act2, \"Tell me where you are!\") # and call it with an argument\n      From worker 2:    Tell me where you are!","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors are created with a behavior function and eventually partial arguments to it. We can then send them the remaining arguments later.","category":"page"},{"location":"actors/#Links","page":"Actors","title":"Links","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"The actor returned a Link over which it can receive messages. This is its only representation.","category":"page"},{"location":"actors/#Messages","page":"Actors","title":"Messages","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors act and communicate asynchronously. There are only two functions to interact with them:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"send!: send a message to an actor,\nreceive!: receive a message from an actor.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors follow a message protocol if they get a message of type Msg. This can be extended by a user.","category":"page"},{"location":"actors/#Behavior","page":"Actors","title":"Behavior","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"When an actor receives a message, it combines any partial arguments known to it with the message arguments and executes its behavior function.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"julia> mystack = spawn(Func(stack_node, StackNode(nothing, Link()))); # create an actor with a partial argument","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"mystack represents an actor with a stack_node behavior and a partial argument StackNode(nothing, Link()). When it eventually receives a message ...","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"julia> send!(mystack, Push(1))        # push 1 on the stack","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"..., it executes stack_node(StackNode(nothing, Link()), Push(1)).","category":"page"},{"location":"actors/#Actor-Control","page":"Actors","title":"Actor Control","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors can be controlled with the following functions:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become!: cause an actor to switch its behavior,\ncast!: cause an actor to execute its behavior function,\nexit!: cause an actor to terminate,\ninit!: tell an actor to execute a function at startup,\nterm!: tell an actor to execute a function when it terminates,\nupdate!: update an actor's internal state.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Those functions are wrappers to internal messages and to send!.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors can also operate on themselves, or rather they send messages to themselves:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become: an actor switches its own behavior,\nself: an actor gets a link to itself,\nstop: an actor stops.","category":"page"},{"location":"actors/#Bidirectional-Messages","page":"Actors","title":"Bidirectional Messages","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"What if you want to receive a reply from an actor? Then there are two possibilities:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"send! a message to an actor and then receive! the Response asynchronously,\nrequest!: send a message to an actor, block and receive the result synchronously.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"The following functions do this for specific duties:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"call! an actor to execute its behavior function and to send the result,\nexec!: tell an actor to execute a function and to send the result,\nquery! tell an actor's to send one of its internal state variables.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"If you provide those functions with a return link, they will use send! and you can then receive! the Response from the return link later. If you  don't provide a return link, they will use request! to block and return the result. Note that you should not use blocking when you need to be strictly responsive.","category":"page"},{"location":"actors/#Using-the-API","page":"Actors","title":"Using the API","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"The API functions allow to work with actors without using messages explicitly:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"julia> act4 = spawn(Func(+, 4))       # start an actor adding to 4\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :local)\n\njulia> request!(act4, 4)\n8","category":"page"},{"location":"actors/#Actor-Registry","page":"Actors","title":"Actor Registry","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"...","category":"page"},{"location":"actors/#Actor-Supervision","page":"Actors","title":"Actor Supervision","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"...","category":"page"},{"location":"actors/#Actor-Isolation","page":"Actors","title":"Actor Isolation","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"In order to avoid race conditions actors have to be strongly isolated from each other:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"they do not share state,\nthey must not share mutable variables.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"An actor stores the behavior function and arguments to it, results of computations and more. Thus it has state and this influences how it behaves.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"But it does not share its state variables with its environment (only for diagnostic purposes). The API functions above are a safe way to access actor state via messaging.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Mutable variables in Julia can be sent over local channels without being copied. Accessing those variables from multiple threads can cause race conditions. The programmer has to be careful to avoid those situations either by","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"not sharing them between actors,\ncopying them when sending them to actors or\nacquiring a lock around any access to data that can be observed from multiple threads. [3]","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"When sending mutable variables over remote links, they are automatically copied.","category":"page"},{"location":"actors/#Actor-Local-Dictionary","page":"Actors","title":"Actor Local Dictionary","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Since actors are Julia tasks, they have a local dictionary in which you can store values. You can use task_local_storage to access it in behavior functions. But normally argument passing should be enough to handle values in actors.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[1]: See: The Actor Model on Wikipedia and 43 Years of Actors.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[2]: They build on Julia's concurrency primitives  Task and Channel.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[3]: see Data race freedom in the Julia manual.","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"On JuliaActors there is a companion library SlowActors to illustrate the use of the interface. This is a completely different implementation of the Actor Model. It doesn't use Julia Channels for message passing and operates without an actor loop. Rather each time a message to a \"slow\" actor is sent, an actor Task is started.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"But in using the common Link type, actors from both libraries can communicate. With actually few lines of code SlowActors plugs in the Actors interface and is able to run the identical examples. It actually only reimplements three primitives: spawn, newLink and send!.","category":"page"},{"location":"protocol/#Message-Protocol","page":"Message Protocol","title":"Message Protocol","text":"","category":"section"},{"location":"protocol/","page":"Message Protocol","title":"Message Protocol","text":"CurrentModule = Actors","category":"page"},{"location":"protocol/","page":"Message Protocol","title":"Message Protocol","text":"Actors can be called, updated, queried … To do it they follow an internal message protocol.","category":"page"},{"location":"protocol/#Internal-Messages","page":"Message Protocol","title":"Internal Messages","text":"","category":"section"},{"location":"protocol/","page":"Message Protocol","title":"Message Protocol","text":"The API-functions are mostly using those messages:","category":"page"},{"location":"protocol/","page":"Message Protocol","title":"Message Protocol","text":"Become\nCall\nCast\nDiag\nExit\nExec\nInit\nQuery\nTerm\nTimeout\nUpdate","category":"page"},{"location":"protocol/#Actors.Become","page":"Message Protocol","title":"Actors.Become","text":"Become(x::Func)\n\nAn asynchronous Msg to an actor to change its  behavior.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#Actors.Call","page":"Message Protocol","title":"Actors.Call","text":"Call(arg, from::Link)\n\nA synchronous Msg to an actor to execute its  behavior with arg... and to send the result as a Response  message to from.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#Actors.Cast","page":"Message Protocol","title":"Actors.Cast","text":"Cast(arg)\n\nAn asynchronous Msg to an actor to execute  its behavior with arg... without sending a response.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"protocol/#Actors.Diag","page":"Message Protocol","title":"Actors.Diag","text":"Diag(from::Link)\n\nA synchronous Msg to an actor to send diagnostic information.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#Actors.Exit","page":"Message Protocol","title":"Actors.Exit","text":"Exit(reason=:ok, stack)\n\nA Msg causing an actor to stop with an exit code. If present, it calls its term! function with code as last argument.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#Actors.Exec","page":"Message Protocol","title":"Actors.Exec","text":"Exec(func::Func, from::Link)\n\nA synchronous Msg to an actor to execute func and to send a Response message with the return value to from.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#Actors.Init","page":"Message Protocol","title":"Actors.Init","text":"Init(f::Func)\n\nA Msg to an actor to execute the given Func and to register it in the _ACT variable.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#Actors.Query","page":"Message Protocol","title":"Actors.Query","text":"Query(s::Symbol, from::Link)\n\nA Msg to an actor to send a  Response message with one of its internal state  variables s to from.\n\ns::Symbol can be one of :sta, :res, :bhv, :dsp.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#Actors.Term","page":"Message Protocol","title":"Actors.Term","text":"Term(x::Func)\n\nA Msg to an actor to save the given Func  and to execute it upon termination.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#Actors.Timeout","page":"Message Protocol","title":"Actors.Timeout","text":"Timeout()\n\nA return value to signal that a timeout has occurred.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#Actors.Update","page":"Message Protocol","title":"Actors.Update","text":"Update(s::Symbol, x)\n\nAn asynchronous Msg to an actor to update its  internal state s to x.\n\ns::Symbol can be one of :arg, :self, :sta, :usr.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#User-extensions","page":"Message Protocol","title":"User extensions","text":"","category":"section"},{"location":"protocol/","page":"Message Protocol","title":"Message Protocol","text":"There are three ways to extend the messaging protocol and the functionality of Actors:","category":"page"},{"location":"protocol/","page":"Message Protocol","title":"Message Protocol","text":"If a user defines its own messages of type Msg and sends them to an actor, it passes them on as remaining argument to the behavior function.\nAlternatively a user can extend Actors.onmessage with his own methods to dispatch on those messages and doing user defined things.\nFinally a user can implement other message types and messaging protocols and extend Actors.onmessage for dispatching on those.","category":"page"},{"location":"behaviors/#Behaviors","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"CurrentModule = Actors","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"A behavior is a ...","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"... function to express what an actor does when it processes a message. [1]","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Actors represents a behavior as a Func object. This is a callable object func together with eventually partial or full arguments and keyword arguments to it.","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Behaviors can be set with spawn and changed with become!. Inside a behavior function an actor can change its own behavior with become. In both cases no arguments, partial or full arguments and keyword arguments can be specified with the behavior. ","category":"page"},{"location":"behaviors/#Partial-Arguments","page":"Behaviors","title":"Partial Arguments","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Partial arguments can constrain the behavior function func to work with given variables, e.g. a certain database, a state variable, a user request ... This is very useful since it specifies a behavior.","category":"page"},{"location":"behaviors/#dispatch","page":"Behaviors","title":"Behavior Dispatch","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"If arguments arrive with a message, an actor composes the previously set partial arguments with the received arguments and dispatches the behavior function with them. The arguments are composed from left to right, first the partial arguments, then the received ones.","category":"page"},{"location":"behaviors/#Keyword-Arguments","page":"Behaviors","title":"Keyword Arguments","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Keyword arguments are not dispatched on but they too can represent state and therefore can change the behavior.","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"[1]: see the Actor Model on Wikipedia.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"see the examples in the repository.","category":"page"},{"location":"#Actors.jl","page":"Home","title":"Actors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Concurrent programming in Julia with the Actor model.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A quick introduction to Actors,\nHow to use actors,\nHow to use behaviors,\nActors API: detailed documentation,\nInternals\nThe actor protocol,\nInterface for Julia actor libraries.","category":"page"},{"location":"#JuliaActors","page":"Home","title":"JuliaActors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Actors is part of the Julia GitHub group JuliaActors.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paul Bayer","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Actors is licensed under the MIT License.","category":"page"}]
}
