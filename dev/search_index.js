var documenterSearchIndex = {"docs":
[{"location":"infrastructure/#Infrastructure","page":"Infrastructure","title":"Infrastructure","text":"","category":"section"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"CurrentModule = Actors","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"Actors provides some functionality going beyond the classical model:","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"actor tasks and\nactor registry.","category":"page"},{"location":"infrastructure/#Actor-Tasks","page":"Infrastructure","title":"Actor Tasks","text":"","category":"section"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"Actor tasks execute one computation, mostly without communicating with other actors. They can be used to compute values asynchronously.","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"You can start actor tasks with async and get their result with await.","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"using Actors\nt = async(Bhv(^, 123, 456));\nawait(t)","category":"page"},{"location":"infrastructure/#Actor-Registry","page":"Infrastructure","title":"Actor Registry","text":"","category":"section"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"If a parent actor or worker process creates a new actor, the link to it is only locally known. It has to be sent to all other actors that want to communicate with it.","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"Now let's setup a remote worker and an ident function:","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"julia> using Actors, Distributed\n\njulia> import Actors: spawn\n\njulia> addprocs(1);\n\njulia> @everywhere using Actors\n\njulia> @everywhere function ident(id, from)\n           id == from ?\n               (\"local actor\",  id, from) :\n               (\"remote actor\", id, from)\n       end","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"An actor (link) can be registered under a name (a Symbol). This name then is known system-wide and any other actor can communicate with it using that name:","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"julia> register(:act1, spawn(ident, 1))      # a registered local actor\ntrue\n\njulia> call(:act1, myid())                   # call it locally\n(\"local actor\", 1, 1)\n\njulia> register(:act2, spawn(ident, 2, pid=2)) #  register a remote actor on pid 2\ntrue\n\njulia> call(:act2, myid())                   # call it locally\n(\"remote actor\", 2, 1)\n\njulia> fetch(@spawnat 2 call(:act1, myid())) # call :act1 on pid 2\n(\"remote actor\", 1, 2)\n\njulia> fetch(@spawnat 2 call(:act2, myid())) # call :act2 on pid 2\n(\"local actor\", 2, 2)","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"The registry provides three further functions:","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"API function brief description\nwhereis return the link of a registered actor\nregistered return an array of all registered actors\nunregister remove a registration","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"julia> whereis(:act1)                         # get a link to :act1\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> whereis(:act2)                         # get a link to :act2\nLink{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n\njulia> fetch(@spawnat 2 whereis(:act1))       # get a link to :act1 on pid 2\nLink{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 40), 1, :default)\n\njulia> registered()                           # get a list of registered actors\n2-element Array{Pair{Symbol,Link},1}:\n :act2 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n :act1 => Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> fetch(@spawnat 2 registered())         # get it on pid 2\n2-element Array{Pair{Symbol,Link{RemoteChannel{Channel{Any}}}},1}:\n :act2 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n :act1 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 46), 1, :default)","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"The registry works transparently across workers. All workers have access to registered actors on other workers via remote links.","category":"page"},{"location":"infrastructure/#Actor-Supervision","page":"Infrastructure","title":"Actor Supervision","text":"","category":"section"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"note: This is not yet implemented!\nIt is due to come with Actors v0.3.","category":"page"},{"location":"actors/#Actors-and-Julia","page":"Actors and Julia","title":"Actors and Julia","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"CurrentModule = Actors","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors implements the Actor model using Julia's concurrency primitives:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors are implemented as Tasks.\nThey communicate over Channels.","category":"page"},{"location":"actors/#Julia-is-Not-an-Actor-Language","page":"Actors and Julia","title":"Julia is Not an Actor Language","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"The actor model adopts the philosophy that everything is an actor. [1]","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"That implies that everything from access to variables or calling a function with multiple arguments in a programming language down to the routines of the operating system can and should be modeled as actors. But Erlang/Elixir/OTP and Scala/Akka show that actors can be successfully implemented even if they are not \"Actors all the way down\" [2].","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors therefore follows a pragmatic approach to integrate actors in a non-actor language. Sutter and Larus justified that as follows:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"We need higher-level language abstractions, including evolutionary extensions to current imperative languages, so that existing applications can incrementally become concurrent. The programming model must make concurrency easy to understand and reason about, not only during initial development but also during maintenance. [3]","category":"page"},{"location":"actors/#Julia-is-Well-Suited-for-Actors","page":"Actors and Julia","title":"Julia is Well Suited for Actors","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Like the Go language Julia goes beyond Communicating Sequential Processes (CSP) by introducing channels. Furthermore Julia is particularly strong with functions. Thus it offers better alternatives to sharing (global) memory between threads:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"share by communicating [4] and\nuse functions with local variables and\nwrap shared mutable variables into actors.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors both use functions as behaviors and communicate function parameters via messages. This makes it easier to write clear, correct concurrent programs.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Below I will argue and show that it makes sense to use  actors in standard multi-threading or distributed Julia code.","category":"page"},{"location":"actors/#Multi-threading","page":"Actors and Julia","title":"Multi-threading","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"The Julia manual encourages the use of locks [5] in order to ensure data-race freedom. But be aware that","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"they are not composable. You canâ€™t take two correct lock-based pieces of code, combine them, and know that the result is still correct. Modern software development relies on the ability to compose libraries into larger programs, and so it is a serious difficulty that we cannot build on lock-based components without examining their implementations. [6]","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"An actor controlling the access to a variable or to another resource is lock-free and there are no limits to composability. Therefore if you write multi-threaded programs which should be composable or maybe used by other programs within a lock, you might consider using Actors.","category":"page"},{"location":"actors/#Distributed-Computing","page":"Actors and Julia","title":"Distributed Computing","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors are location transparent. You can share their links across workers to access the same actor on different workers. If local links are sent to a remote actor, they are converted to remote links.","category":"page"},{"location":"actors/#dict-server","page":"Actors and Julia","title":"A Dict Server","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"This example shows how to implement a Dict-server actor that can be used in multi-threaded and distributed Julia code:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"# examples/mydict.jl\n\nmodule MyDict\nusing Actors\nimport Actors: spawn\n\nstruct DictSrv{L}\n    lk::L\nend\n(ds::DictSrv)() = call(ds.lk)\n(ds::DictSrv)(f::Function, args...) = call(ds.lk, f, args...)\n# indexing interface\nBase.getindex(d::DictSrv, key) = call(d.lk, getindex, key)\nBase.setindex!(d::DictSrv, value, key) = call(d.lk, setindex!, value, key)\n\n# dict server behavior\nds(d::Dict, f::Function, args...) = f(d, args...)\nds(d::Dict) = d\n# start dict server\ndictsrv(d::Dict; remote=false) = DictSrv(spawn(ds, d, remote=remote))\n\nexport DictSrv, dictsrv\n\nend","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"This module implements a DictSrv type with an indexing interface. A dict server is started with dictsrv. Let's try it out:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"julia> include(\"examples/mydict.jl\")\nMain.MyDict\n\njulia> using .MyDict, .Threads\n\njulia> d = dictsrv(Dict{Int,Int}())\nDictSrv{Link{Channel{Any}}}(Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default))\n\njulia> @threads for i in 1:1000\n           d[i] = threadid()\n       end\n\njulia> d()\nDict{Int64,Int64} with 1000 entries:\n  306 => 3\n  29  => 1\n  74  => 1\n  905 => 8\n  176 => 2\n  892 => 8\n  285 => 3\n  318 => 3\n  873 => 7\n  975 => 8\n  â‹®   => â‹®\n\njulia> d[892]\n8","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"All available threads did concurrently fill our served dictionary with their thread ids. Actor access to the dictionary happens almost completely behind the scenes.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Now we try it out with distributed computing:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"julia> using Distributed\n\njulia> addprocs();\n\njulia> nworkers()\n17\n\njulia> @everywhere include(\"examples/mydict.jl\")\n\njulia> @everywhere using .MyDict\n\njulia> d = dictsrv(Dict{Int,Int}(), remote=true)\nDictSrv{Link{RemoteChannel{Channel{Any}}}}(Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 278), 1, :default))\n\njulia> @spawnat :any d[myid()] = rand(Int)\nFuture(4, 1, 279, nothing)\n\njulia> @spawnat 17 d[myid()] = rand(Int)\nFuture(17, 1, 283, nothing)\n\njulia> d()\nDict{Int64,Int64} with 2 entries:\n  4  => -4807958210447734689\n  17 => -8998327833489977098\n\njulia> fetch(@spawnat 10 d())\nDict{Int64,Int64} with 2 entries:\n  4  => -4807958210447734689\n  17 => -8998327833489977098","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"The remote DictSrv actor is available on all workers.","category":"page"},{"location":"actors/#Fault-Tolerance","page":"Actors and Julia","title":"Fault Tolerance","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"note: This has yet to be developed!\nThis will be implemented with the next major version.","category":"page"},{"location":"actors/#Actor-Isolation","page":"Actors and Julia","title":"Actor Isolation","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"In order to avoid race conditions actors have to be strongly isolated from each other:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"they do not share state,\nthey must not share mutable variables.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"An actor stores the behavior function and arguments to it, results of computations and more. Thus it has state and this influences how it behaves.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"But it does not share its state variables with its environment (only for diagnostic purposes). The API functions above are a safe way to access actor state via messaging.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Mutable variables in Julia can be sent over local channels without being copied. Accessing those variables from multiple threads can cause race conditions. The programmer has to be careful to avoid those situations either by","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"not sharing them between actors,\ncopying them when sending them to actors or\nrepresenting them by an actor.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"When sending mutable variables over remote links, they are automatically copied.","category":"page"},{"location":"actors/#Actor-Local-Dictionary","page":"Actors and Julia","title":"Actor Local Dictionary","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Since actors are Julia tasks, they have a local dictionary in which you can store values. You can use task_local_storage to access it in behavior functions. But normally argument passing should be enough to handle values in actors.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[1]: Wikipedia. Actor Model: Fundamental Concepts","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[2]: That is to paraphrase Dale Schumacher's wonderful blog Actors all the way down.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[3]: H. Sutter and J. Larus. Software and the concurrency revolution. ACM Queue, 3(7), 2005.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[4]: Effective Go: Share by Communicating","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[5]: see Data race freedom in the Julia manual.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[6]: H. Sutter and J. Larus. see above","category":"page"},{"location":"protocol/#The-Actors-Protocol","page":"The Actors Protocol","title":"The Actors Protocol","text":"","category":"section"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"CurrentModule = Actors","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Actors has predefined message types with respective onmessage methods. This gives your actors predefined behaviors going beyond the classical behavior. API functions provide an interface to that messaging protocol and facilitate actor control and message exchange.","category":"page"},{"location":"protocol/#Messaging-Patterns","page":"The Actors Protocol","title":"Messaging Patterns","text":"","category":"section"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"The actor protocol can be described as a series of messaging patterns. For every predefined message the actor executes a predefined behavior. Here is an overview:","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Message pattern brief description\nBecome Tell an actor to change its behavior.\nCall - Response Call an actor to execute its behavior and to respond with the result.\nDiag - Response Call an actor to respond with diagnostic information.\nExit Tell an actor to exit.\nExec - Response Call an actor to execute a function and to respond with the result.\nInit Tell an actor to execute an initialization function and to store it in its internal state.\nQuery - Response Call an actor to send a status variable/value.\nRequest This triggers the actor's default response to execute its behavior.\nTerm Tell an actor to execute a given behavior upon termination.","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Actors API functions are wrappers to those message patterns. As you have seen there are unidirectional messages (without response) for actor control and bidirectional messages.","category":"page"},{"location":"protocol/#Actor-Control","page":"The Actors Protocol","title":"Actor Control","text":"","category":"section"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Actors can be controlled with the following functions:","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"API function brief description\nbecome! cause an actor to switch its behavior\ncast cause an actor to execute its behavior function\nexit! cause an actor to terminate\ninit! tell an actor to execute a function at startup\nterm! tell an actor to execute a function when it terminates\nupdate! update an actor's internal state","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Actors can also operate on themselves, or rather they send themselves messages:","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"API function brief description\nbecome an actor switches its own behavior\nself an actor gets a link to itself\nstop an actor stops","category":"page"},{"location":"protocol/#Bidirectional-Messages","page":"The Actors Protocol","title":"Bidirectional Messages","text":"","category":"section"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"To receive a reply from an actor there are two possibilities:","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"API function brief description\nreceive after a send receive the Response asynchronously\nrequest send (implicitly) a message to an actor, block and receive the result synchronously","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"The following functions do that for specific duties:","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"API function brief description\ncall tell an actor to execute its behavior function and to send the result\nexec tell an actor to execute a function and to send the result\nquery tell an actor's to send one of its internal state variables","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Those functions support both asynchronous and synchronous communication.","category":"page"},{"location":"protocol/#Enhancing-the-Protocol","page":"The Actors Protocol","title":"Enhancing the Protocol","text":"","category":"section"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"The Actors protocol can be enhanced or altered by","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"introducing new messages and onmessage methods,\nswitching the actor mode and writing new onmessage methods for existing messages\nor both.","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Libraries can do this for specific duties and plugin their protocols into Actors. Examples of such libraries are GenServers and Guards.","category":"page"},{"location":"errors/#Error-Handling","page":"Error Handling","title":"Error Handling","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"Actors follows Erlang's philosophy to let actors fail and then to recover.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"The error handling based on this has yet to be implemented:","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"grouping of actors\nmonitoring\nsystem actors (for supervision)","category":"page"},{"location":"examples/examples/#Further-Examples","page":"Further Examples","title":"Further Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Further Examples","title":"Further Examples","text":"In the manual there are the following examples:","category":"page"},{"location":"examples/examples/","page":"Further Examples","title":"Further Examples","text":"Table-tennis,\nAgha's Stack example,\nA Dict Server","category":"page"},{"location":"examples/examples/","page":"Further Examples","title":"Further Examples","text":"See also the examples in the repository.","category":"page"},{"location":"basics/#Actor-Model","page":"Actor Model","title":"Actor Model","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"CurrentModule = Actors","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"The Actor Model was originally proposed by Carl Hewitt et. al. in the 70es and since then has evolved into different families [1]. ","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"We focus here on the classical Actor Model described by Gul Agha in Actors [2]. This sees an actor as the universal primitive of concurrent computation:","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"An actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [3]","category":"page"},{"location":"basics/#Actor-Characteristics","page":"Actor Model","title":"Actor Characteristics","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Actor systems and actors have the following basic characteristics[4] :","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"communication via direct asynchronous messaging,\nactors support finite state machines,\nactors do not share their mutable state,\nlock-free concurrency,\nactors support parallelism,\nactors tend to come in systems.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Modern actor implementations extend those by","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"location transparency: this enables actors of different kinds and on different systems to communicate,\nsupervision: actors form a dependency relationship where a parent actor supervises child/subordinate ones. This is used to implement fault tolerant systems.\nactor protocols: there are predefined actors  following a specific message protocol to implement complex behaviors e.g. as generic server, supervisor, router, publish-subscribe ...  ","category":"page"},{"location":"basics/#Actor-Primitives","page":"Actor Model","title":"Actor Primitives","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"The actor machinery is based on only a few basic primitives defined in ActorInterfaces.Classic:","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Primitive Brief description\nAddr an address identifying an actor,\nself() get the address of the current actor,\nspawn(bhv) create an actor from a behavior and return an address,\nsend(addr, msg) send a message to an actor,\nbecome(bhv) an actor designates a new behavior,\nonmessage(bhv, msg) is executed by the actor when a message arrives.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"A user can write actor programs using only those basic primitives. Those programs should run with minor modifications on other libraries supporting the same basic interface.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"note: The interface needs yet work!\nAt the moment the Actors implementation of the interface in ActorInterfaces.Classic is not complete as it doesn't support context injection with @ctx.","category":"page"},{"location":"basics/#table-tennis","page":"Actor Model","title":"A Classic Example","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Now a small toy example for concurrency with actors using only the classic primitives. We simulate table-tennis where a player has a name and a capability. If he gets a ball with a difficulty exceeding his capability, he looses it. Players log to a print server actor.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"using Actors, Printf, Random\nimport Actors: spawn\n\nstruct Player{S,T}\n    name::S\n    capa::T\nend\n\nstruct Ball{T,S,L}\n    diff::T\n    name::S\n    from::L\nend\n\nfunction (p::Player)(prn, b::Ball)\n    if p.capa â‰¥ b.diff\n        send(b.from, Ball(rand(), p.name, self()))\n        send(prn, p.name*\" serves \"*b.name)\n    else\n        send(prn, p.name*\" looses ball from \"*b.name)\n    end\nend\nfunction (p::Player)(prn, ::Val{:serve}, to)\n    send(to, Ball(rand(), p.name, self()))\n    send(prn, p.name*\" serves \")\nend","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"In order to get reproducible results we initialize our random generator on each thread and assign threads to  players.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"The print server prn gets an anonymous function as behavior. The two players ping and pong get the print server's link as acquaintance. We start the game by sending ping the :serve command and the address of pong:","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"@threads for i in 1:nthreads()\n    Random.seed!(2021+threadid())\nend\n\nprn = spawn(s->print(@sprintf(\"%s\\n\", s))) \nping = spawn(Player(\"Ping\", 0.8), prn, thrd=3)\npong = spawn(Player(\"Pong\", 0.75), prn, thrd=4)\n\nsend(ping, Val(:serve), pong);","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"To execute the program we include the file:","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"julia> include(\"examples/pingpong.jl\");\n\nPing serves \nPong serves Ping\nPing serves Pong\nPong serves Ping\nPing serves Pong\nPong looses ball from Ping","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Actors are great for simulation.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[1]: De Koster, Van Cutsem, De Meuter 2016. 43 Years of Actors: A Taxonomy of Actor Models and Their Key Properties.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[2]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[3]: See the Wikipedia entry on the Actor Model.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[4]: Here I follow roughly: Vernon, Vaughn 2016. Reactive messaging patterns with the Actor model: applications and integration in Scala and Akka, Pearson","category":"page"},{"location":"messages/#Messages","page":"Messages","title":"Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"CurrentModule = Actors","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Actors can be called, updated, queried â€¦ To do it they follow a onmessage protocol on the following internal messages.","category":"page"},{"location":"messages/#Internal-Messages","page":"Messages","title":"Internal Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"Become\nCall\nCast\nDiag\nExit\nExec\nInit\nQuery\nTerm\nTimeout\nUpdate","category":"page"},{"location":"messages/#Actors.Become","page":"Messages","title":"Actors.Become","text":"Become(bhv)\n\nAn asynchronous Msg to an actor to change its  behavior to bhv.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Call","page":"Messages","title":"Actors.Call","text":"Call(arg, from::Link)\n\nA synchronous Msg to an actor to execute its  behavior with arg... and to send the result as a Response  message to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Cast","page":"Messages","title":"Actors.Cast","text":"Cast(arg)\n\nAn asynchronous Msg to an actor to execute  its behavior with arg... without sending a response.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Diag","page":"Messages","title":"Actors.Diag","text":"Diag(x, from::Link)\n\nA synchronous Msg to an actor to send diagnostic information.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Exit","page":"Messages","title":"Actors.Exit","text":"Exit(reason=:ok, stack=nothing)\n\nA Msg causing an actor to stop with an exit reason. If present, it calls its term!  function with reason as last argument.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Exec","page":"Messages","title":"Actors.Exec","text":"Exec(func::Bhv, from::Link)\n\nA synchronous Msg to an actor to execute func and to send a Response message with the return value to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Init","page":"Messages","title":"Actors.Init","text":"Init(f::Bhv)\n\nA Msg to an actor to execute the given Bhv and to store it in the _ACT variable.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Query","page":"Messages","title":"Actors.Query","text":"Query(s::Symbol, from::Link)\n\nA Msg to an actor to send a  Response message with one of its internal state  variables s to from.\n\ns::Symbol can be one of :sta, :res, :bhv, :dsp.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Term","page":"Messages","title":"Actors.Term","text":"Term(x::Bhv)\n\nA Msg to an actor to save the given Bhv  and to execute it upon termination.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Timeout","page":"Messages","title":"Actors.Timeout","text":"Timeout()\n\nA return value to signal that a timeout has occurred.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Update","page":"Messages","title":"Actors.Update","text":"Update(s::Symbol, x)\n\nAn asynchronous Msg to an actor to update its  internal state s to x.\n\ns::Symbol can be one of :arg, :self, :sta, :usr.\n\n\n\n\n\n","category":"type"},{"location":"messages/#User-extensions","page":"Messages","title":"User extensions","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"There are four ways to extend the messaging protocol and the functionality of Actors:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"If a user defines its own messages of type Msg and sends them to an actor, it passes them on as remaining argument to the behavior function.\nAlternatively a user can extend Actors.onmessage with his own methods to dispatch on those messages and doing user defined things.\nA user can set the actor mode with spawn or change it with update! to something other than :default, e.g. :mymode. If he then implements a method Actors.onmessage(A::_ACT, ::Val{:mymode}, msg::Call) and so on, the actor will dispatch that one when it receives a Call message.\nFinally a user can implement other message types and messaging protocols and extend Actors.onmessage for dispatching on those.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"CurrentModule = Actors","category":"page"},{"location":"intro/#Getting-Started-with-Actors","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"You may have heard about the Actor Model, but at first we present actors as practical things, which you can spawn, send messages to, receive or request messages from, call, cast to them, query and update! them. Please follow along in your Julia REPL and don't hesitate to try things out.","category":"page"},{"location":"intro/#Creation:-spawn","page":"Getting Started with Actors","title":"Creation: spawn","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The basic mechanism to create a new actor is the spawn function. You have to import it explicitly:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"using Actors\nimport Actors: spawn, newLink","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"You spawn an actor with a behavior. A behavior is a callable Julia object.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"myactor = spawn(Threads.threadid)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"spawn returned an actor link. Now - as we will discover right away - our actor is responsive and waits for our messages.","category":"page"},{"location":"intro/#Actor-Links","page":"Getting Started with Actors","title":"Actor Links","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"A Link is the actor's mail address and its only representation. Over the returned link it is possible to send messages to the actor or to use other messaging functions. For example if you call or request it, you send a Call message to the actor to execute its behavior and to respond with the result:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"call(myactor)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Now what happens if you send your actor a message which it cannot understand?","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, \"Boom\")\nActors.info(myactor)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We caused our actor to fail. Ouch!","category":"page"},{"location":"intro/#Behaviors:-become-and-become!","page":"Getting Started with Actors","title":"Behaviors: become and become!","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We want our actor to do something more meaningful! Let's write our own behavior. We want it to calculate something and to send the result back to a given address:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"function calc(addr::Link, f::Function, args...)\n    send(addr, f(args...))\nend","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"With newLink we create a link for ourselves, spawn a new actor with a calc behavior and give it that newly created link as acquaintance parameter:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"me = newLink()\nmyactor = spawn(calc, me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We applied our calc function partially to me. Now our actor holds the me link as acquaintance and we need to send it only the rest of the parameters to cause it to execute the given function f on some parameters and to send the result back:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, +, 1, 2, 3, 4)\nreceive(me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"If we want our actor to do only multiplication, we can change its behavior with become! to calc with new acquaintances:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"become!(myactor, calc, me, *);","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The actor's new behavior is calc with two acquaintances me and *, and thus it does multiplication only. As before we send it the communication parameters to multiply and receive the result:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, 1,2,3,4)\nreceive(me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"An actor can change also its own behavior with become. Since what an actor does is defined by its behavior, become inside the behavior function  causes the actor to switch to a new behavior. Instead become! is a call from the outside of an actor. A behavior change is effective for the next message an actor receives.","category":"page"},{"location":"intro/#Communication:-send-and-receive","page":"Getting Started with Actors","title":"Communication: send and receive","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"When we used send and receive in our experiments so far, we did asynchronous communication with our actor. After sending something  we could have done other work and then receive the result later.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"What happens if we try to receive something from a failed actor?","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, 5, \"x\")\nreceive(me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"After some seconds we got a Timeout().","category":"page"},{"location":"intro/#Actor-Protocol:-request","page":"Getting Started with Actors","title":"Actor Protocol: request","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We don't give up with it and start it again, but now we want an adding machine with an offset of 1000:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"myactor = spawn(+, 1000)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Our actor now has no acquaintance of me, neither has its behavior any send instruction. If we send it something, it will only add that to 1000 but not respond anything.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Here the actor protocol comes to our rescue. It allows us to communicate with actors even if their behaviors don't send anything. Actors understand messaging patterns.  For example if we send an actor a Call, it knows that it must send a Response with the result. Let's try that out:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, Actors.Call((1,2,3), me))\nreceive(me)\nans.y","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The actor added (1,2,3) to 1000 and sent the result back to the provided link. Then we received it asynchronously.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The request function is a wrapper for synchronous bidirectional communication. It will create a link internally and send it with the communication parameters as a Call (or another given message type) to the actor. That one sends a Response back to the received link, and request then delivers the response:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"request(myactor, 1,2,3)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"This is called synchronous communication since request blocks until it receives the result (or a Timeout()).","category":"page"},{"location":"intro/#More-Control:-call,-cast,-exec,-query,-update!-...","page":"Getting Started with Actors","title":"More Control: call, cast, exec, query, update! ...","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"There are more such actor protocols and API functions.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We can do asynchronous communication with our actor if we use call with the me link. This sends the given link to the actor and it responds to it. Then we can receive the result asynchronously:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"call(myactor, me, 1000)\nreceive(me).y","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"If we don't provide a return link to call, it will use request and deliver the result synchronously:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"call(myactor, 2000)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Another possibility to communicate asynchronously with an actor is to cast it parameters and then to query the result afterwards.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"cast(myactor, 3000)\nquery(myactor, :res)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"But this will work fine only if between those two calls to myactor there is not another actor communicating with it. If for example our actor has mutual variables as acquaintances, we can use cast to set parameters or to do anything else where we don't need a response.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"With exec we can tell an actor to execute any function and to deliver the result:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"exec(myactor, broadcast, cos, pi .* (-2:2))","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Actors have internal state variables which we normally don't need to work with. We can update! those variables. One example for such a use is to update! the actor's current acquaintance parameter (1000) to 500. Then it adds to 500:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"update!(myactor, Args(500))\ncall(myactor, 500)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"But we could have achieved the same with become!(myactor, +, 500).","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Finally we exit! the actor since we are finished with this introduction:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"exit!(myactor)\nsend(myactor, 500)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Trying to send it something now throws an exception.","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"CurrentModule = Actors","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"warning: The interface is yet experimental!\nMost of the following needs yet work .","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Actors provides a versatile interface to work with other actor libraries in the JuliaActors ecosystem or to allow programmers and users alike to extend its functionality:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"It is written against ActorInterfaces.Classic. Thus it can execute programs written with the primitives in that interface.\nActors from other libraries written with that interface have actor level compatibility. Thus they can exchange messages, use the Actors registry (and upcoming supervision).\nOther libraries written against that interface can plugin the Actors' onmessage protocol and thus inherit the user API functions: call, cast ...\nOther party libraries can start actors in another mode and implement a different onmessage protocol to make their actors do different things.\nUsers can enhance the implemented Msg types and extend the onmessage methods for working with those messages.","category":"page"},{"location":"interface/#Reimplementing-Actor-Primitives","page":"Interface","title":"Reimplementing Actor Primitives","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"On JuliaActors there is a companion library SlowActors to illustrate one use of the interface. This is a completely different implementation of the Actor Model. It doesn't use Julia Channels for message passing and operates without an actor loop. Rather each time a message to a \"slow\" actor is sent, an actor Task is started.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"But in using the common Link type, actors from both libraries can communicate. With actually few lines of code SlowActors plugs in the Actors interface and is able to run the identical examples. It actually only reimplements three primitives: spawn, newLink and send!.","category":"page"},{"location":"interface/#Change-Actor-Mode-and-Behavior","page":"Interface","title":"Change Actor Mode and Behavior","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Actors provides a mode field in both Link and _ACT, with mode=:default for normal operation.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Other libraries can spawn their actors with a different mode, e.g. mode=:GenServer. If they then enhance onmessage with e.g.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Actors.onmessage(A::_ACT, ::Val{:GenServer}, msg::Call) = ...\nActors.onmessage(A::_ACT, ::Val{:GenServer}, msg::Cast) = ...\n....","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"... they get for those messages a different actor behavior where they can do callbacks or set state or whatever they want to. Actors spawned with a different mode return a link with the mode field set accordingly.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Currently there are two libraries capitalizing on this functionality:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"library brief description\nGuards Actors guarding access to mutable variables.\nGenServers Actors representing generic servers and allowing users to write sequential code to use them.","category":"page"},{"location":"glossary/#A-Glossary-of-Actor-Terms","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"","category":"section"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"Since Gul Agha's actor glossary [1] is very useful, we include here some of his descriptions and some additions.","category":"page"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"Actor term brief description\nacquaintance An actor alpha is an acquaintance of an actor beta if beta knows the mail address of alpha.\nactor A computational agent which has an mail address and a behavior. Actors communicate by message-passing and carry out their actions concurrently.\nasynchronous communication Communication is considered to be asynchronous when the sender does not have to wait for the recipient to be ready to accept a communication before the sender can send the communication.\nbehavior The behavior of an actor maps the incoming communication to a three tuple of tasks created, new actors created, and the replacement behavior.\nbehaviour \"A behavior encapsulates common behavioral patterns.\" Armstrong [2] The Erlang world has a more complex view of behaviors. Such more complex behaviors can be realized with a message protocol.\ncommunication The only mechanism by which actors may affect each other's behavior. The content of a message sent by an actor is called a communication.\nconcurrency The potentially parallel execution of actions without a determinate predefined sequence for their actions.\ncustomer A request communication contains the mail address of an actor called the customer to which a reply to the request is to be sent. Customers are dynamically created to carry out the rest of the computation, so that an actor sending a request to another actor can begin processing the next incoming communication without waiting for the subcomputations of the previous communication to complete.\nevent In the actor model, an event is the acceptance of a communication by an actor. In response to accepting a communication, an actor creates other actors, sends communications and specifies a replacement behavior; in an event based semantics these actions are considered a part of the event.\nexternal actor An actor which is external to a configuration but whose mail address is known to some actor within the configuration.\nfuture A future is an actor representing the value of a computation in progress. Futures can speed up computation since they allow subcomputations using references to a value to proceed concurrently with the evaluation of an expression to compute the value. Communications sent to a future are queued until the value has been determined.\nmail address A virtual location by which an actor may be accessed. Each actor has a unique mail address which is invariant, although the behavior of an actor may change over time.\nmail queue The queue of incoming communications sent to a given actor. The mail queue represents the arrival order of communications and provides the means to buffer communications until they are processed by the target actor.\nprotocol An actor follows a protocol if it â€“ when receiving certain messages â€“ executes predefined behaviors other than its current behavior. This is used to implement more complex behaviors and goes beyond the classical model.\nreceptionist An actor to whom communications may be sent from outside the configuration to which it belongs. The set of receptionists evolves dynamically as the mail addresses of various actors may be communicated to actors outside the system.\nreplacement behavior A behavior specified by an actor processing a communication which is used to process the next communication in the mail queue of the actor.\nreply A communication sent in response to a request (see also customers).\nrequest A communication asking for a response to be sent to a customer contained in the request.\nsynchronous communication Communication between two actors requiring the sender to wait until the recipient acknowledges or otherwise responds to the communication before continuing with further processing. Synchronous communication in actors is implemented using customers.","category":"page"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"[1]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT; Appendix B","category":"page"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"[2]: Joe Armstrong 2014. Programming Erlang, 2nd Ed., Software for a Concurrent World, Pragmatic Programmers; p. 361","category":"page"},{"location":"api/#Actor-API","page":"API","title":"Actor API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Actors","category":"page"},{"location":"api/","page":"API","title":"API","text":"Actors\nActors.version","category":"page"},{"location":"api/#Actors.Actors","page":"API","title":"Actors.Actors","text":"Actors implements the classical Actor Model and is  based on the primitives defined in ActorInterfaces.Classic.  It provides:\n\nbasic primitives for creating actors,   sending messages to them and changing behavior:   spawn, send, become    with Addr and self,\nonmessage, executed by an actor on a    received message,\na Msg message protocol with onmessage and    predefined messages,\nan actor API based on the protocol with primitives   receive and request and further    API functions become!, call,    cast, exec, exit!,    init!, query, term!,    update!,\nactor tasks with async and await,\nan actor registry and more.\n\nThe current stable, registered version is installed with\n\npkg> add Actors\n\nThe development version is installed with:\n\npkg> add \"https://github.com/JuliaActors/Actors.jl\"\n\n\n\n\n\n","category":"module"},{"location":"api/#Actors.version","page":"API","title":"Actors.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"api/","page":"API","title":"API","text":"using Actors\nActors.version","category":"page"},{"location":"api/#Basic-Types","page":"API","title":"Basic Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following types are needed for using and extending Actors:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Msg\nRequest\nResponse\nLink\nBhv\n_ACT","category":"page"},{"location":"api/#Actors.Msg","page":"API","title":"Actors.Msg","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Request","page":"API","title":"Actors.Request","text":"Request(x, from::Link)\n\nA generic Msg for user requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Response","page":"API","title":"Actors.Response","text":"Response(y, from::Link=self())\n\nA Msg representing a response to requests.\n\nFields\n\ny: response content,\nfrom::Link: sender link.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Link","page":"API","title":"Actors.Link","text":"Link{C} <: ActorInterfaces.Classic.Addr\nLink(chn::C, pid::Int, type::Symbol) where C\n\nA mailbox for communicating with actors. A concrete type of this must be returned by an actor on creation with spawn.\n\nFields/Parameters\n\nchn::C: C can be any type and characterizes the interface   to an actor,\npid::Int: the pid (worker process identifier) of the actor, \nmode::Symbol: a symbol characterizing the actor mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Bhv","page":"API","title":"Actors.Bhv","text":"Bhv(func, a...; kw...)(c...)\n\nA callable struct to represent actor behavior. It is executed with parameters from the incoming communication.\n\nParameters\n\nf: a callable object,\na...: stored acquaintance parameters to f,\nkw...: stored keyword arguments,\nc...: parameters from the incoming communication.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors._ACT","page":"API","title":"Actors._ACT","text":"_ACT\n\nInternal actor status variable.\n\nFields\n\nmode::Symbol: the actor mode,\nbhv::AbstractBehavior: a partial function or a function object,\ninit::Union{Nothing,Function}: the init function and its arguments,\nterm::Union{Nothing,Function}: the terminate function and its arguments,\nself::Link: the actor's address,\nname::Union{Nothing,Symbol}: the actor's registered name.\nres::Any: the result of the last behavior execution,\nsta::Any: a variable for representing state,\nusr::Any: user variable for plugging in something.\n\nsee also: Bhv, Link\n\n\n\n\n\n","category":"type"},{"location":"api/#Starting-Actors,-creating-links","page":"API","title":"Starting Actors, creating links","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Actors.jl doesn't export its functions to start actors and to create links. Thus other libraries building on it can implement their own actors and links.","category":"page"},{"location":"api/","page":"API","title":"API","text":"To use Actors's actors and links you import them explicitly:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Actors\nimport Actors: spawn, newLink","category":"page"},{"location":"api/","page":"API","title":"API","text":"Then you can create them with the following functions:","category":"page"},{"location":"api/","page":"API","title":"API","text":"spawn\nnewLink","category":"page"},{"location":"api/#ActorInterfaces.Classic.spawn","page":"API","title":"ActorInterfaces.Classic.spawn","text":"spawn(f, args...; \n      pid=myid(), thrd=false, sticky=false, \n      taskref=nothing, remote=false, mode=:default)\n\nCreate an actor with a behavior f(args...) and return  a Link to it.\n\nParameters\n\nf: callable object (function, closure or functor)   to execute when a message arrives,\nargs...: (partial) arguments to it,\npid=myid(): pid of worker process the actor should be started on,\nthrd=false: thread number the actor should be started on or false,\nsticky=false: if true the actor is started on the current thread,\ntaskref=nothing: if a Ref{Task}() is given here, it gets the started Task,\nremote=false: if true, a remote channel is created,\nmode=:default: mode, the actor should operate in.\n\nNote: If you need keyword arguments kwargs... to  f, you can do spawn(Bhv(f, args...; kwargs...)).\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.newLink","page":"API","title":"Actors.newLink","text":"newLink(size=32; remote=false, pid=myid(), mode=nothing)\n\nCreate a local Link with a buffered Channel size â‰¥ 1.\n\nParameters\n\nsize=32: the size of the channel buffer,\nremote=false: should a remote link be created,\npid=myid(): optional pid of the remote worker,\nmode=nothing: if mode==nothing the mode is automatically   set to :local or :remote.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actor-Primitives","page":"API","title":"Actor Primitives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following primitives characterize actors in the classical Actor Model:","category":"page"},{"location":"api/","page":"API","title":"API","text":"send\nbecome!\nbecome\nself\nstop\nonmessage","category":"page"},{"location":"api/#ActorInterfaces.Classic.send","page":"API","title":"ActorInterfaces.Classic.send","text":"send(lk::Link, msg...)\n\nSend a message to an actor. msg... are communication parameters to the actor's behavior function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.become!","page":"API","title":"Actors.become!","text":"become!(lk::Link, func, args1...; kwargs...)\nbecome!(name::Symbol, ....)\n\nCause an actor to change behavior.\n\nArguments\n\nactor lk::Link (or name::Symbol if registered),\nfunc: a callable object,\nargs1...: (partial) arguments to func,\nkwargs...: keyword arguments to func.\n\n\n\n\n\n","category":"function"},{"location":"api/#ActorInterfaces.Classic.become","page":"API","title":"ActorInterfaces.Classic.become","text":"become(func, args...; kwargs...)\n\nCause your actor to take on a new behavior. This can only be called from inside an actor/behavior.\n\nArguments\n\nfunc: a callable object,\nargs...: (partial) arguments to func,\nkwargs...: keyword arguments to func.\n\n\n\n\n\n","category":"function"},{"location":"api/#ActorInterfaces.Classic.self","page":"API","title":"ActorInterfaces.Classic.self","text":"self()\n\nGet the Link of your actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.stop","page":"API","title":"Actors.stop","text":"stop(reason::Symbol)\n\nCause your actor to stop with a reason.\n\n\n\n\n\n","category":"function"},{"location":"api/#ActorInterfaces.Classic.onmessage","page":"API","title":"ActorInterfaces.Classic.onmessage","text":"onmessage(bhv, msg...)\n\nDefault behavior function to execute the current actor  behavior bhv with the message msg. The actor calls bhv(msg...) when a message arrives. \n\nParameters\n\nbhv: excutable object (closure or functor) taking   parameters msg...,\nmsg...: message parameters to bhv.\n\n\n\n\n\nonmessage(A::_ACT, msg)\nonmessage(A::_ACT, mode, msg)\n\nAn actor executes this function when a message arrives.\n\nActor libraries or applications can use this to\n\nplugin the Actors.jl API (first form) or\nextend it to other protocols by using the 2nd form.\n\n\n\n\n\n","category":"function"},{"location":"api/#API-Primitives","page":"API","title":"API Primitives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"To receive messages from actors the following two functions for synchronous and asynchronous communication can be used:","category":"page"},{"location":"api/","page":"API","title":"API","text":"receive\nrequest","category":"page"},{"location":"api/#Actors.receive","page":"API","title":"Actors.receive","text":"receive(lk; timeout=5.0)\nreceive(lk, from; timeout=5.0)\nreceive(lk, M; timeout=5.0)\nreceive(lk, M, from; timeout=5.0)\n\nReceive a message over a link lk.\n\nIf M or from are provided, receive returns only a  matching message. Other messages in lk are restored to it in their previous order.\n\nParameters\n\nlk::Link: local or remote link over which the message is received,\nM::Type{<:Msg}: Msg type,\nfrom::Link: local or remote link of sender. If from is   provided, only messages with a from field can be matched.\ntimeout::Real=5.0: maximum waiting time in seconds.\nIf timeout==0, lk is scanned only for existing messages.\nSet timeout=Inf if you don't want to timeout. \n\nReturns\n\nreceived message or Timeout().\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.request","page":"API","title":"Actors.request","text":"request(lk::Link, msg::Msg; full=false, timeout::Real=5.0)\nrequest(lk::Link, M::Type{<:Msg}, args...; kwargs...)\n\nSend a message to an actor, block, receive and return the result.\n\nArguments\n\nlk::Link: actor link, or name::Symbol (if registered),\nmsg::Msg: a message,\nMsg::Type{<:Msg}: a message type,\nargs...: optional arguments to Msg, \nfull: if true return the full Response message.\ntimeout::Real=5.0: timeout in seconds after which a    Timeout is returned,\nkwargs...: full or timeout.\n\n\n\n\n\n","category":"function"},{"location":"api/#User-API","page":"API","title":"User API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The user API allows you to communicate with actors using the Actors protocol:","category":"page"},{"location":"api/","page":"API","title":"API","text":"call\ncast\nexec\nexit!\nquery\nupdate!","category":"page"},{"location":"api/#Actors.call","page":"API","title":"Actors.call","text":"call(lk::Link, [from::Link,] args2...; timeout::Real=5.0)\ncall(name::Symbol, ....)\n\nCall an actor to execute its behavior and to send a  Response with the result. \n\nArguments\n\nactor lk::Link (or name::Symbol if registered), \nfrom::Link: sender link, \nargs2...: remaining arguments to the actor.\ntimeout::Real=5.0: timeout in seconds.\n\nNote: If from is omitted, call blocks and returns the result\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.cast","page":"API","title":"Actors.cast","text":"cast(lk::Link, args2...)\ncast(name::Symbol, args2...)\n\nCast args2... to the actor lk (or name if registered)  to execute its behavior with args2... without sending a  response. \n\nNote: you can prompt the returned value with query.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.exec","page":"API","title":"Actors.exec","text":"exec(lk::Link, from::Link, f, args...; kwargs...)\nexec(lk::Link, f, args...; timeout::Real=5.0, kwargs...)\nexec(name::Symbol, ....)\n\nAsk an actor lk (or name if registered) to execute an  arbitrary function and to send the returned value as  Response.\n\nArguments\n\nactor lk::Link or name::Symbol if registered,\nfrom::Link: the link a Response should be sent to.\nf: a callable object,\nargs...; kwargs...: arguments and keyword arguments to it,\ntimeout::Real=5.0: timeout in seconds. Set timeout=Inf    if you don't want to timeout.\n\nNote: If from is ommitted, exec blocks, waits and  returns the result (with a timeout).\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.exit!","page":"API","title":"Actors.exit!","text":"exit!(lk::Link, reason=:ok)\nexit!(name::Symbol, ....)\n\nTell an actor lk (or name if registered) to exit. If it  has a term function, it calls it with  reason as last argument. \n\nnote: This behavior is not yet fully implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.query","page":"API","title":"Actors.query","text":"query(lk::Link, [from::Link,] s::Symbol; timeout::Real=5.0)\nquery(name::Symbol, ....)\n\nQuery an actor about an internal state variable s. \n\nParameters\n\nactor lk::Link or name::Symbol if registered,\nfrom::Link: sender link,\ns::Symbol one of :mode,:bhv,:res,:sta,:usr.\ntimeout::Real=5.0: \n\nNote: If from is omitted, query blocks and returns  the response. In that case there is a timeout.\n\nExamples\n\njulia> f(x, y; u=0, v=0) = x+y+u+v  # implement a behavior\nf (generic function with 1 method)\n\njulia> fact = spawn(Bhv(f, 1))     # start an actor with it\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> query(fact, :mode)           # query the mode\n:default\n\njulia> cast(fact, 1)                # cast a 2nd argument to it\nActors.Cast((1,))\n\njulia> query(fact, :res)            # query the result\n2\n\njulia> query(fact, :sta)            # query the state\n\njulia> query(fact, :bhv)            # query the behavior\nBhv(f, (1,), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), Actors.var\"#2#4\"{Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},typeof(f),Tuple{Int64}}(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), f, (1,)))\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.update!","page":"API","title":"Actors.update!","text":"update!(lk::Link, x; s::Symbol=:sta)\nupdate!(lk::Link, arg::Args)\nupdate!(name::Symbol, ....)\n\nUpdate an actor's internal state s with args....\n\nArguments\n\nactor lk::Link or name::Symbol if registered,\nx: value/variable to update the choosen state with,\narg::Args: arguments to update,\ns::Symbol: one of :arg,:mode,:name,:self,:sta,:usr.\n\nNote: If you want to update the stored arguments to the  behavior function with s=:arg, you must pass an Args  to arg. If Args has keyword arguments, they are merged  with existing keyword arguments to the behavior function.\n\nExample\n\njulia> update!(fact, 5)       # update the state variable\nActors.Update(:sta, 5)\n\njulia> query(fact, :sta)      # query it\n5\n\njulia> update!(fact, Args(0, u=5, v=5));  # update arguments to the behavior \n\njulia> call(fact, 0)          # call the actor with 0\n10\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The following is needed for updating arguments:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Args","category":"page"},{"location":"api/#Actors.Args","page":"API","title":"Actors.Args","text":"Args(args...; kwargs...)\n\nA structure for updating arguments to an actor's behavior.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actor-Tasks","page":"API","title":"Actor Tasks","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ATask\nasync\nawait","category":"page"},{"location":"api/#Actors.ATask","page":"API","title":"Actors.ATask","text":"The actor task type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.async","page":"API","title":"Actors.async","text":"async(func; pid=myid(), thrd=false, sticky=false, taskref=nothing)\n\nStart a task to execute func and return an ATask  variable.\n\nAn actor task sends its result to the back link  of the ATask variable and exits immediately.\n\nParameters\n\nfunc: a callable object,\npid=myid(): pid of worker process the task should run on,\nthrd=false: thread number the should be started on,\nsticky=false: if true the task is started on the current thread,\ntaskref=nothing: if a Ref{Task}() is given here, it gets the started Task.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.await","page":"API","title":"Actors.await","text":"await(t::ATask; timeout::Real=5.0)\n\nAwait a task reply and return it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actor-Registry","page":"API","title":"Actor Registry","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Actors can be registered with Symbols to a registry. API functions on actors can then be called with their registered names.","category":"page"},{"location":"api/","page":"API","title":"API","text":"register\nunregister\nwhereis\nregistered","category":"page"},{"location":"api/#Actors.register","page":"API","title":"Actors.register","text":"register(name::Symbol, lk::Link)\n\nRegister the actor lk with name. Returns true if the  registration succeeds, false if name is already in use.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.unregister","page":"API","title":"Actors.unregister","text":"unregister(name::Symbol)\n\nRemove any registrations associated with name.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.whereis","page":"API","title":"Actors.whereis","text":"whereis(name::Symbol)\n\nFind out whether name is registered. Return the actor link  lk or missing if not found.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.registered","page":"API","title":"Actors.registered","text":"registered()\n\nReturn an Array of all registered actors in the system.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The registry works transparently over distributed worker processes such that local links are transformed to remote links when shared between workers.","category":"page"},{"location":"api/#Actor-Supervision","page":"API","title":"Actor Supervision","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This is not yet implemented.","category":"page"},{"location":"api/","page":"API","title":"API","text":"init!\nterm!","category":"page"},{"location":"api/#Actors.init!","page":"API","title":"Actors.init!","text":"init!(lk::Link, f, args...; kwargs...)\ninit!(name::Symbol, ....)\n\nTell an actor lk to save the callable object f with  the given arguments as an init function  and to execute it.\n\nThe init function will be called at actor restart.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.term!","page":"API","title":"Actors.term!","text":"term!(lk::Link, func, args...; kwargs...)\nterm!(name::Symbol, ....)\n\nTell an actor lk (or name::Symbol if registered) to  execute func with the given partial arguments and an exit reason when it terminates. \n\nThe exit reason is added by the actor to args1... when it  exits.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Diagnosis","page":"API","title":"Diagnosis","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In order to develop actor programs, it is useful to have access to the actor tasks and eventually to their stack traces. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"istaskfailed(::Link)\ninfo","category":"page"},{"location":"api/#Base.istaskfailed-Tuple{Link}","page":"API","title":"Base.istaskfailed","text":"istaskfailed(lk::Link)\n\nReturns true if a task associated with lk has failed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Actors.info","page":"API","title":"Actors.info","text":"info(lk::Link)\n\nReturn the state (eventually the stacktrace) of a task associated  with lk.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"For diagnostic purposes it is possible to get access to the actor's ACT variable:","category":"page"},{"location":"api/","page":"API","title":"API","text":"diag","category":"page"},{"location":"api/#Actors.diag","page":"API","title":"Actors.diag","text":"diag(lk::Link, check=0)\ndiag(name::Symbol, ....)\n\nGive an actor state or stacktrace.\n\nIf check != 0 return the internal _ACT variable of the  actor. This is for diagnosis and testing only!\n\n\n\n\n\n","category":"function"},{"location":"examples/dining_phil/#Dining-Philosophers","page":"Dining Philosophers","title":"Dining Philosophers","text":"","category":"section"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"This is a classic problem to illustrate challenges with concurrency. We will give here a solution based on Dale Schumacher's blogpost [1]. First some initial definitions:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"using Actors\nimport Actors: spawn\n\nconst eating_time = 5\nconst thinking_time = 10\nconst speedup = 100\n\nmutable struct Phil{L}\n    left::L\n    right::L\n    eaten::Float64\nend\n\ndelay(time, msg, cust) = async() do \n    sleep(time/speedup)\n    send(cust, msg)\nend","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"The first part of an actor based solution is that each chopstick between the philosophers is an actor. So only one access to a chopstick is possible at a time. And the philosophers will have to communicate with the chopsticks to take them:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"mutable struct Chopstick\n    idle::Bool\n    Chopstick() = new(true)\nend\n\nfunction (c::Chopstick)(cust, ::Val{:take})\n    if c.idle\n        send(cust, self(), Val(:taken))\n        c.idle = false\n    else\n        send(cust, self(), Val(:busy))\n    end\nend\n(c::Chopstick)(::Val{:put}) = c.idle = true","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"We have modeled a chopstick actor as a functor with two messages, :take and :put.","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"Now the philosophers! We model them with behavior functions representing their state, the respective philosopher as an acquaintance and state transitions with become. So a philosopher is a finite state machine:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"function thinking(p::Phil, ::Val{:eat})\n    send(p.left, self(), Val(:take))\n    send(p.right, self(), Val(:take))\n    become(hungry, p)\nend\nfunction hungry(p::Phil, chop, ::Val{:taken})\n    chop == p.left ?\n        become(right_waiting, p) :\n        become(left_waiting,  p)\nend\nhungry(p::Phil, chop, ::Val{:busy}) = become(denied, p)\nfunction denied(p::Phil, other, ::Val{:taken})\n    send(other, Val(:put))\n    become(thinking, p)\n    send(self(), Val(:eat))\nend\nfunction denied(p::Phil, chop, ::Val{:busy})\n    become(thinking, p)\n    send(self(), Val(:eat))\nend\nfunction right_waiting(p::Phil, chop, ::Val{:taken})\n    if chop == p.right \n        become(eating, p)\n        p.eaten += te = randn()+eating_time\n        delay(te, Val(:think), self())\n    end\nend\nfunction right_waiting(p::Phil, chop, ::Val{:busy})\n    send(p.left, Val(:put))\n    become(thinking, p)\n    send(self(), Val(:eat))\nend\nfunction left_waiting(p::Phil, chop, ::Val{:taken})\n    if chop == p.left\n        become(eating, p)\n        p.eaten += te = randn()+eating_time\n        delay(te, Val(:think), self())\n    end\nend\nfunction left_waiting(p::Phil, chop, ::Val{:busy})\n    send(p.right, Val(:put))\n    become(thinking, p)\n    send(self(), Val(:eat))\nend\nfunction eating(p::Phil, ::Val{:think})\n    send(p.left, Val(:put))\n    send(p.right, Val(:put))\n    become(thinking, p)\n    delay(randn()+thinking_time, Val(:eat), self())\nend","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"The crucial step here in preventing a deadlock is that a philosopher puts down his chopstick if he is  right_waiting or left_waiting and gets a :busy or if he is denied and gets a :taken message. Then he switches again to thinking and sends a message to himself to :eat. So he can try again.","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"We need a stats function for eating time and we setup everything:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"eaten(phils...) = Tuple(round(Int, query(p, :bhv).a[1].eaten) for p in phils)\n\nc1 = spawn(Chopstick())\nc2 = spawn(Chopstick())\nc3 = spawn(Chopstick())\nc4 = spawn(Chopstick())\nc5 = spawn(Chopstick())\n\ndescartes = spawn(thinking, Phil(c1,c2,0.0))\nnietzsche = spawn(thinking, Phil(c2,c3,0.0))\nkant      = spawn(thinking, Phil(c3,c4,0.0))\nhume      = spawn(thinking, Phil(c4,c5,0.0))\nplato     = spawn(thinking, Phil(c5,c1,0.0))\n\nfor p in (descartes, nietzsche, kant, hume, plato)\n    delay(thinking_time, Val(:eat), p)\nend","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"To get some stats we print the eaten times every second:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"julia > for i in 1:5\n            sleep(1)\n            println(i, \"s: \", eaten(descartes, nietzsche, kant, hume, plato))\n        end\n1s: (24, 34, 32, 31, 31)\n2s: (57, 70, 61, 62, 65)\n3s: (86, 101, 89, 96, 100)\n4s: (119, 129, 123, 124, 132)\n5s: (151, 162, 155, 155, 162)","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"So they are happy thinking and eating asynchronously. Since we have a speedup of 100, we can conclude that in 500 time units our philosophers eat around 155 (much more than programmers). We stop the whole thing in order to prevent overconsumption:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"julia > foreach(a->exit!(a), (descartes, nietzsche, kant, hume, plato, c1, c2, c3, c4, c5))","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"Actually Gul Agha proposed something else. He reasoned about to let philosophers talk to each other:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"An actor is free and able to figure out a deadlock situation by querying other actors as to their local state. ... While these philosophers may be \"busy\" eating or looking for a chopstick, they nevertheless accept communications sent to them. [2]","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"We did not go this road in order to avoid philosophical debates about local state. But you can try for yourself.","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"[1]: Dale Schumacher. It's Actors All The Way Down, 2010: \"Dining Philosophers\" in Humus","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"[2]: Gul Agha, 1986. Actors: A Model of Concurrent Computation in Distributed Systems, MIT,- p. 95","category":"page"},{"location":"behaviors/#Behaviors","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"CurrentModule = Actors","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"A behavior is a ...","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"... function to express what an actor does when it processes a message. [1]The behavior of an actor maps the incoming communication to a three tuple of tasks created, new actors created, and the replacement behavior. [2]","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"beginarraylrl\nf_i(a_i)c_i  rightarrow tau_utau_v alpha_xalpha_yf_i+1(a_i+1) quad\ntextrmwith  f  textrmbehavior function \n  a  textrmacquaintances \n  c  textrmcommunication \n  tau  textrmtasks created \n  alpha  textrmactors created \nendarray","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"The behavior thus can be seen as a partial application of a function f to acquaintances a (variables or values the actor knows of). If a communication c arrives, the behavior executes f(ac):","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"f(a, c) = a + c         # define a function\ng(f, a) = (c)->f(a, c)  # a function to build a behavior\nbhv = g(f, 1)           # partially apply f to 1\nbhv(2)                  # execute f(1,2)","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Actor behavior can be represented in a functional or in an object-oriented style. Both are interchangeable.","category":"page"},{"location":"behaviors/#Functional-Style","page":"Behaviors","title":"Functional Style","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"We represent a behavior as a function f together with acquaintance arguments a... and kw... (keyword arguments) to it. Bhv creates a partial application (a closure) Ï•(a...; kw...) which then can be executed with the communication arguments c...:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"using Actors\nf(s, t, u, v; w=1, x=1) = s + t + u + v + w + x   # a function\nbhv = Bhv(f, 1, 1, w=2, x=2);  # create a Bhv with f and acquaintances\nbhv(1, 1)                      # execute it with communication parameters","category":"page"},{"location":"behaviors/#Object-oriented-Style","page":"Behaviors","title":"Object-oriented Style","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Alternatively we put the acquaintance parameters in an object which we make executable (e.g. a functor) with communication parameters:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"struct Acqu                    # define an object with acquaintances\n    s; t; w; x\nend\n(a::Acqu)(u, v) = a.s + a.t + u + v + a.w + a.x  # make it executable with communication parameters\nbhv = Acqu(1,1,2,2)            # create an instance\nbhv(1,1)                       # execute it with communication parameters","category":"page"},{"location":"behaviors/#Freestyle","page":"Behaviors","title":"Freestyle","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"With being callable the only hard requirement for a behavior, you can pass anything callable as behavior to an actor regardless whether it contains acquaintances or not:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"using Actors, .Threads\nimport Actors: spawn, newLink\nmyactor = spawn(threadid)                     # a parameterless function\ncall(myactor)\nbecome!(myactor, (lk, x, y) -> send(lk, x^y)) # an anonymous function with communication arguments\nme = newLink()\nsend(myactor, me, 123, 456)\nreceive(me)","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"You can give functors further acquaintance parameters (as for the players in the table-tennis example). Of course you can give objects containing acquaintances as parameters to a function and create a partial application with Bhv on them and much more. Be my guest!","category":"page"},{"location":"behaviors/#stack","page":"Behaviors","title":"Agha's Stack example","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Now more realistically for actor behavior we reproduce Agha's example 3.2.1 [3]:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"using Actors\nimport Actors: spawn, newLink\n\nmutable struct StackNode{T,L}  # a stack node object\n    content::T\n    link::L\nend\n\nstruct Pop{L}                  # a pop message\n    customer::L\nend\n\nstruct Push{T}                 # a push message\n    content::T\nend\n\n# now three behavior methods\nforwarder = send\nfunction (sn::StackNode)(msg::Pop)\n    isnothing(sn.content) || become(forwarder, sn.link)\n    send(msg.customer, Response(sn.content))\nend\n(sn::StackNode)(msg::Push) = become(StackNode(msg.content, spawn(sn)))","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Here we use both the functional and the object oriented approach:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"forwarder is a function which we put together with sn.link into a Bhv,\nStackNode is an object, which gets two methods.","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Now we can operate the stack:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"julia> mystack = spawn(StackNode(nothing, newLink()))\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> response = newLink()\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :local)\n\njulia> for i âˆˆ 1:5\n           send(mystack, Push(i))\n       end\n\njulia> for i âˆˆ 1:5\n           send(mystack, Pop(response))\n           println(receive(response).y)\n       end\n5\n4\n3\n2\n1","category":"page"},{"location":"behaviors/#Setting-and-Changing-Behavior","page":"Behaviors","title":"Setting and Changing Behavior","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"An actor's behavior is set with spawn and gets changed with become!. Inside a behavior function an actor can change its own behavior with become. In both cases a callable object together with acquaintance arguments can be specified as new behavior. This is effective when the next message gets processed.","category":"page"},{"location":"behaviors/#Don't-Share-Mutable-Variables","page":"Behaviors","title":"Don't Share Mutable Variables","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"As you have seen, you are very free in how you define behaviors, but you must be very careful in passing mutable variables as acquaintances to actors as they could be accessed by other actors on other threads concurrently causing race conditions. ","category":"page"},{"location":"behaviors/#Instead-Share-Actors","page":"Behaviors","title":"Instead Share Actors","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"It is thread-safe to share actors between threads or other actors. Each call to the shared actor is a communication.","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"In the table-tennis example we shared a print server actor between player actors working on different threads.\nIn the Dict-server example a dictionary gets served by an actor to parallel threads.\nYou can wrap mutable variables into a :guard actor, which will manage access to them.\nIn more complicated cases of resource sharing you can use a :genserver actor.","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"As those examples show, it is surprisingly easy to avoid race conditions by using actors.","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"[1]: see the Actor Model on Wikipedia.","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"[2]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT.- p. 30","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"[3]: ibid. p. 34","category":"page"},{"location":"examples/prod_cons/#Producer-Consumer-Problem","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"","category":"section"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"This classic problem describes producers and consumers sharing a buffer with a given capacity. A producer produces an item at a time, puts it into the buffer and starts again. At the same time consumers are consuming the items (i.e. removing them from the buffer). The problem ist to make sure that a producer won't add items to the buffer if it is full and that a consumer won't try to remove them from an empty buffer. ","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"The solution for a producer is to go to sleep if the buffer is full. The next time, a consumer removes an item from the buffer, the buffer notifies the stalled producer, who then starts to replenish the buffer again. In the same way, the consumer can go to waiting if it finds the buffer empty. The next time a producer delivers an item, the buffer notifies the waiting consumer.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"We implement this problem with three kinds of actors for store, producer and consumer.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"The store has a fixed capacity, holds items and queues of stalled producers and waiting customers and a counting variable.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"# examples/prod_cons.jl\n\nusing Actors, Printf\nimport Actors: spawn\n\nconst maxitems = 10\n\nmutable struct Store\n    capacity::Int\n    items::Array{Any,1}\n    prod::Array{Link,1}\n    cons::Array{Link,1}\n    count::Int\n    Store(capacity::Int) = new(capacity, Any[], Link[], Link[], 0)\nend\n\navailable(s::Store) = 0 < length(s.items) < s.capacity\nisfull(s::Store) = length(s.items) â‰¥ s.capacity\nBase.isempty(s::Store) = isempty(s.items)","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"We implement the store's behavior as a functor receiving two messages :put and :take.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"function (s::Store)(::Val{:put}, prod, item)\n    if isfull(s)\n        send(prod, Val(:full), item)\n        push!(s.prod, prod)\n    elseif s.count < maxitems\n        push!(s.items, item)\n        s.count += 1\n        s.count == maxitems ?\n            send(prod, Val(:done)) :\n            send(prod, Val(:ok), item)\n        !isempty(s.cons) && send(popfirst!(s.cons), Val(:notify))\n    else\n        send(prod, Val(:done))\n    end\nend\nfunction (s::Store)(::Val{:take}, cons)\n    if isempty(s)\n        send(cons, Val(:empty))\n        push!(s.cons, cons)\n    else\n        send(cons, popfirst!(s.items))\n        !isempty(s.prod) && send(popfirst!(s.prod), Val(:notify))\n    end\nend","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Producers and consumers have a name and a link to the store:","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"struct Prod\n    name::String\n    store::Link\nend\n\nstruct Cons\n    name::String\n    store::Link\nend","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Those are acquaintances of their behavior functions. We have also a print server actor prn as a global variable.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"function prod_start(p::Prod, start)\n    become(producing, p)\n    send(self(), start+1)\n    send(prn, \"producer $(p.name) started\")\nend\nfunction producing(p::Prod, item)\n    sleep(rand())\n    send(p.store, Val(:put), self(), item)\nend\nfunction producing(p::Prod, ::Val{:ok}, item)\n    send(prn, \"producer $(p.name) delivered item $item\")\n    send(self(), item+1)\nend\nfunction producing(p::Prod, ::Val{:full}, item)\n    send(prn, \"producer $(p.name) stalled with item $item\")\n    become(stalled, p, item)\nend\nfunction producing(p::Prod, ::Val{:done})\n    send(prn, \"producer $(p.name) done\")\n    stop()\nend\nfunction stalled(p::Prod, item, ::Val{:notify})\n    send(p.store, Val(:put), self(), item)\n    become(producing, p)\nend\n\nfunction cons_start(c::Cons)\n    become(buying, c)\n    send(c.store, Val(:take), self())\n    send(prn, \"consumer $(c.name) started\")\nend\nfunction buying(c::Cons, item)\n    become(consuming)\n    send(self(), c)\n    send(prn, \"consumer $(c.name) got item $item\")\nend\nfunction buying(c::Cons, ::Val{:empty})\n    become(waiting, c)\n    send(prn, \"consumer $(c.name) found store empty\")\nend\nfunction consuming(c)\n    sleep(rand())\n    become(buying, c)\n    send(c.store, Val(:take), self())\nend\nfunction waiting(c::Cons, ::Val{:notify})\n    become(buying, c)\n    send(c.store, Val(:take), self())\nend","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Finally we start the simulation with a print server, a store, three producers and two consumers.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"prn = spawn(s->print(@sprintf(\"%s\\n\", s)))\nst = spawn(Store(5))\npr1 = spawn(prod_start, Prod(\"A\", st), 100)\npr2 = spawn(prod_start, Prod(\"B\", st), 200)\npr3 = spawn(prod_start, Prod(\"C\", st), 300)\ncs1 = spawn(cons_start, Cons(\"U\", st))\ncs2 = spawn(cons_start, Cons(\"V\", st))\n\nforeach(x->send(x), (pr1,pr2,pr3,cs1,cs2))","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Let's see, what happens:","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"julia> include(\"examples/prod_cons.jl\")\n\njulia> producer A started\nconsumer U started\nproducer C started\nproducer B started\nconsumer V started\nconsumer V found store empty\nconsumer U found store empty\nproducer A delivered item 101\nconsumer U got item 101\nproducer B delivered item 201\nconsumer V got item 201\nproducer C delivered item 301\nconsumer V got item 301\nconsumer U found store empty\nproducer C delivered item 302\nconsumer U got item 302\nproducer B delivered item 202\nproducer C delivered item 303\nproducer B delivered item 203\nproducer A delivered item 102\nproducer A delivered item 103\nconsumer U got item 202\nconsumer V got item 303\nproducer A done\nconsumer V got item 203\nproducer C done\nproducer B done\nconsumer V got item 102\nconsumer U got item 103\nconsumer V got item 104\nconsumer U found store empty\nconsumer V found store empty","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"We had limited the sold items to 10. This is a queueing process.","category":"page"},{"location":"#Actors-Documentation","page":"Actors Documentation","title":"Actors Documentation","text":"","category":"section"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors implements the classical Actor model using Julia's concurrency primitives.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"An actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [1]","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors enhance Julia's capabilities for concurrent computing. They can be used together with other Julia functionality for multi-threading and distributed computing.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors use Julia functions as behaviors and are","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"responsive â€“ they react to users - and\nmessage-driven - they rely on asynchronous message-passing [2].","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors has a modern API [3], can interface with other actor libraries and can be extended by them using actor protocols.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors is in active development. If you want to contribute, please join JuliaActors.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"[1]: See the Wikipedia entry on the Actor Model.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"[2]: See The Reactive Manifesto. Its other two tenets resilient and elastic are prepared for and are likely to come soon.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"[3]: The Actors API is inspired by Erlang/OTP, see OTP Design Principles - Userâ€™s Guide","category":"page"}]
}
