var documenterSearchIndex = {"docs":
[{"location":"infrastructure/#More-Useful-Stuff","page":"More Useful Stuff","title":"More Useful Stuff","text":"","category":"section"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"CurrentModule = Actors","category":"page"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"Actors provides some more functionality going beyond the classical model.","category":"page"},{"location":"infrastructure/#User-Defined-Messages","page":"More Useful Stuff","title":"User Defined Messages","text":"","category":"section"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"Often you want to define your own message types. For  defining empty messages you can use the @msg macro.  ","category":"page"},{"location":"infrastructure/#Actor-Registry","page":"More Useful Stuff","title":"Actor Registry","text":"","category":"section"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"If a parent actor or worker process creates a new actor, the link to it is only locally known. It has to be sent to all other actors that want to communicate with it.","category":"page"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"Now let's setup a remote worker and an ident function:","category":"page"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"julia> using Actors, Distributed\n\njulia> import Actors: spawn\n\njulia> addprocs(1);\n\njulia> @everywhere using Actors\n\njulia> @everywhere function ident(id, from)\n           id == from ?\n               (\"local actor\",  id, from) :\n               (\"remote actor\", id, from)\n       end","category":"page"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"An actor (link) can be registered under a name (a Symbol). This name then is known system-wide and any other actor can communicate with it using that name:","category":"page"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"julia> register(:act1, spawn(ident, 1))      # a registered local actor\ntrue\n\njulia> call(:act1, myid())                   # call it locally\n(\"local actor\", 1, 1)\n\njulia> register(:act2, spawn(ident, 2, pid=2)) #  register a remote actor on pid 2\ntrue\n\njulia> call(:act2, myid())                   # call it locally\n(\"remote actor\", 2, 1)\n\njulia> fetch(@spawnat 2 call(:act1, myid())) # call :act1 on pid 2\n(\"remote actor\", 1, 2)\n\njulia> fetch(@spawnat 2 call(:act2, myid())) # call :act2 on pid 2\n(\"local actor\", 2, 2)","category":"page"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"The registry provides three further functions:","category":"page"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"API function brief description\nwhereis return the link of a registered actor\nregistered return an array of all registered actors\nunregister remove a registration","category":"page"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"julia> whereis(:act1)                         # get a link to :act1\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> whereis(:act2)                         # get a link to :act2\nLink{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n\njulia> fetch(@spawnat 2 whereis(:act1))       # get a link to :act1 on pid 2\nLink{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 40), 1, :default)\n\njulia> registered()                           # get a list of registered actors\n2-element Array{Pair{Symbol,Link},1}:\n :act2 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n :act1 => Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> fetch(@spawnat 2 registered())         # get it on pid 2\n2-element Array{Pair{Symbol,Link{RemoteChannel{Channel{Any}}}},1}:\n :act2 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n :act1 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 46), 1, :default)","category":"page"},{"location":"infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"The registry works transparently across workers. All workers have access to registered actors on other workers via remote links.","category":"page"},{"location":"actors/#Actors-and-Julia","page":"Actors and Julia","title":"Actors and Julia","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"CurrentModule = Actors","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"In one of his later papers (2010) Carl Hewitt wrote:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"It is important to distinguish the following:modeling arbitrary computational systems using Actors. It is difficult to find physical computational systems (regardless of how idiosyncratic) that cannot be modeled using Actors.\nsecurely implementing practical computational applications using Actors remains an active area of research and development. [1]","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"We focus on the second point, namely on practical computational applications.","category":"page"},{"location":"actors/#Julia-is-Well-Suited-for-Actors","page":"Actors and Julia","title":"Julia is Well Suited for Actors","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors uses Julia's Tasks to execute functions concurrently and Channels to let them communicate. An actor has a Julia function or callable object as behavior. That gets parametrized with the arguments given to the actor at startup (acquaintances). The other arguments are delivered via messages (communication). Then an actor executes its behavior. Actors incorporate processing, storage and communication. Functions thus become responsive and composable in new ways.","category":"page"},{"location":"actors/#Actors-Complement-Julia","page":"Actors and Julia","title":"Actors Complement Julia","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors give Julia users additional ways to deal with concurrency. Sutter and Larus justified that as follows:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"We need higher-level language abstractions, including evolutionary extensions to current imperative languages, so that existing applications can incrementally become concurrent. The programming model must make concurrency easy to understand and reason about, not only during initial development but also during maintenance. [2]","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors support clear, correct concurrent programs and are an alternative to sharing memory in concurrent computing:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Share by communicating [3] to functions and\nuse functions to localize variables and\nmake actors serve mutable variables without using locks.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Below I will show how you can use actors in common multi-threading or distributed Julia code.","category":"page"},{"location":"actors/#Multi-threading","page":"Actors and Julia","title":"Multi-threading","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Julia's manual encourages the use of locks [4] in order to ensure data-race freedom. But be aware that","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"they are not composable. You can’t take two correct lock-based pieces of code, combine them, and know that the result is still correct. Modern software development relies on the ability to compose libraries into larger programs, and so it is a serious difficulty that we cannot build on lock-based components without examining their implementations. [5]","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"An actor controlling the access to a variable or to another resource is lock-free and there are no limits to composability. Therefore if you write multi-threaded programs which should be composable or maybe used by other programs within a lock, you might consider using Actors.","category":"page"},{"location":"actors/#Distributed-Computing","page":"Actors and Julia","title":"Distributed Computing","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors are location transparent. You can share their links across workers to access the same actor on different workers. If local links are sent to a remote actor, they are converted to remote links.","category":"page"},{"location":"actors/#dict-server","page":"Actors and Julia","title":"A Dict Server","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"This example shows how to implement a Dict-server actor that can be used in multi-threaded and distributed Julia code.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"We implement DictSrv as a function object containing a link to an actor.\nDictSrv gets an indexing interface.\nThe actor behavior ds takes a Dict variable as acquaintance and executes the communicated function f and args... on it. If called without arguments it returns a copy of its Dict variable.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"# examples/mydict.jl\n\nmodule MyDict\nusing Actors\nimport Actors: spawn\n\nstruct DictSrv{L}\n    lk::L\nend\n(ds::DictSrv)() = call(ds.lk)\n(ds::DictSrv)(f::Function, args...) = call(ds.lk, f, args...)\n# indexing interface\nBase.getindex(d::DictSrv, key) = call(d.lk, getindex, key)\nBase.setindex!(d::DictSrv, value, key) = call(d.lk, setindex!, value, key)\n\n# dict server behavior\nds(d::Dict, f::Function, args...) = f(d, args...)\nds(d::Dict) = copy(d)\n# start dict server\ndictsrv(d::Dict; remote=false) = DictSrv(spawn(ds, d, remote=remote))\n\nexport DictSrv, dictsrv\n\nend","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"A dict server is started with dictsrv. It does not share its Dict variable. Let's try it out:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"julia> include(\"examples/mydict.jl\")\nMain.MyDict\n\njulia> using .MyDict, .Threads\n\njulia> d = dictsrv(Dict{Int,Int}())\nDictSrv{Link{Channel{Any}}}(Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default))\n\njulia> @threads for i in 1:1000\n           d[i] = threadid()\n       end\n\njulia> d()\nDict{Int64,Int64} with 1000 entries:\n  306 => 3\n  29  => 1\n  74  => 1\n  905 => 8\n  176 => 2\n  892 => 8\n  285 => 3\n  318 => 3\n  873 => 7\n  975 => 8\n  ⋮   => ⋮\n\njulia> d[892]\n8","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"All available threads did concurrently fill our served dictionary with their thread ids. Actor access to the dictionary happens almost completely behind the scenes.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Now we try it out with distributed computing:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"julia> using Distributed\n\njulia> addprocs();\n\njulia> nworkers()\n17\n\njulia> @everywhere include(\"examples/mydict.jl\")\n\njulia> @everywhere using .MyDict\n\njulia> d = dictsrv(Dict{Int,Int}(), remote=true)\nDictSrv{Link{RemoteChannel{Channel{Any}}}}(Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 278), 1, :default))\n\njulia> @spawnat :any d[myid()] = rand(Int)\nFuture(4, 1, 279, nothing)\n\njulia> @spawnat 17 d[myid()] = rand(Int)\nFuture(17, 1, 283, nothing)\n\njulia> d()\nDict{Int64,Int64} with 2 entries:\n  4  => -4807958210447734689\n  17 => -8998327833489977098\n\njulia> fetch(@spawnat 10 d())\nDict{Int64,Int64} with 2 entries:\n  4  => -4807958210447734689\n  17 => -8998327833489977098","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"The remote DictSrv actor is available on all workers.","category":"page"},{"location":"actors/#Fault-Tolerance","page":"Actors and Julia","title":"Fault Tolerance","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"note: This has yet to be developed!\nThis will be implemented with the next major version.","category":"page"},{"location":"actors/#Actor-Isolation","page":"Actors and Julia","title":"Actor Isolation","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"In order to avoid race conditions actors have to be strongly isolated from each other:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"they do not share state,\nthey must not share mutable variables.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"An actor stores the behavior function and arguments to it, results of computations and more. Thus it has state and this influences how it behaves.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"But it does not share its state variables with its environment (only for diagnostic purposes). The API functions above are a safe way to access actor state via messaging.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Mutable variables in Julia can be sent over local channels without being copied. Accessing those variables from multiple threads can cause race conditions. The programmer has to be careful to avoid those situations either by","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"not sharing them between actors,\ncopying them when sending them to actors or\nrepresenting them by an actor.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"When sending mutable variables over remote links, they are automatically copied.","category":"page"},{"location":"actors/#Actor-Local-Dictionary","page":"Actors and Julia","title":"Actor Local Dictionary","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Since actors are Julia tasks, they have a local dictionary in which you can store values. You can use task_local_storage to access it in behavior functions. But normally argument passing should be enough to handle values in actors.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[1]: Carl Hewitt. Actor Model of Computation: Scalable Robust Information Systems.- arXiv:1008.1459","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[2]: H. Sutter and J. Larus. Software and the concurrency revolution. ACM Queue, 3(7), 2005.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[3]: Effective Go: Share by Communicating","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[4]: see Data race freedom in the Julia manual.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[5]: H. Sutter and J. Larus. see above","category":"page"},{"location":"protocol/#Messaging-Protocol","page":"Messaging Protocol","title":"Messaging Protocol","text":"","category":"section"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"CurrentModule = Actors","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Actors has predefined message types with respective onmessage methods. This gives your actors predefined behaviors going beyond the classical behavior. API functions provide an interface to that messaging protocol and facilitate actor control and message exchange.","category":"page"},{"location":"protocol/#Messaging-Patterns","page":"Messaging Protocol","title":"Messaging Patterns","text":"","category":"section"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"The actor protocol can be described as a series of messaging patterns. For every predefined message the actor executes a predefined behavior. Here is an overview:","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Message pattern brief description\nBecome Tell an actor to change its behavior.\nCall - Response Call an actor to execute its behavior and to respond with the result.\nDiag - Response Call an actor to respond with diagnostic information.\nDown A message to a monitor actor signaling an exit or a failure.\nExit A message causing an actor to exit.\nExec - Response Call an actor to execute a function and to respond with the result.\nInit Tell an actor to execute an initialization function and to store it in its internal state.\nQuery - Response Call an actor to send a status variable/value.\nRequest This triggers the actor's default response to execute its behavior.\nTerm Tell an actor to execute a given behavior upon termination.","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Actors API functions are wrappers to those message patterns. As you have seen there are unidirectional messages (without response) for actor control and bidirectional messages.","category":"page"},{"location":"protocol/#Actor-Control","page":"Messaging Protocol","title":"Actor Control","text":"","category":"section"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Actors can be controlled with the following functions:","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"API function brief description\nbecome! cause an actor to switch its behavior\ncast cause an actor to execute its behavior function\nexit! cause an actor to terminate\ninit! tell an actor to execute a function at startup\nterm! tell an actor to execute a function when it terminates\nupdate! update an actor's internal state","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Actors can also operate on themselves, or rather they send themselves messages:","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"API function brief description\nbecome an actor switches its own behavior\nself an actor gets a link to itself\nstop an actor stops","category":"page"},{"location":"protocol/#Bidirectional-Messages","page":"Messaging Protocol","title":"Bidirectional Messages","text":"","category":"section"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"To receive a reply from an actor there are two possibilities:","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"API function brief description\nreceive after a send receive the Response asynchronously\nrequest send (implicitly) a message to an actor, block and receive the result synchronously","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"The following functions do that for specific duties:","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"API function brief description\ncall tell an actor to execute its behavior function and to send the result\nexec tell an actor to execute a function and to send the result\nquery tell an actor's to send one of its internal state variables","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Those functions support both asynchronous and synchronous communication.","category":"page"},{"location":"protocol/#Enhancing-the-Protocol","page":"Messaging Protocol","title":"Enhancing the Protocol","text":"","category":"section"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"The Actors protocol can be enhanced or altered by","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"introducing new messages and onmessage methods,\nswitching the actor mode and writing new onmessage methods for existing messages\nor both.","category":"page"},{"location":"protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Libraries can do this for specific duties and plugin their protocols into Actors. Examples of such libraries are GenServers and Guards.","category":"page"},{"location":"errors/#Error-Handling","page":"Error Handling","title":"Error Handling","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"CurrentModule = Actors","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"Actors provides Erlang/OTP-like [1][2] mechanisms and message protocols to","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"handle errors in actors and tasks and to\nwrite fault-tolerant programs.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"The basic philosophy is not to defend against errors but to detect them and then to take action about them. There are two basic mechanisms for that: connections and monitors:","category":"page"},{"location":"errors/#Connections","page":"Error Handling","title":"Connections","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"If you connect actors, they send each other Exit messages when they fail, stop or exit!. An actor propagates an Exit message to all its connected actors and then terminates","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"if the exit reason is other than :normal,\nand if it is not :sticky.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"With trapExit an actor can be made :sticky. When it then receives an Exit message with a reason other than :normal, it will","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"not propagate it and not terminate but\ngive a warning about it and\nstore a link to the failed actor.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"Connections between actors are always bidirectional and can be disconnected. You can build a chain or network of connected actors that depend on each other and exit together. A :sticky actor operates as a firewall among connected actors.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"(Image: connection)","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"Assume in an actor system A1-A3-A7-A9-A4 are connected, A3 is a :sticky actor and A9 fails. Before it terminates, it sends an Exit message to A4 and A7. A7 propagates it further to A3. A9, A4 and A7 die together. A3 gives a warning about the failure and saves the link to the failed actor A9. A3 does not propagate the Exit to A1. Both A1 and A3 stay connected and continue to operate. The other actors are separate and are not affected by the failure.","category":"page"},{"location":"errors/#Monitors","page":"Error Handling","title":"Monitors","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"An actor can be told to monitor other actors or Julia tasks. Monitored actors or tasks send a Down message with an exit reason to their monitor(s) before they terminate. A monitor then gives a warning or executes a specified action dispatched on the received reason.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"(Image: monitor)","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"A3 is a monitor. It gets a Down signal from its monitored actors if they exit.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"Monitors do not forward Down messages. They give warnings or execute specified actions for Down signals (even with reason :normal). Monitoring is not bidirectional. If a monitor fails, the monitored actor gets no notification. Monitoring can be stopped with demonitor. An actor can have several monitors (if that makes sense).","category":"page"},{"location":"errors/#Supervisors","page":"Error Handling","title":"Supervisors","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"A supervisor is an actor looking after child actors and restarting them as necessary when they exit.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"(Image: supervisor)","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"In the depicted case the supervisor A10 has child actors A1-A6. What it does if one of them – say A4 - exits, is determined by its supervision strategy and by the child's restart variable and exit reason.","category":"page"},{"location":"errors/#Supervision-strategy","page":"Error Handling","title":"Supervision strategy","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"strategy brief description\n:one_for_one only the terminated actor is restarted (A4),\n:one_for_all all other child actors are terminated, then all child actors are restarted (A1-A6),\n:rest_for_one the children started after the terminated one are terminated, then all terminated ones are restarted (A4-A6).","category":"page"},{"location":"errors/#Child-restart-options","page":"Error Handling","title":"Child restart options","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"restart option brief description\n:permanent the child actor is always restarted,\n:temporary the child is never restarted, regardless of the supervision strategy,\n:transient the child is restarted only if it terminates abnormally, i.e., with an exit reason other than :normal or :shutdown.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"Supervisors allow for more automation and control of error handling in an actor system. For that they have the following API:","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"API function brief description\nsupervisor start a supervisor actor,\nsupervise add the current actor to a supervisor's child list,\nunsupervise delete the current actor from a supervisor's child list,\nstart_actor tell a supervisor to start an actor as a child,\nstart_task tell a supervisor to start a task as a child,\ndelete_child tell a supervisor to remove an actor from its child list,\nterminate_child tell a supervisor to terminate a child and to remove it from its child list,\ncount_children tell a supervisor to return a children count,\nwhich_children tell a supervisor to return a list of its children.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"With options we can limit how often a supervisor tries to restart children in a given timeframe. If it exceeds this limit, it terminates itself and all of its children with a warning.","category":"page"},{"location":"errors/#The-_ROOT-Actor","page":"Error Handling","title":"The _ROOT Actor","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"If connect or monitor are called from the REPL or a user script and not from an actor, the given link will be connected to or monitored by the Actors._ROOT actor.","category":"page"},{"location":"errors/#Fault-Tolerance","page":"Error Handling","title":"Fault Tolerance","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"To use the above mechanisms for fault-tolerance successfully, supervisors, monitors or :sticky actors must have behaviors which are unlikely to fail. Therefore actors with complicated and error-prone behaviors should not be made monitors or :sticky.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"Connections, monitors and supervisors represent quite different protocols. When do you use which?","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"If you want a failure in one actor to terminate others, then use connect.\nIf instead you need to know or take action when some other actor or task exits for any reason, choose a monitor.\nIf you want to realize a hierarchy of actors and tasks, use supervisors.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"The approaches can be combined to realize arbitrary structures of connected and monitored actors.","category":"page"},{"location":"errors/#Supervisory-trees","page":"Error Handling","title":"Supervisory trees","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"Often you may be interested in building a hierarchical structure containing all actors and tasks in your application. This is called a supervisory tree, and there is the Supervisors package facilitating to build that.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"[1]: The definitive source for an outline of actor-based error handling is Joe Armstrong's dissertation: Making reliable distributed systems in the presence of software errors","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"[2]: For implementation see also Joe Armstrong 2013. Programming Erlang, 2nd ed: Software for a Concurrent World; Manning, chs. 13 and 23 as well as the Erlang/OTP and Elixir online documentations.","category":"page"},{"location":"examples/examples/#Further-Examples","page":"Further Examples","title":"Further Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Further Examples","title":"Further Examples","text":"In the manual there are the following examples:","category":"page"},{"location":"examples/examples/","page":"Further Examples","title":"Further Examples","text":"Table-tennis,\nAgha's Stack example,\nA Dict Server","category":"page"},{"location":"examples/examples/","page":"Further Examples","title":"Further Examples","text":"See also the examples in the repository.","category":"page"},{"location":"basics/#Actor-Model","page":"Actor Model","title":"Actor Model","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"CurrentModule = Actors","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"The Actor Model was originally proposed by Carl Hewitt et. al. in the 70es and since then has evolved into different families [1]. ","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"We focus here on the classical Actor Model described by Gul Agha in Actors [2]. This sees an actor as the universal primitive of concurrent computation:","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"An actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [3]","category":"page"},{"location":"basics/#Actor-Characteristics","page":"Actor Model","title":"Actor Characteristics","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Actor systems and actors have the following basic characteristics[4] :","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"communication via direct asynchronous messaging,\nactors support finite state machines,\nactors do not share their mutable state,\nlock-free concurrency,\nactors support parallelism,\nactors tend to come in systems.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Modern actor implementations extend those by","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"location transparency: this enables actors of different kinds and on different systems to communicate,\nsupervision: actors form a dependency relationship where a parent actor supervises child/subordinate ones. This is used to implement fault tolerant systems.\nactor protocols: there are predefined actors  following a specific message protocol to implement complex behaviors e.g. as generic server, supervisor, router, publish-subscribe ...  ","category":"page"},{"location":"basics/#Actor-Primitives","page":"Actor Model","title":"Actor Primitives","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"The actor machinery is based on only a few basic primitives defined in ActorInterfaces.Classic:","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Primitive Brief description\nAddr an address identifying an actor,\nself() get the address of the current actor,\nspawn(bhv) create an actor from a behavior and return an address,\nsend(addr, msg) send a message to an actor,\nbecome(bhv) an actor designates a new behavior,\nonmessage(bhv, msg) is executed by the actor when a message arrives.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"A user can write actor programs using only those basic primitives. Those programs should run with minor modifications on other libraries supporting the same basic interface.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"note: The interface needs yet work!\nAt the moment the Actors implementation of the interface in ActorInterfaces.Classic is not complete as it doesn't support context injection with @ctx.","category":"page"},{"location":"basics/#table-tennis","page":"Actor Model","title":"A Classic Example","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Now a small toy example for concurrency with actors using only the classic primitives. We simulate table-tennis where a player has a name and a capability. If he gets a ball with a difficulty exceeding his capability, he looses it. Players log to a print server actor.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"using Actors, Printf, Random\nimport Actors: spawn\n\nstruct Player{S,T}\n    name::S\n    capa::T\nend\n\nstruct Ball{T,S,L}\n    diff::T\n    name::S\n    from::L\nend\n\nstruct Serve{L}\n    to::L\nend\n\nfunction (p::Player)(prn, b::Ball)\n    if p.capa ≥ b.diff\n        send(b.from, Ball(rand(), p.name, self()))\n        send(prn, p.name*\" serves \"*b.name)\n    else\n        send(prn, p.name*\" looses ball from \"*b.name)\n    end\nend\nfunction (p::Player)(prn, s::Serve)\n    send(s.to, Ball(rand(), p.name, self()))\n    send(prn, p.name*\" serves \")\nend","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"In order to get reproducible results we initialize our random generator on each thread and assign threads to  players.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"The print server prn gets an anonymous function as behavior. The two players ping and pong get the print server's link as acquaintance. We start the game by sending ping the :serve command and the address of pong:","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"@threads for i in 1:nthreads()\n    Random.seed!(2021+threadid())\nend\n\nprn = spawn(s->print(@sprintf(\"%s\\n\", s))) \nping = spawn(Player(\"Ping\", 0.8), prn, thrd=3)\npong = spawn(Player(\"Pong\", 0.75), prn, thrd=4)\n\nsend(ping, Serve(pong))","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"To execute the program we include the file:","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"julia> include(\"examples/pingpong.jl\");\n\nPing serves \nPong serves Ping\nPing serves Pong\nPong serves Ping\nPing serves Pong\nPong looses ball from Ping","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Actors are great for simulation.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[1]: De Koster, Van Cutsem, De Meuter 2016. 43 Years of Actors: A Taxonomy of Actor Models and Their Key Properties.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[2]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[3]: See the Wikipedia entry on the Actor Model.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[4]: Here I follow roughly: Vernon, Vaughn 2016. Reactive messaging patterns with the Actor model: applications and integration in Scala and Akka, Pearson","category":"page"},{"location":"messages/#Messages","page":"Messages","title":"Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"CurrentModule = Actors","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Actors can be called, updated, queried … To do it they follow a onmessage protocol on the following internal messages.","category":"page"},{"location":"messages/#Internal-Messages","page":"Messages","title":"Internal Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"Become\nCall\nCast\nConnect\nDiag\nDown\nExit\nExec\nInit\nQuery\nTerm\nTimeout\nUpdate","category":"page"},{"location":"messages/#Actors.Become","page":"Messages","title":"Actors.Become","text":"Become(bhv)\n\nAn asynchronous Msg to an actor to change its  behavior to bhv.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Call","page":"Messages","title":"Actors.Call","text":"Call(arg, from::Link)\n\nA synchronous Msg to an actor to execute its  behavior with arg... and to send the result as a Response  message to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Cast","page":"Messages","title":"Actors.Cast","text":"Cast(arg)\n\nAn asynchronous Msg to an actor to execute  its behavior with arg... without sending a response.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Connect","page":"Messages","title":"Actors.Connect","text":"Connect(x, remove=false)\n\nA Msg to an actor to connect with x. If  remove=true, an existing connection gets removed.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Diag","page":"Messages","title":"Actors.Diag","text":"Diag(x, from::Link)\n\nA synchronous Msg to an actor to send diagnostic information.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Down","page":"Messages","title":"Actors.Down","text":"Down(from, reason, task)\n\nA Msg to a monitor actor indicating that an error has occurred or a Exit has been received.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Exit","page":"Messages","title":"Actors.Exit","text":"Exit(reason, from, task, state)\n\nA Msg to an actor causing it to terminate.  Exit messages are sent to connected actors  if an error has occurred and then are propagated further. They are not propagated by :sticky actors, see  trapExit.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Exec","page":"Messages","title":"Actors.Exec","text":"Exec(func::Bhv, from::Link)\n\nA synchronous Msg to an actor to execute func and to send a Response message with the return value to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Init","page":"Messages","title":"Actors.Init","text":"Init(f::Bhv)\n\nA Msg to an actor to execute the given Bhv and to store it in the _ACT variable.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Query","page":"Messages","title":"Actors.Query","text":"Query(s::Symbol, from::Link)\n\nA Msg to an actor to send a  Response message with one of its internal state  variables s to from.\n\ns::Symbol can be one of :sta, :res, :bhv, :dsp.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Term","page":"Messages","title":"Actors.Term","text":"Term(x::Bhv)\n\nA Msg to an actor to save the given Bhv  and to execute it upon termination.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Timeout","page":"Messages","title":"Actors.Timeout","text":"Timeout()\n\nA return value to signal that a timeout has occurred.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Update","page":"Messages","title":"Actors.Update","text":"Update(s::Symbol, x)\n\nAn asynchronous Msg to an actor to update its  internal state s to x.\n\ns::Symbol can be one of :arg, :self, :sta, :usr.\n\n\n\n\n\n","category":"type"},{"location":"messages/#User-extensions","page":"Messages","title":"User extensions","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"There are four ways to extend the messaging protocol and the functionality of Actors:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"If a user defines its own messages of type Msg and sends them to an actor, it passes them on as remaining argument to the behavior function.\nAlternatively a user can extend Actors.onmessage with his own methods to dispatch on those messages and doing user defined things.\nA user can set the actor mode with spawn or change it with update! to something other than :default, e.g. :mymode. If he then implements a method Actors.onmessage(A::_ACT, ::Val{:mymode}, msg::Call) and so on, the actor will dispatch that one when it receives a Call message.\nFinally a user can implement other message types and messaging protocols and extend Actors.onmessage for dispatching on those.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"CurrentModule = Actors","category":"page"},{"location":"intro/#Getting-Started-with-Actors","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"You may have heard about the Actor Model, but at first we present actors as practical things, which you can spawn, send messages to, receive or request messages from, call, cast to them, query and update! them. Please follow along in your Julia REPL and don't hesitate to try things out.","category":"page"},{"location":"intro/#Creation:-spawn","page":"Getting Started with Actors","title":"Creation: spawn","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The basic mechanism to create a new actor is the spawn function. You have to import it explicitly:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"using Actors, .Threads\nimport Actors: spawn, newLink","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"You spawn an actor with a behavior. A behavior is a callable Julia object.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"myactor = spawn(threadid)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"spawn returned an actor link. Now - as we will discover right away - our actor is responsive and waits for our messages.","category":"page"},{"location":"intro/#Actor-Links","page":"Getting Started with Actors","title":"Actor Links","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"A Link is the actor's mail address and its only representation. Over the returned link it is possible to send messages to the actor or to use other messaging functions. Actors' API functions like info use an actors link to communicate with it. If you call or request it, you send a Call message to the actor to execute its behavior and to respond with the result:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"info(myactor)\ncall(myactor)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Now what happens if you send your actor a message which it cannot understand?","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, \"Boom\")\ninfo(myactor)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We caused our actor to fail. Ouch!","category":"page"},{"location":"intro/#Behaviors:-become-and-become!","page":"Getting Started with Actors","title":"Behaviors: become and become!","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We want our actor to do something more meaningful! Let's write our own behavior. We want it to calculate something and to send the result back to a given address:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"function calc(addr::Link, f::Function, args...)\n    send(addr, f(args...))\nend","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"With newLink we create a link for ourselves, spawn a new actor with a calc behavior and give it that newly created link as acquaintance parameter:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"me = newLink()\nmyactor = spawn(calc, me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We applied our calc function partially to me. Now our actor holds the me link as acquaintance and we need to send it only the rest of the parameters to cause it to execute the given function f on some parameters and to send the result back:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, +, 1, 2, 3, 4)\nreceive(me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"If we want our actor to do only multiplication, we can change its behavior with become! to calc with new acquaintances:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"become!(myactor, calc, me, *);","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The actor's new behavior is calc with two acquaintances me and *, and thus it does multiplication only. As before we send it the communication parameters to multiply and receive the result:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, 1,2,3,4)\nreceive(me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"An actor can change also its own behavior with become. Since what an actor does is defined by its behavior, become inside the behavior function  causes the actor to switch to a new behavior. Instead become! is a call from the outside of an actor. A behavior change is effective for the next message an actor receives.","category":"page"},{"location":"intro/#Communication:-send-and-receive","page":"Getting Started with Actors","title":"Communication: send and receive","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"When we used send and receive in our experiments so far, we did asynchronous communication with our actor. After sending something  we could have done other work and then receive the result later.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"What happens if we try to receive something from a failed actor?","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, 5, \"x\")\nreceive(me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"After some seconds we got a Timeout().","category":"page"},{"location":"intro/#Actor-Protocol:-request","page":"Getting Started with Actors","title":"Actor Protocol: request","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We don't give up with it and start it again, but now we want an adding machine with an offset of 1000:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"myactor = spawn(+, 1000)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Our actor now has no acquaintance of me, neither has its behavior any send instruction. If we send it something, it will only add that to 1000 but not respond anything.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Here the actor protocol comes to our rescue. It allows us to communicate with actors even if their behaviors don't send anything. Actors understand messaging patterns.  For example if we send an actor a Call, it knows that it must send a Response with the result. Let's try that out:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, Actors.Call((1,2,3), me))\nreceive(me)\nans.y","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The actor added (1,2,3) to 1000 and sent the result back to the provided link. Then we received it asynchronously.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The request function is a wrapper for synchronous bidirectional communication. It will create a link internally and send it with the communication parameters as a Call (or another given message type) to the actor. That one sends a Response back to the received link, and request then delivers the response:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"request(myactor, 1,2,3)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"This is called synchronous communication since request blocks until it receives the result (or a Timeout()).","category":"page"},{"location":"intro/#More-Control:-call,-cast,-exec,-query,-update!-...","page":"Getting Started with Actors","title":"More Control: call, cast, exec, query, update! ...","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"There are more such actor protocols and API functions.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We can do asynchronous communication with our actor if we use call with the me link. This sends the given link to the actor and it responds to it. Then we can receive the result asynchronously:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"call(myactor, me, 1000)\nreceive(me).y","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"If we don't provide a return link to call, it will use request and deliver the result synchronously:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"call(myactor, 2000)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Another possibility to communicate asynchronously with an actor is to cast it parameters and then to query the result afterwards.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"cast(myactor, 3000)\nquery(myactor, :res)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"But this will work fine only if between those two calls to myactor there is not another actor communicating with it. If for example our actor has mutual variables as acquaintances, we can use cast to set parameters or to do anything else where we don't need a response.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"With exec we can tell an actor to execute any function and to deliver the result:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"exec(myactor, broadcast, cos, pi .* (-2:2))","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Actors have internal state variables which we normally don't need to work with. We can update! those variables. One example for such a use is to update! the actor's current acquaintance parameter (1000) to 500. Then it adds to 500:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"update!(myactor, Args(500))\ncall(myactor, 500)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"But we could have achieved the same with become!(myactor, +, 500).","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Finally we exit! the actor since we are finished with this introduction:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"exit!(myactor)\nsend(myactor, 500)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Trying to send it something now throws an exception.","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"CurrentModule = Actors","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"warning: The interface is yet experimental!\nMost of the following needs yet work .","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Actors provides a versatile interface to work with other actor libraries in the JuliaActors ecosystem or to allow programmers and users alike to extend its functionality:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"It is written against ActorInterfaces.Classic. Thus it can execute programs written with the primitives in that interface.\nActors from other libraries written with that interface have actor level compatibility. Thus they can exchange messages, use the Actors registry (and upcoming supervision).\nOther libraries written against that interface can plugin the Actors' onmessage protocol and thus inherit the user API functions: call, cast ...\nOther party libraries can start actors in another mode and implement a different onmessage protocol to make their actors do different things.\nUsers can enhance the implemented Msg types and extend the onmessage methods for working with those messages.","category":"page"},{"location":"interface/#Reimplementing-Actor-Primitives","page":"Interface","title":"Reimplementing Actor Primitives","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"On JuliaActors there is a companion library SlowActors to illustrate one use of the interface. This is a completely different implementation of the Actor Model. It doesn't use Julia Channels for message passing and operates without an actor loop. Rather each time a message to a \"slow\" actor is sent, an actor Task is started.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"But in using the common Link type, actors from both libraries can communicate. With actually few lines of code SlowActors plugs in the Actors interface and is able to run the identical examples. It actually only reimplements three primitives: spawn, newLink and send!.","category":"page"},{"location":"interface/#Change-Actor-Mode-and-Behavior","page":"Interface","title":"Change Actor Mode and Behavior","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Actors provides a mode field in both Link and _ACT, with mode=:default for normal operation.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Other libraries can spawn their actors with a different mode, e.g. mode=:GenServer. If they then enhance onmessage with e.g.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Actors.onmessage(A::_ACT, ::Val{:GenServer}, msg::Call) = ...\nActors.onmessage(A::_ACT, ::Val{:GenServer}, msg::Cast) = ...\n....","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"... they get for those messages a different actor behavior where they can do callbacks or set state or whatever they want to. Actors spawned with a different mode return a link with the mode field set accordingly.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Currently there are two libraries capitalizing on this functionality:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"library brief description\nGuards Actors guarding access to mutable variables.\nGenServers Actors representing generic servers and allowing users to write sequential code to use them.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"CurrentModule = Actors","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Actors have internal data structures controlling their behavior:","category":"page"},{"location":"internals/#Actor-State","page":"Internals","title":"Actor State","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"_ACT\nInfo","category":"page"},{"location":"internals/#Actors._ACT","page":"Internals","title":"Actors._ACT","text":"_ACT\n\nInternal actor status variable.\n\nFields\n\nmode::Symbol: the actor mode,\nbhv::Any:  behavior - a callable object,\ninit::Any: initialization - a callable object, \nterm::Any: termination - a callable object,\nself::Link: the actor's address,\nname::Union{Nothing,Symbol}: the actor's registered name.\nres::Any: the result of the last behavior execution,\nsta::Any: a variable for representing state,\nusr::Any: user variable for plugging in something,\nconn::Array{Connection,1}: connected actors.\n\nsee also: Bhv, Link\n\n\n\n\n\n","category":"type"},{"location":"internals/#Actors.Info","page":"Internals","title":"Actors.Info","text":"Actor information\n\nmode::Symbol: actor mode,\nbhvf::Any: behavior function,\npid::Int: process identifier,\nthrd::Int: thread,\ntask::Task: actor task address,\ntid::String: proquint identifier based on task address.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Actor-Mode","page":"Internals","title":"Actor Mode","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"More complex actor behaviors can be realized by changing their mode. Actors uses the following modes:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"mode brief description\n:default the default actor mode.\n:sticky sticky actors do not exit if they get an Exit signal from a connected actor.\n:system behave as :sticky actors, but are  internal actors _REF and _ROOT.\n:supervisor reserved for actors with supervisor behavior.","category":"page"},{"location":"internals/#Connections","page":"Internals","title":"Connections","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The error handling between actors is realized by connections between them","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Connection\nPeer\nMonitor\nMonitored\nSuper\nChild","category":"page"},{"location":"internals/#Actors.Connection","page":"Internals","title":"Actors.Connection","text":"Abstract type for connections between actors.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Actors.Peer","page":"Internals","title":"Actors.Peer","text":"Connection to a peer actor\n\n\n\n\n\n","category":"type"},{"location":"internals/#Actors.Monitor","page":"Internals","title":"Actors.Monitor","text":"Connection to a monitor\n\n\n\n\n\n","category":"type"},{"location":"internals/#Actors.Monitored","page":"Internals","title":"Actors.Monitored","text":"Connection to a monitored actor or task\n\n\n\n\n\n","category":"type"},{"location":"internals/#Actors.Super","page":"Internals","title":"Actors.Super","text":"Connection to a supervisor.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Actors.Child","page":"Internals","title":"Actors.Child","text":"Connection to a supervised actor or task.\n\nFields\n\nlk::L: Link or Task,\nstart::Any: callable object for restarting it,\nrestart::Symbol: :permanent, :temporary or :transient.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Supervision","page":"Internals","title":"Supervision","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"A supervisor actor has a function object as behavior:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Supervisor","category":"page"},{"location":"internals/#Actors.Supervisor","page":"Internals","title":"Actors.Supervisor","text":"Supervisor\n\nSupervisor functor for actors, has data and behavior.\n\nData (acquaintances)\n\nstrategy::Symbol: supervision strategy, can be    either :one_for_one, :one_for_all or :rest_for_one.\nmax_restarts::Int: maximum number of restarts    allowed in a time frame, defaults to 3\nmax_seconds::Float64: time frame in which    max_restarts applies, defaults to 5.\nchilds::Array{Child,1}: supervised childs,\nrtime::Array{Float64,1}: last restart times.\n\n\n\n\n\n","category":"type"},{"location":"glossary/#A-Glossary-of-Actor-Terms","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"","category":"section"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"Since Gul Agha's actor glossary [1] is very useful, we include here some of his descriptions and some additions or changes (marked with (*)).","category":"page"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"Actor term brief description\nacquaintance An actor alpha is an acquaintance of an actor beta if beta knows the mail address of alpha.\nactor A computational agent which has an mail address and a behavior. Actors communicate by message-passing and carry out their actions concurrently.\nasynchronous communication Communication is considered to be asynchronous when the sender does not have to wait for the recipient to be ready to accept a communication before the sender can send the communication.\nbehavior (*) The behavior of an actor maps the incoming communication to a three tuple of messages sent, new actors created, and the replacement behavior.\nbehaviour (*) \"A behavior encapsulates common behavioral patterns.\" Armstrong [2] The Erlang world has a more complex view of behaviors. Such more complex behaviors can be realized with a message protocol.\ncommunication The only mechanism by which actors may affect each other's behavior. The content of a message sent by an actor is called a communication.\nconcurrency The potentially parallel execution of actions without a determinate predefined sequence for their actions.\ncustomer A request communication contains the mail address of an actor called the customer to which a reply to the request is to be sent. Customers are dynamically created to carry out the rest of the computation, so that an actor sending a request to another actor can begin processing the next incoming communication without waiting for the subcomputations of the previous communication to complete.\nevent In the actor model, an event is the acceptance of a communication by an actor. In response to accepting a communication, an actor creates other actors, sends communications and specifies a replacement behavior; in an event based semantics these actions are considered a part of the event.\nexternal actor An actor which is external to a configuration but whose mail address is known to some actor within the configuration.\nfuture A future is an actor representing the value of a computation in progress. Futures can speed up computation since they allow subcomputations using references to a value to proceed concurrently with the evaluation of an expression to compute the value. Communications sent to a future are queued until the value has been determined.\nmail address A virtual location by which an actor may be accessed. Each actor has a unique mail address which is invariant, although the behavior of an actor may change over time.\nmail queue The queue of incoming communications sent to a given actor. The mail queue represents the arrival order of communications and provides the means to buffer communications until they are processed by the target actor.\nprotocol (*) An actor follows a protocol if it – when receiving certain messages – executes predefined behaviors other than its current behavior. This is used to implement more complex behaviors and goes beyond the classical model.\nreceptionist An actor to whom communications may be sent from outside the configuration to which it belongs. The set of receptionists evolves dynamically as the mail addresses of various actors may be communicated to actors outside the system.\nreplacement behavior A behavior specified by an actor processing a communication which is used to process the next communication in the mail queue of the actor.\nreply A communication sent in response to a request (see also customers).\nrequest A communication asking for a response to be sent to a customer contained in the request.\nsynchronous communication Communication between two actors requiring the sender to wait until the recipient acknowledges or otherwise responds to the communication before continuing with further processing. Synchronous communication in actors is implemented using customers.","category":"page"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"[1]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT; Appendix B","category":"page"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"[2]: Joe Armstrong 2014. Programming Erlang, 2nd Ed., Software for a Concurrent World, Pragmatic Programmers; p. 361","category":"page"},{"location":"api/#Actor-API","page":"API","title":"Actor API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Actors","category":"page"},{"location":"api/","page":"API","title":"API","text":"Actors\nActors.version","category":"page"},{"location":"api/#Actors.Actors","page":"API","title":"Actors.Actors","text":"Actors implements the classical Actor Model and is  based on the primitives defined in ActorInterfaces.Classic.  It provides:\n\nbasic primitives for creating actors,   sending messages to them and changing behavior:   spawn, send, become    with Addr and self,\nonmessage, executed by an actor on a    received message,\na message protocol with predefined messages,\nan API based on the protocol with primitives   receive and request and further    API functions become!, call,    cast, exec, exit!,    init!, query, term!,    update!,\nerror handling with actor\nconnections: connect, disconnect, trapExit,\nmonitors: monitor, demonitor,\nsupervisors: supervisor, supervise,    unsupervise, start_actor,    start_task, count_children,    which_children, delete_child,    terminate_child, \nan actor registry: register, unregister,    whereis, registered\n\nand more.\n\nThe current stable, registered version is installed with\n\npkg> add Actors\n\nThe development version is installed with:\n\npkg> add \"https://github.com/JuliaActors/Actors.jl\"\n\n\n\n\n\n","category":"module"},{"location":"api/#Actors.version","page":"API","title":"Actors.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"api/","page":"API","title":"API","text":"using Actors\nActors.version","category":"page"},{"location":"api/#Basic-Types","page":"API","title":"Basic Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following types are needed for using and extending Actors:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Msg\nRequest\nResponse\nLink\nBhv","category":"page"},{"location":"api/#Actors.Msg","page":"API","title":"Actors.Msg","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Request","page":"API","title":"Actors.Request","text":"Request(x, from::Link)\n\nA generic Msg for user requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Response","page":"API","title":"Actors.Response","text":"Response(y, from::Link=self())\n\nA Msg representing a response to requests.\n\nFields\n\ny: response content,\nfrom::Link: sender link.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Link","page":"API","title":"Actors.Link","text":"Link{C} <: ActorInterfaces.Classic.Addr\nLink(chn::C, pid::Int, type::Symbol) where C\n\nA mailbox for communicating with actors. A concrete type of this must be returned by an actor on creation with spawn.\n\nFields/Parameters\n\nchn::C: C can be any type and characterizes the interface   to an actor,\npid::Int: the pid (worker process identifier) of the actor, \nmode::Symbol: a symbol characterizing the actor mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Bhv","page":"API","title":"Actors.Bhv","text":"Bhv(func, a...; kw...)(c...)\n\nA callable struct to represent actor behavior. It is executed with parameters from the incoming communication.\n\nParameters\n\nf: a callable object,\na...: stored acquaintance parameters to f,\nkw...: stored keyword arguments,\nc...: parameters from the incoming communication.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"You can create your own message types with","category":"page"},{"location":"api/","page":"API","title":"API","text":"@msg","category":"page"},{"location":"api/#Actors.@msg","page":"API","title":"Actors.@msg","text":"@msg [Msg] A B C\n\nDefine empty structs as message types. Msg is an existing abstract datatype.\n\nTo call @msg Msg A B C is equivalent to\n\nstruct A <: Msg end\nstruct B <: Msg end\nstruct C <: Msg end\n\nTo call @msg D E F is equivalent to\n\nstruct D end\nstruct E end\nstruct F end\n\n\n\n\n\n","category":"macro"},{"location":"api/#Starting-Actors,-creating-links","page":"API","title":"Starting Actors, creating links","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Actors.jl doesn't export its functions to start actors and to create links. Thus other libraries building on it can implement their own actors and links.","category":"page"},{"location":"api/","page":"API","title":"API","text":"To use Actors's actors and links you import them explicitly:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Actors\nimport Actors: spawn, newLink","category":"page"},{"location":"api/","page":"API","title":"API","text":"Then you can create them with the following functions:","category":"page"},{"location":"api/","page":"API","title":"API","text":"spawn\nnewLink","category":"page"},{"location":"api/#ActorInterfaces.Classic.spawn","page":"API","title":"ActorInterfaces.Classic.spawn","text":"spawn(f, args...; \n      pid=myid(), thrd=false, sticky=false, \n      taskref=nothing, remote=false, mode=:default)\n\nCreate an actor with a behavior f(args...) and return  a Link to it.\n\nParameters\n\nf: callable object (function, closure or functor)   to execute when a message arrives,\nargs...: (partial) arguments to it,\npid=myid(): pid of worker process the actor should be started on,\nthrd=false: thread number the actor should be started on or false,\nsticky=false: if true the actor is started on the current thread,\ntaskref=nothing: if a Ref{Task}() is given here, it gets the started Task,\nremote=false: if true, a remote channel is created,\nmode=:default: mode, the actor should operate in.\n\nNote: If you need keyword arguments kwargs... to  f, you can do spawn(Bhv(f, args...; kwargs...)).\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.newLink","page":"API","title":"Actors.newLink","text":"newLink(size=32; remote=false, pid=myid(), mode=nothing)\n\nCreate a local Link with a buffered Channel size ≥ 1.\n\nParameters\n\nsize=32: the size of the channel buffer,\nremote=false: should a remote link be created,\npid=myid(): optional pid of the remote worker,\nmode=nothing: if mode==nothing the mode is automatically   set to :local or :remote.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actor-Primitives","page":"API","title":"Actor Primitives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following primitives characterize actors in the classical Actor Model:","category":"page"},{"location":"api/","page":"API","title":"API","text":"send\nbecome!\nbecome\nself\nstop\nonmessage","category":"page"},{"location":"api/#ActorInterfaces.Classic.send","page":"API","title":"ActorInterfaces.Classic.send","text":"send(lk::Link, msg...)\n\nSend a message to an actor. msg... are communication parameters to the actor's behavior function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.become!","page":"API","title":"Actors.become!","text":"become!(lk::Link, func, args1...; kwargs...)\nbecome!(name::Symbol, ....)\n\nCause an actor to change behavior.\n\nArguments\n\nactor lk::Link (or name::Symbol if registered),\nfunc: a callable object,\nargs1...: (partial) arguments to func,\nkwargs...: keyword arguments to func.\n\n\n\n\n\n","category":"function"},{"location":"api/#ActorInterfaces.Classic.become","page":"API","title":"ActorInterfaces.Classic.become","text":"become(func, args...; kwargs...)\n\nCause your actor to take on a new behavior. This can only be called from inside an actor/behavior.\n\nArguments\n\nfunc: a callable object,\nargs...: (partial) arguments to func,\nkwargs...: keyword arguments to func.\n\n\n\n\n\n","category":"function"},{"location":"api/#ActorInterfaces.Classic.self","page":"API","title":"ActorInterfaces.Classic.self","text":"self()\n\nGet the Link of your actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.stop","page":"API","title":"Actors.stop","text":"stop(reason=:normal)\n\nCause your actor to stop with a reason.\n\n\n\n\n\n","category":"function"},{"location":"api/#ActorInterfaces.Classic.onmessage","page":"API","title":"ActorInterfaces.Classic.onmessage","text":"onmessage(bhv, msg)\n\nDefault behavior function to execute the current actor  behavior bhv with the message msg. The actor calls bhv(msg) when a message arrives. \n\nParameters\n\nbhv: excutable object (closure or functor) taking   parameters msg,\nmsg: message parameters to bhv.\n\n\n\n\n\nonmessage(A::_ACT, msg)\nonmessage(A::_ACT, mode, msg)\n\nAn actor executes this function when a message arrives.\n\nActor libraries or applications can use this to\n\nplugin the Actors.jl API (first form) or\nextend it to other protocols by using the 2nd form.\n\n\n\n\n\n","category":"function"},{"location":"api/#API-Primitives","page":"API","title":"API Primitives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"To receive messages from actors the following two functions for synchronous and asynchronous communication can be used:","category":"page"},{"location":"api/","page":"API","title":"API","text":"receive\nrequest","category":"page"},{"location":"api/#Actors.receive","page":"API","title":"Actors.receive","text":"receive(lk; timeout=5.0)\nreceive(lk, from; timeout=5.0)\nreceive(lk, M; timeout=5.0)\nreceive(lk, M, from; timeout=5.0)\n\nReceive a message over a link lk.\n\nIf M or from are provided, receive returns only a  matching message. Other messages in lk are restored to it in their previous order.\n\nParameters\n\nlk::Link: local or remote link over which the message is received,\nM::Type{<:Msg}: Msg type,\nfrom::Link: local or remote link of sender. If from is   provided, only messages with a from field can be matched.\ntimeout::Real=5.0: maximum waiting time in seconds.\nIf timeout==0, lk is scanned only for existing messages.\nSet timeout=Inf if you don't want to timeout. \n\nReturns\n\nreceived message or Timeout().\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.request","page":"API","title":"Actors.request","text":"request(lk::Link, msg::Msg; full=false, timeout::Real=5.0)\nrequest(lk::Link, M::Type{<:Msg}, args...; kwargs...)\n\nSend a message to an actor, block, receive and return the result.\n\nArguments\n\nlk::Link: actor link, or name::Symbol (if registered),\nmsg::Msg: a message,\nMsg::Type{<:Msg}: a message type,\nargs...: optional arguments to Msg, \nfull: if true return the full Response message.\ntimeout::Real=5.0: timeout in seconds after which a    Timeout is returned,\nkwargs...: full or timeout.\n\n\n\n\n\n","category":"function"},{"location":"api/#User-API","page":"API","title":"User API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The user API allows you to communicate with actors using the Actors protocol:","category":"page"},{"location":"api/","page":"API","title":"API","text":"call\ncast\nexec\nexit!\ninfo\nquery\nupdate!","category":"page"},{"location":"api/#Actors.call","page":"API","title":"Actors.call","text":"call(lk::Link, [from::Link,] args2...; timeout::Real=5.0)\ncall(name::Symbol, ....)\n\nCall an actor to execute its behavior and to send a  Response with the result. \n\nArguments\n\nactor lk::Link (or name::Symbol if registered), \nfrom::Link: sender link, \nargs2...: remaining arguments to the actor.\ntimeout::Real=5.0: timeout in seconds.\n\nNote: If from is omitted, call blocks and returns the result\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.cast","page":"API","title":"Actors.cast","text":"cast(lk::Link, args2...)\ncast(name::Symbol, args2...)\n\nCast args2... to the actor lk (or name if registered)  to execute its behavior with args2... without sending a  response. \n\nNote: you can prompt the returned value with query.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.exec","page":"API","title":"Actors.exec","text":"exec(lk::Link, from::Link, f, args...; kwargs...)\nexec(lk::Link, f, args...; timeout::Real=5.0, kwargs...)\nexec(name::Symbol, ....)\n\nAsk an actor lk (or name if registered) to execute an  arbitrary function and to send the returned value as  Response.\n\nArguments\n\nactor lk::Link or name::Symbol if registered,\nfrom::Link: the link a Response should be sent to.\nf: a callable object,\nargs...; kwargs...: arguments and keyword arguments to it,\ntimeout::Real=5.0: timeout in seconds. Set timeout=Inf    if you don't want to timeout.\n\nNote: If from is ommitted, exec blocks, waits and  returns the result (with a timeout).\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.exit!","page":"API","title":"Actors.exit!","text":"exit!(lk::Link, reason=:normal)\nexit!(name::Symbol, ....)\n\nTell an actor lk (or name if registered) to stop. If it  has a term function, it calls that with  reason as last argument. \n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.info","page":"API","title":"Actors.info","text":"info(lk::Link)\n\nReturn the state of an actor associated with lk:\n\nActors.Info if it is runnable,\n:done if it has finished,\nelse return the failed task. \n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.query","page":"API","title":"Actors.query","text":"query(lk::Link, [from::Link,] s::Symbol; timeout::Real=5.0)\nquery(name::Symbol, ....)\n\nQuery an actor about an internal state variable s. \n\nParameters\n\nactor lk::Link or name::Symbol if registered,\nfrom::Link: sender link,\ns::Symbol one of :mode,:bhv,:res,:sta,:usr.\ntimeout::Real=5.0: \n\nNote: If from is omitted, query blocks and returns  the response. In that case there is a timeout.\n\nExamples\n\njulia> f(x, y; u=0, v=0) = x+y+u+v  # implement a behavior\nf (generic function with 1 method)\n\njulia> fact = spawn(Bhv(f, 1))     # start an actor with it\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> query(fact, :mode)           # query the mode\n:default\n\njulia> cast(fact, 1)                # cast a 2nd argument to it\nActors.Cast((1,))\n\njulia> query(fact, :res)            # query the result\n2\n\njulia> query(fact, :sta)            # query the state\n\njulia> query(fact, :bhv)            # query the behavior\nBhv(f, (1,), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), Actors.var\"#2#4\"{Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},typeof(f),Tuple{Int64}}(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), f, (1,)))\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.update!","page":"API","title":"Actors.update!","text":"update!(lk::Link, x; s::Symbol=:sta)\nupdate!(lk::Link, arg::Args)\nupdate!(name::Symbol, ....)\n\nUpdate an actor's internal state s with args....\n\nArguments\n\nactor lk::Link or name::Symbol if registered,\nx: value/variable to update the choosen state with,\narg::Args: arguments to update,\ns::Symbol: one of :arg, :mode, :name, :self, :sta, :usr.\n\nNote: If you want to update the stored arguments to the  behavior function with s=:arg, you must pass an Args  to arg. If Args has keyword arguments, they are merged  with existing keyword arguments to the behavior function.\n\nExample\n\njulia> update!(fact, 5)       # update the state variable\nActors.Update(:sta, 5)\n\njulia> query(fact, :sta)      # query it\n5\n\njulia> update!(fact, Args(0, u=5, v=5));  # update arguments to the behavior \n\njulia> call(fact, 0)          # call the actor with 0\n10\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The following is needed for updating arguments:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Args","category":"page"},{"location":"api/#Actors.Args","page":"API","title":"Actors.Args","text":"Args(args...; kwargs...)\n\nA structure for updating arguments to an actor's behavior.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actor-Registry","page":"API","title":"Actor Registry","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Actors can be registered with Symbols to a registry. API functions on actors can then be called with their registered names.","category":"page"},{"location":"api/","page":"API","title":"API","text":"register\nunregister\nwhereis\nregistered","category":"page"},{"location":"api/#Actors.register","page":"API","title":"Actors.register","text":"register(name::Symbol, lk::Link)\n\nRegister the actor lk with name. Returns true if the  registration succeeds, false if name is already in use.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.unregister","page":"API","title":"Actors.unregister","text":"unregister(name::Symbol)\n\nRemove any registrations associated with name.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.whereis","page":"API","title":"Actors.whereis","text":"whereis(name::Symbol)\n\nFind out whether name is registered. Return the actor link  lk or missing if not found.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.registered","page":"API","title":"Actors.registered","text":"registered()\n\nReturn an Array of all registered actors in the system.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The registry works transparently over distributed worker processes such that local links are transformed to remote links when shared between workers.","category":"page"},{"location":"api/#Error-Handling","page":"API","title":"Error Handling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"init!\nterm!","category":"page"},{"location":"api/#Actors.init!","page":"API","title":"Actors.init!","text":"init!(lk::Link, f, args...; kwargs...)\ninit!(name::Symbol, ....)\n\nTell an actor lk to save the callable object f with  the given arguments as an init function  and to execute it.\n\nThe init function will be called at actor restart.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.term!","page":"API","title":"Actors.term!","text":"term!(lk::Link, func, args...; kwargs...)\nterm!(name::Symbol, ....)\n\nTell an actor lk (or name::Symbol if registered) to  execute func with the given partial arguments and an exit reason when it terminates. \n\nThe exit reason is added by the actor to args1... when it  exits.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Connections","page":"API","title":"Connections","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Connected actors send each other Exit signals and terminate together unless they are made :sticky with trapExit:","category":"page"},{"location":"api/","page":"API","title":"API","text":"connect\ndisconnect\ntrapExit","category":"page"},{"location":"api/#Actors.connect","page":"API","title":"Actors.connect","text":"connect(lk::Link)\n\nCreate a connection between the calling actor and  the actor represented by lk. \n\nConnected actors will send each other Exit  signals. A connected actor will exit with the signaled reason  unless it is :normal.\n\nNote:\n\nAn actor can be made :sticky with trapExit and then will not exit.\nIf this is called from the Main scope, lk is \n\nconnected to the Actors._ROOT actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.disconnect","page":"API","title":"Actors.disconnect","text":"disconnect(lk::Link)\n\nRemove the connection between the calling actor and the actor represented by lk.\n\nNote: If this is called from the Main scope, lk  is disconnected from the _ROOT actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.trapExit","page":"API","title":"Actors.trapExit","text":"trapExit(lk::Link=self(), mode=:sticky)\n\nChange the mode of an actor.\n\nA :sticky actor does not exit if it receives an  Exit signal from a connected actor and does  not propagate it further. Instead it reports the failure  and saves a link to the failed actor. \n\nSee diag for getting links to failed actors  from a :sticky actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Monitors","page":"API","title":"Monitors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Actors can warn or take actions if their monitored actors or tasks terminate.","category":"page"},{"location":"api/","page":"API","title":"API","text":"monitor\ndemonitor","category":"page"},{"location":"api/#Actors.monitor","page":"API","title":"Actors.monitor","text":"monitor(lk::Link, onsignal...)\nmonitor(t::Task, onsignal...; timeout::Real=5.0, pollint::Real=0.1)\n\nStart monitoring the actor represented by lk or the task t and execute onsignal... if it sends Down or if it fails.\n\nParameters\n\nonsignal...: action to take on Down signal: \nif empty, it gives a warning; \nif it is one argument f, it executes with  f(msg.reason); \nif f, args..., it gets executed with  f(args..., msg.reason).\ntimeout::Real=5.0: how many seconds should a task    be monitored? After that a Down with   reason :timed_out is sent.\npollint::Real=0.1: polling interval in seconds for   task monitoring.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.demonitor","page":"API","title":"Actors.demonitor","text":"demonitor(lk::Link)\n\nRemove the monitoring for the given link lk.\n\n\n\n\n\n","category":"function"},{"location":"api/#Supervisors","page":"API","title":"Supervisors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A supervisor actor can restart its children if they should terminate.","category":"page"},{"location":"api/","page":"API","title":"API","text":"supervisor\nsupervise\nunsupervise\nstart_actor\nstart_task\ncount_children\nwhich_children\ndelete_child\nterminate_child","category":"page"},{"location":"api/#Actors.supervisor","page":"API","title":"Actors.supervisor","text":"supervisor( strategy=:one_for_one, \n            max_restarts::Int=3, \n            max_seconds::Real=5; \n            name=nothing, kwargs...)\n\nStart a supervisor actor with an empty child list and return a link to it.\n\nParameters\n\nstrategy=:one_for_one: supervision strategy, can be    either :one_for_one, :one_for_all or :rest_for_one,\nmax_restarts::Int=3: maximum number of restarts    allowed in a time frame,\nmax_seconds::Real=5: time frame in which    max_restarts applies,\nname=nothing: name (Symbol) under which it should   be registered,\nkwargs...: keyword arguments to spawn.\n\nnote: Note\nSee the manual chapter on error handling for explanations of strategy.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.supervise","page":"API","title":"Actors.supervise","text":"supervise(sv::Link, start, restart::Symbol=:transient; \n          timeout::Real=5.0, pollint::Real=0.1)\n\nTell a supervisor sv to add the calling actor or task to its childs list.\n\nParameters\n\nsv::Link: link to a started supervisor,\nstart: start behavior of the child, a callable object,\nrestart::Symbol=:transient: restart option, one of    :permanent, :temporary, :transient,\n\nnote: Note\nSee the manual chapter on error handling for explanations of restart options.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.unsupervise","page":"API","title":"Actors.unsupervise","text":"unsupervise(sv::Link)\n\nTell a supervisor sv to delete the calling actor or task from the childs list. \n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.start_actor","page":"API","title":"Actors.start_actor","text":"start_actor(sv::Link, start, restart::Symbol; kwargs...)\n\nTell a supervisor sv to start an actor, to add  it to its childs list and to return a link to it.\n\nParameters\n\nsv::Link: link to a started supervisor,\nstart: start behavior of the child, a callable object,\nrestart::Symbol=:transient: restart option, one of    :permanent, :temporary, :transient,\nkwargs...: keyword arguments to spawn.\n\nnote: Note\nSee the manual chapter on error handling for explanations of restart options.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.start_task","page":"API","title":"Actors.start_task","text":"start_task(sv::Link, start, restart::Symbol; \n           timeout::Real=5.0, pollint::Real=0.1)\n\nTell a supervisor sv to start a child task, to add  it to its childs list and to return it.\n\nParameters\n\nsv::Link: link to a started supervisor,\nstart: must be callable with no arguments,\nrestart::Symbol=:transient: restart option, one of    :temporary, :transient,\ntimeout::Real=5.0: how many seconds should a task    be supervised, \npollint::Real=0.1: polling interval in seconds.\n\nnote: Note\nSee the manual chapter on error handling for explanations of restart options.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.count_children","page":"API","title":"Actors.count_children","text":"count_children(sv::Link)\n\nReturn a named tuple containing counts for the given supervisor sv.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.which_children","page":"API","title":"Actors.which_children","text":"which_children(sv::Link)\n\nTell a supervisor sv to return its childs list.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.delete_child","page":"API","title":"Actors.delete_child","text":"delete_child(sv::Link, c::Link)\n\nTell a supervisor sv to delete c from the childs list. \n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.terminate_child","page":"API","title":"Actors.terminate_child","text":"terminate_child(sv::Link, c::Link)\n\nTell a supervisor sv to remove a child c from its  childs and to terminate it with reason :shutdown.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"tid","category":"page"},{"location":"api/#Actors.tid","page":"API","title":"Actors.tid","text":"tid(n::Int)\n\nReturn a threadid where an n-th calculation could run.\n\nThis is for emulating a @threads for loop with actors.\n\n\n\n\n\n","category":"function"},{"location":"api/#Diagnosis","page":"API","title":"Diagnosis","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"diag","category":"page"},{"location":"api/#Actors.diag","page":"API","title":"Actors.diag","text":"diag(lk::Link, check::Symbol=:state)\ndiag(name::Symbol, ....)\n\nDiagnose an actor, get a state or stacktrace.\n\nArguments\n\nlk::Link: actor link,\ncheck::Symbol: requested information,\n\n- `:state`: :ok if the actor is running, \n- `:task`: current actor task,\n- `:tid`: current actor task encoded as a proquint string,\n- `:pid`: process identifier number,\n- `:act`: actor `_ACT` variable,\n- `:info`: actor `Info`,\n- `:err`: error log (only monitors or supervisors).\n\nwarn: This is for diagnosis only!\n\n\nModifying an actor's state can cause a race condition.\n\n\n\n\n\n","category":"function"},{"location":"examples/dining_phil/#Dining-Philosophers","page":"Dining Philosophers","title":"Dining Philosophers","text":"","category":"section"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"This is a classic problem to illustrate challenges with concurrency. We will give here a solution based on Dale Schumacher's blogpost [1]. First some initial definitions:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"using Actors\nimport Actors: spawn\n\nconst eating_time = 5\nconst thinking_time = 10\nconst speedup = 100\n\nmutable struct Phil{L}\n    left::L\n    right::L\n    eaten::Float64\nend\n\ndelay(time, msg, cust) = async() do \n    sleep(time/speedup)\n    send(cust, msg)\nend\n\n@msg Take Taken Busy Put Eat Think","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"The first part of an actor based solution is that each chopstick between the philosophers is an actor. So only one access to a chopstick is possible at a time. And the philosophers will have to communicate with the chopsticks to take them:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"mutable struct Chopstick\n    idle::Bool\n    Chopstick() = new(true)\nend\n\nfunction (c::Chopstick)(cust, ::Take)\n    if c.idle\n        send(cust, self(), Taken())\n        c.idle = false\n    else\n        send(cust, self(), Busy())\n    end\nend\n(c::Chopstick)(::Put) = c.idle = true","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"We have modeled a chopstick actor as a function object with two message arguments, Take and Put.","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"Now the philosophers! We model them with behavior functions representing their state, the respective philosopher as an acquaintance and state transitions with become. So a philosopher is modeled as a finite state machine:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"function thinking(p::Phil, ::Eat)\n    send(p.left, self(), Take())\n    send(p.right, self(), Take())\n    become(hungry, p)\nend\nfunction hungry(p::Phil, chop, ::Taken)\n    chop == p.left ?\n        become(right_waiting, p) :\n        become(left_waiting,  p)\nend\nhungry(p::Phil, chop, ::Busy) = become(denied, p)\nfunction denied(p::Phil, other, ::Taken)\n    send(other, Put())\n    become(thinking, p)\n    send(self(), Eat())\nend\nfunction denied(p::Phil, chop, ::Busy)\n    become(thinking, p)\n    send(self(), Eat())\nend\nfunction right_waiting(p::Phil, chop, ::Taken)\n    if chop == p.right \n        become(eating, p)\n        p.eaten += te = randn()+eating_time\n        delay(te, Think(), self())\n    end\nend\nfunction right_waiting(p::Phil, chop, ::Busy)\n    send(p.left, Put())\n    become(thinking, p)\n    send(self(), Eat())\nend\nfunction left_waiting(p::Phil, chop, ::Taken)\n    if chop == p.left\n        become(eating, p)\n        p.eaten += te = randn()+eating_time\n        delay(te, Think(), self())\n    end\nend\nfunction left_waiting(p::Phil, chop, ::Busy)\n    send(p.right, Put())\n    become(thinking, p)\n    send(self(), Eat())\nend\nfunction eating(p::Phil, ::Think)\n    send(p.left, Put())\n    send(p.right, Put())\n    become(thinking, p)\n    delay(randn()+thinking_time, Eat(), self())\nend","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"The crucial step in preventing a deadlock is that a philosopher puts down his chopstick if he is  right_waiting or left_waiting and gets a :busy or if he is denied and gets a :taken message. Then he switches again to thinking and sends a message to himself to :eat. So he can try again.","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"We need a stats function for eating time and we setup everything:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"eaten(phils...) = Tuple(round(Int, query(p, :bhv).a[1].eaten) for p in phils)\n\nc1 = spawn(Chopstick())\nc2 = spawn(Chopstick())\nc3 = spawn(Chopstick())\nc4 = spawn(Chopstick())\nc5 = spawn(Chopstick())\n\ndescartes = spawn(thinking, Phil(c1,c2,0.0))\nnietzsche = spawn(thinking, Phil(c2,c3,0.0))\nkant      = spawn(thinking, Phil(c3,c4,0.0))\nhume      = spawn(thinking, Phil(c4,c5,0.0))\nplato     = spawn(thinking, Phil(c5,c1,0.0))\n\nfor p in (descartes, nietzsche, kant, hume, plato)\n    delay(thinking_time, Eat(), p)\nend","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"To get some stats we print the eaten times every second:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"julia > for i in 1:5\n            sleep(1)\n            println(i, \"s: \", eaten(descartes, nietzsche, kant, hume, plato))\n        end\n1s: (24, 34, 32, 31, 31)\n2s: (57, 70, 61, 62, 65)\n3s: (86, 101, 89, 96, 100)\n4s: (119, 129, 123, 124, 132)\n5s: (151, 162, 155, 155, 162)","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"So they are happy thinking and eating asynchronously. Since we have a speedup of 100, we can conclude that in 500 time units our philosophers eat around 155 (much more than programmers). We stop the whole thing in order to prevent overconsumption:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"julia > foreach(a->exit!(a), (descartes, nietzsche, kant, hume, plato, c1, c2, c3, c4, c5))","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"Actually Gul Agha proposed something else. He reasoned about to let philosophers talk to each other:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"An actor is free and able to figure out a deadlock situation by querying other actors as to their local state. ... While these philosophers may be \"busy\" eating or looking for a chopstick, they nevertheless accept communications sent to them. [2]","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"We did not go this road in order to avoid philosophical debates about local state. But you can try for yourself.","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"[1]: Dale Schumacher. It's Actors All The Way Down, 2010: \"Dining Philosophers\" in Humus","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"[2]: Gul Agha, 1986. Actors: A Model of Concurrent Computation in Distributed Systems, MIT,- p. 95","category":"page"},{"location":"diag/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"diag/","page":"Diagnostics","title":"Diagnostics","text":"CurrentModule = Actors","category":"page"},{"location":"diag/","page":"Diagnostics","title":"Diagnostics","text":"Actors are represented only by their Links. There are two API functions: info and diag (not exported) to get more information about them.","category":"page"},{"location":"diag/#Actor-Identification","page":"Diagnostics","title":"Actor Identification","text":"","category":"section"},{"location":"diag/","page":"Diagnostics","title":"Diagnostics","text":"Actors can be identified by their task's address. On a common 64-bit machine this is a UInt64 number. To improve readability Actors shows this number encoded as a Proquint string (short form):","category":"page"},{"location":"diag/","page":"Diagnostics","title":"Diagnostics","text":"julia> sv = supervisor()\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :supervisor)\n\njulia> info(sv)\nActor    supervisor\nBehavior Actors.Supervisor\nPid      1, Thread 2\nTask     @0x0000000120c16890\nIdent    x-d-fagad-kofib\n\njulia> Actors.diag(sv, :task)\nTask (runnable) @0x0000000120c16890\n\njulia> Actors.diag(sv, :tid)\n\"x-d-fagad-kofib\"\n\njulia> exit!(sv, :shutdown);\n┌ Warning: 2021-02-05T12:51:33.288 x-d-fagad-kofib: Exit: supervisor shutdown\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:30\n\njulia> using Proquint\n\njulia> quint2uint(\"x-d-fagad-kofib\")\n0x0000000120c16890","category":"page"},{"location":"diag/#Status-Information","page":"Diagnostics","title":"Status Information","text":"","category":"section"},{"location":"diag/","page":"Diagnostics","title":"Diagnostics","text":"For testing and diagnosis you can use diag to get status information from an actor. For example diag(x, :act) returns the actors' x status variable:","category":"page"},{"location":"diag/","page":"Diagnostics","title":"Diagnostics","text":"julia> myact = spawn(threadid)\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> myact_state = Actors.diag(myact, :act)\nActors._ACT(:default, Base.Threads.threadid, nothing, nothing, Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default), nothing, nothing, nothing, nothing, Actors.Connection[])","category":"page"},{"location":"diag/","page":"Diagnostics","title":"Diagnostics","text":"But since an actors' state is private, this should be used for diagnostic purposes only.","category":"page"},{"location":"behaviors/#Actor-Behavior","page":"Actor Behavior","title":"Actor Behavior","text":"","category":"section"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"CurrentModule = Actors","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"An actor embodies the essential elements of  computation: 1) processing, 2) storage and 3) communication.","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"When an Actor receives a message, it can concurrently:send messages to ... addresses of Actors that it has;\ncreate new Actors;\ndesignate how to handle the next message it receives. [1]","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"For that Gul Agha introduced the behavior as a ...","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"... function of the incoming communication. Two lists of identifiers are used in a behavior definition. Values for the first list of parameters must be specified when the actor is created. This list is called the acquaintance list. The second list of parameters, called the communication list, gets its bindings from an incoming communication. [2]","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Thus a behavior maps the incoming communication to a three tuple of messages sent, new actors created and the replacement behavior:","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"beginarraylrl\nf_i(a_i)c_i  rightarrow mu_umu_v alpha_xalpha_yf_i+1(a_i+1) quad\ntextrmwith  f  textrmbehavior function \n  a  textrmacquaintances \n  c  textrmcommunication \n  mu  textrmmessages sent \n  alpha  textrmactors created \nendarray","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Actors represents a behavior as partial application of a function f to acquaintances a (variables, values or actors the actor knows of). If a communication c arrives, the behavior executes f(ac):","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"f(a, c) = a + c         # define a function\npartial(f, a...; kw...) = (c...) -> f(a..., c...; kw...)\nbhv = partial(f, 1)     # partially apply f to 1\nbhv(2)                  # execute f(1,2)","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Actor behavior can be represented in a functional or in an object-oriented style. Both are interchangeable.","category":"page"},{"location":"behaviors/#Functional-Style","page":"Actor Behavior","title":"Functional Style","text":"","category":"section"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"The behavior is a function f together with acquaintance arguments a... and kw... (keyword arguments) to it. Bhv creates a partial application (a closure) ϕ(a...; kw...) which  can be executed with communication arguments c...:","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"using Actors\nf(s, t, u, v; w=1, x=1) = s + t + u + v + w + x   # a function\nbhv = Bhv(f, 1, 1, w=2, x=2);  # create a Bhv with f and acquaintances\nbhv(1, 1)                      # execute it with communication parameters","category":"page"},{"location":"behaviors/#Object-oriented-Style","page":"Actor Behavior","title":"Object-oriented Style","text":"","category":"section"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Alternatively we put the acquaintance parameters in an object which we make executable (see: function object) with communication parameters:","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"struct Acqu                    # define an object with acquaintances\n    s; t; w; x\nend\n(a::Acqu)(u, v) = a.s + a.t + u + v + a.w + a.x  # make it executable with communication parameters\nbhv = Acqu(1,1,2,2)            # create an instance\nbhv(1,1)                       # execute it with communication parameters","category":"page"},{"location":"behaviors/#Freestyle","page":"Actor Behavior","title":"Freestyle","text":"","category":"section"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"With being callable the only hard requirement for a behavior, you can pass anything callable as behavior to an actor regardless whether it contains acquaintances or not:","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"using Actors, .Threads\nimport Actors: spawn, newLink\nmyactor = spawn(threadid)                     # a parameterless function\ncall(myactor)\nbecome!(myactor, (lk, x, y) -> send(lk, x^y)) # an anonymous function with communication arguments\nme = newLink()\nsend(myactor, me, 123, 456)\nreceive(me)","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"You can give functors further acquaintance parameters (as for the players in the table-tennis example). Of course you can give objects containing acquaintances as parameters to a function and create a partial application with Bhv on them and much more. Be my guest!","category":"page"},{"location":"behaviors/#stack","page":"Actor Behavior","title":"Agha's Stack example","text":"","category":"section"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Now more realistically for actor behavior we reproduce Agha's example 3.2.1 [3]:","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"using Actors\nimport Actors: spawn, newLink\n\nmutable struct StackNode{T,L}  # a stack node object\n    content::T\n    link::L\nend\n\nstruct Pop{L}                  # a pop message\n    customer::L\nend\n\nstruct Push{T}                 # a push message\n    content::T\nend\n\n# now three behavior methods\nforwarder = send\nfunction (sn::StackNode)(msg::Pop)\n    isnothing(sn.content) || become(forwarder, sn.link)\n    send(msg.customer, Response(sn.content))\nend\n(sn::StackNode)(msg::Push) = become(StackNode(msg.content, spawn(sn)))","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Here we use both the functional and the object oriented approach:","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"forwarder is a function which we put together with sn.link into a Bhv,\nStackNode is an object, which gets two methods.","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Now we can operate the stack:","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"julia> mystack = spawn(StackNode(nothing, newLink()))\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> response = newLink()\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :local)\n\njulia> for i ∈ 1:5\n           send(mystack, Push(i))\n       end\n\njulia> for i ∈ 1:5\n           send(mystack, Pop(response))\n           println(receive(response).y)\n       end\n5\n4\n3\n2\n1","category":"page"},{"location":"behaviors/#Setting-and-Changing-Behavior","page":"Actor Behavior","title":"Setting and Changing Behavior","text":"","category":"section"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"An actor's behavior is set with spawn and gets changed with become!. Inside a behavior function an actor can change its own behavior with become. In both cases a callable object together with acquaintance arguments can be specified as new behavior. This is effective when the next message gets processed.","category":"page"},{"location":"behaviors/#Don't-Share-Mutable-Variables","page":"Actor Behavior","title":"Don't Share Mutable Variables","text":"","category":"section"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"As you have seen, you are very free in how you define behaviors, but you must be very careful in passing mutable variables as acquaintances to actors as they could be accessed by other actors on other threads concurrently causing race conditions. ","category":"page"},{"location":"behaviors/#Instead-Share-Actors","page":"Actor Behavior","title":"Instead Share Actors","text":"","category":"section"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"It is thread-safe to share actors between threads or other actors. Each call to the shared actor is a communication.","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"In the table-tennis example we shared a print server actor between player actors working on different threads.\nIn the Dict-server example a dictionary gets served by an actor to parallel threads.\nYou can wrap mutable variables into a :guard actor, which will manage access to them.\nIn more complicated cases of resource sharing you can use a :genserver actor.","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"As those examples show, it is surprisingly easy to avoid race conditions by using actors.","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"[1]: Carl Hewitt. Actor Model of Computation: Scalable Robust Information Systems.- arXiv:1008.1459.","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"[2]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT.- p. 30","category":"page"},{"location":"behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"[3]: ibid. p. 34","category":"page"},{"location":"examples/prod_cons/#Producer-Consumer-Problem","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"","category":"section"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"This classic problem describes producers and consumers sharing a buffer with a given capacity. A producer produces an item at a time, puts it into the buffer and starts again. At the same time consumers are consuming the items (i.e. removing them from the buffer). The problem ist to make sure that a producer won't add items to the buffer if it is full and that a consumer won't try to remove them from an empty buffer. ","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"The solution for a producer is to go to sleep if the buffer is full. The next time, a consumer removes an item from the buffer, the buffer notifies the stalled producer, who then starts to replenish the buffer again. In the same way, the consumer can go to waiting if it finds the buffer empty. The next time a producer delivers an item, the buffer notifies the waiting consumer.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"We implement this problem with three kinds of actors for store, producer and consumer.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"The store has a fixed capacity, holds items and queues of stalled producers and waiting customers and a counting variable.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"# examples/prod_cons.jl\n\nusing Actors, Printf\nimport Actors: spawn\n\nconst maxitems = 10\n\nmutable struct Store\n    capacity::Int\n    items::Array{Any,1}\n    prod::Array{Link,1}\n    cons::Array{Link,1}\n    count::Int\n    Store(capacity::Int) = new(capacity, Any[], Link[], Link[], 0)\nend\n\navailable(s::Store) = 0 < length(s.items) < s.capacity\nisfull(s::Store) = length(s.items) ≥ s.capacity\nBase.isempty(s::Store) = isempty(s.items)","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"We implement the store's behavior as a function object receiving two messages Put() and Take().","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"@msg Put Full Done Ok Take Empty Notify\n\nfunction (s::Store)(::Put, prod, item)\n    if isfull(s)\n        send(prod, Full(), item)\n        push!(s.prod, prod)\n    elseif s.count < maxitems\n        push!(s.items, item)\n        s.count += 1\n        s.count == maxitems ?\n            send(prod, Done()) :\n            send(prod, Ok(), item)\n        !isempty(s.cons) && send(popfirst!(s.cons), Notify())\n    else\n        send(prod, Done())\n    end\nend\nfunction (s::Store)(::Take, cons)\n    if isempty(s)\n        send(cons, Empty())\n        push!(s.cons, cons)\n    else\n        send(cons, popfirst!(s.items))\n        !isempty(s.prod) && send(popfirst!(s.prod), Notify())\n    end\nend","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Producers and consumers have a name and a link to the store:","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"struct Prod\n    name::String\n    store::Link\nend\n\nstruct Cons\n    name::String\n    store::Link\nend","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Those are acquaintances of their behavior functions. We have also a print server actor prn as a global variable.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"function prod_start(p::Prod, start)\n    become(producing, p)\n    send(self(), start+1)\n    send(prn, \"producer $(p.name) started\")\nend\nfunction producing(p::Prod, item)\n    sleep(rand())\n    send(p.store, Put(), self(), item)\nend\nfunction producing(p::Prod, ::Ok, item)\n    send(prn, \"producer $(p.name) delivered item $item\")\n    send(self(), item+1)\nend\nfunction producing(p::Prod, ::Full, item)\n    send(prn, \"producer $(p.name) stalled with item $item\")\n    become(stalled, p, item)\nend\nfunction producing(p::Prod, ::Done)\n    send(prn, \"producer $(p.name) done\")\n    stop()\nend\nfunction stalled(p::Prod, item, ::Notify)\n    send(p.store, Put(), self(), item)\n    become(producing, p)\nend\n\nfunction cons_start(c::Cons)\n    become(buying, c)\n    send(c.store, Take(), self())\n    send(prn, \"consumer $(c.name) started\")\nend\nfunction buying(c::Cons, item)\n    become(consuming)\n    send(self(), c)\n    send(prn, \"consumer $(c.name) got item $item\")\nend\nfunction buying(c::Cons, ::Empty)\n    become(waiting, c)\n    send(prn, \"consumer $(c.name) found store empty\")\nend\nfunction consuming(c)\n    sleep(rand())\n    become(buying, c)\n    send(c.store, Take(), self())\nend\nfunction waiting(c::Cons, ::Notify)\n    become(buying, c)\n    send(c.store, Take(), self())\nend","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Finally we start the simulation with a print server, a store, three producers and two consumers.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"prn = spawn(s->print(@sprintf(\"%s\\n\", s)))\nst = spawn(Store(5))\npr1 = spawn(prod_start, Prod(\"A\", st), 100)\npr2 = spawn(prod_start, Prod(\"B\", st), 200)\npr3 = spawn(prod_start, Prod(\"C\", st), 300)\ncs1 = spawn(cons_start, Cons(\"U\", st))\ncs2 = spawn(cons_start, Cons(\"V\", st))\n\nforeach(x->send(x), (pr1,pr2,pr3,cs1,cs2))","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Let's see, what happens:","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"julia> include(\"examples/prod_cons.jl\")\n\njulia> producer A started\nconsumer U started\nproducer C started\nproducer B started\nconsumer V started\nconsumer V found store empty\nconsumer U found store empty\nproducer A delivered item 101\nconsumer U got item 101\nproducer B delivered item 201\nconsumer V got item 201\nproducer C delivered item 301\nconsumer V got item 301\nconsumer U found store empty\nproducer C delivered item 302\nconsumer U got item 302\nproducer B delivered item 202\nproducer C delivered item 303\nproducer B delivered item 203\nproducer A delivered item 102\nproducer A delivered item 103\nconsumer U got item 202\nconsumer V got item 303\nproducer A done\nconsumer V got item 203\nproducer C done\nproducer B done\nconsumer V got item 102\nconsumer U got item 103\nconsumer V got item 104\nconsumer U found store empty\nconsumer V found store empty","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"We had limited the sold items to 10. This is a queueing process.","category":"page"},{"location":"#Actors-Documentation","page":"Actors Documentation","title":"Actors Documentation","text":"","category":"section"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors implements the classical Actor model using Julia's concurrency primitives.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"An actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [1]","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors enhance Julia's capabilities for concurrent computing. They can be used together with other Julia functionality for multi-threading and distributed computing.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors use Julia functions as behaviors and are","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"responsive – they react to users - and\nmessage-driven - they rely on asynchronous message-passing [2].","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors has a modern API [3], can interface with other actor libraries and can be extended by them using actor protocols.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors is in active development. If you want to contribute, please join JuliaActors.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"[1]: See the Wikipedia entry on the Actor Model.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"[2]: See The Reactive Manifesto. Its other two tenets resilient and elastic are prepared for and are likely to come soon.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"[3]: The Actors API is inspired by Erlang/OTP, see OTP Design Principles - User’s Guide","category":"page"}]
}
