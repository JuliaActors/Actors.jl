var documenterSearchIndex = {"docs":
[{"location":"examples/examples/#Further-Examples","page":"Further Examples","title":"Further Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Further Examples","title":"Further Examples","text":"In the manual there are the following examples:","category":"page"},{"location":"examples/examples/","page":"Further Examples","title":"Further Examples","text":"Table-tennis,\nAgha's Stack example,\nA Dict Server","category":"page"},{"location":"examples/examples/","page":"Further Examples","title":"Further Examples","text":"See also the examples in the repository.","category":"page"},{"location":"howto/communicate/#How-to-communicate-with-actors","page":"communicate with actors","title":"How to communicate with actors","text":"","category":"section"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"CurrentModule = Actors","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"An actor dispatches an incoming message ","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"as a communication parameter to its behavior function or\nif it is a Msg, it processes it according to the message protocol.","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"Then it immediately proceeds to the next message if there is one or it waits for it.","category":"page"},{"location":"howto/communicate/#by-send","page":"communicate with actors","title":"by send","text":"","category":"section"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"If we send an actor a message (which is not of type Msg), we cause it to pass it as a communication argument to its behavior:","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"julia> using Actors\n\njulia> import Actors: spawn, newLink\n\njulia> myactor = spawn(println, \"Hello \")\nLink{Channel{Any}}(Channel{Any}(32), 1, :default)\n\njulia> send(myactor, \"World!\");\nHello World!","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"Actors can send messages to other actors if they have their links:","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"julia> pserv = spawn(println)                    # spawn a print server\nLink{Channel{Any}}(Channel{Any}(32), 1, :default)\n\njulia> become!(myactor, send, pserv, \"Hello \");  # cause myactor to use it\n\njulia> send(myactor, \"Kermit!\");\nHello Kermit!","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"Actors receive messages implicitly.","category":"page"},{"location":"howto/communicate/#receive","page":"communicate with actors","title":"receive","text":"","category":"section"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"Receiving a message is a blocking operation. Since here actors are implemented as Julia Tasks, either they are busy in processing a message or waiting for the next message to arrive. We can use receive explicitly in order to communicate with actors. To do it, we ","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"use newLink to create a Link,\ncommunicate it to an actor and\ncause it to send something to the given link.\nThen we can receive the actor's message.","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"julia> me = newLink()\nLink{Channel{Any}}(Channel{Any}(32), 1, :local)\n\njulia> become!(myactor, (f, args...)->send(me, f(args...)));\n\njulia> send(myactor, +, 1, 2, 3)\n(+, 1, 2, 3)\n\njulia> println(\"now doing something else ...\")\nnow doing something else ...\n\njulia> receive(me)\n6","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"This is asynchronous bidirectional communication : sender and receiver are decoupled.","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"If we call receive after the message has been delivered, it will return it immediately.\nIf we call it before, it will wait until delivery or until it times out.","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"julia> receive(me)\nActors.Timeout()","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"So far we used send and receive explicitly to communicate with actors.","category":"page"},{"location":"howto/communicate/#use-the-messaging-protocol","page":"communicate with actors","title":"use the messaging protocol","text":"","category":"section"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"The messaging protocol is another way to communicate with an actor. It can be used to cause an actor to do also other things e.g. giving information, executing arbitrary functions or updating parameters. You normally won't use it explicitly since we have the user API for that. But here we demonstrate briefly how to do it.","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"We cause our actor to assume a +-behavior. It will add what we send to it, but it will not send it back. Now if we send it a Call with the same information, it will send a Response with the result to the given link:","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"julia> become!(myactor, +);\n\njulia> send(myactor, Actors.Call((1,2,3), me))\nActors.Call((1, 2, 3), Link{Channel{Any}}(Channel{Any}(32), 1, :local))\n\njulia> receive(me)\nResponse(6, Link{Channel{Any}}(Channel{Any}(32), 1, :default))\n\njulia> ans.y\n6","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"A user or programmer can enhance the messaging protocol (see below).","category":"page"},{"location":"howto/communicate/#use-the-user-API-functions","page":"communicate with actors","title":"use the user API functions","text":"","category":"section"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"The user API to the messaging protocol provides an easy way to communicate with actors.","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"request is a wrapper for synchronous bidirectional communication. It creates a link internally and sends it with the communication parameters as a Call (or another given message type) to the actor. So it is a shortcut for the above explicit use:","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"julia> request(myactor, 1,2,3)\n6","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"call can do both asynchronous and synchronous (bidirectional) communication. If you give it a link, the actor will respond to that:","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"julia> call(myactor, me, 1, 2, 3)\nActors.Call((1, 2, 3), Link{Channel{Any}}(Channel{Any}(32), 1, :local))\n\njulia> receive(me).y\n6","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"If you don't give it a link, it will use a request and work synchronously:","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"julia> call(myactor, 1, 2, 3)\n6","category":"page"},{"location":"howto/communicate/","page":"communicate with actors","title":"communicate with actors","text":"There are more user API functions for accessing the messaging protocol.","category":"page"},{"location":"howto/communicate/#write-your-own-actor-API","page":"communicate with actors","title":"write your own actor API","text":"","category":"section"},{"location":"howto/communicate/#enhance-the-messaging-protocol","page":"communicate with actors","title":"enhance the messaging protocol","text":"","category":"section"},{"location":"reference/diag/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"reference/diag/","page":"Diagnostics","title":"Diagnostics","text":"CurrentModule = Actors","category":"page"},{"location":"reference/diag/","page":"Diagnostics","title":"Diagnostics","text":"Actors are represented only by their Links. There are two API functions: info and diag (the latter is not exported) to get more information about them.","category":"page"},{"location":"reference/diag/#Actor-Identification","page":"Diagnostics","title":"Actor Identification","text":"","category":"section"},{"location":"reference/diag/","page":"Diagnostics","title":"Diagnostics","text":"Actors can be identified by their task's address. On a common 64-bit machine this is a UInt64 number. To improve readability Actors shows this number encoded as a Proquint string (short form):","category":"page"},{"location":"reference/diag/","page":"Diagnostics","title":"Diagnostics","text":"julia> sv = supervisor()\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :supervisor)\n\njulia> info(sv)\nActor    supervisor\nBehavior Actors.Supervisor\nPid      1, Thread 2\nTask     @0x0000000120c16890\nIdent    x-d-fagad-kofib\n\njulia> Actors.diag(sv, :task)\nTask (runnable) @0x0000000120c16890\n\njulia> Actors.diag(sv, :tid)\n\"x-d-fagad-kofib\"\n\njulia> exit!(sv, :shutdown);\n┌ Warning: 2021-02-05T12:51:33.288 x-d-fagad-kofib: Exit: supervisor shutdown\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:30\n\njulia> using Proquint\n\njulia> quint2uint(\"x-d-fagad-kofib\")\n0x0000000120c16890","category":"page"},{"location":"reference/diag/#Status-Information","page":"Diagnostics","title":"Status Information","text":"","category":"section"},{"location":"reference/diag/","page":"Diagnostics","title":"Diagnostics","text":"For testing and diagnosis you can use diag to get status information from an actor. For example diag(x, :act) returns the actors' x status variable:","category":"page"},{"location":"reference/diag/","page":"Diagnostics","title":"Diagnostics","text":"julia> myact = spawn(threadid)\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> myact_state = Actors.diag(myact, :act)\nActors._ACT(:default, Base.Threads.threadid, nothing, nothing, Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default), nothing, nothing, nothing, nothing, Actors.Connection[])","category":"page"},{"location":"reference/diag/","page":"Diagnostics","title":"Diagnostics","text":"But since an actors' state is private, this should be used for diagnostic purposes only.","category":"page"},{"location":"api/checkpointing/#Checkpointing","page":"Checkpointing","title":"Checkpointing","text":"","category":"section"},{"location":"api/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"CurrentModule = Actors","category":"page"},{"location":"api/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"A checkpointing actor can take user-defined checkpoints from current computations and restore them on demand.","category":"page"},{"location":"api/checkpointing/","page":"Checkpointing","title":"Checkpointing","text":"checkpointing\ncheckpoint\nrestore\nregister_checkpoint\n@chkey\nset_interval\nget_interval\nstart_checkpointing\nstop_checkpointing\nget_checkpoints\nsave_checkpoints\nload_checkpoints","category":"page"},{"location":"api/checkpointing/#Actors.checkpointing","page":"Checkpointing","title":"Actors.checkpointing","text":"checkpointing(level=1, filename::AbstractString=\"\"; kwargs...)\n\nStart a checkpointing actor and return a Link to it.\n\nArguments\n\nfilename::AbstractString: filename where the actor should save its   checkpointing buffer,\non::Bool=false: should checkpoints automatically be updated and saved, \nupdate::Int=10: update interval in seconds ≥ 1,\nsave::Int=60: saving interval in seconds ≥ 1,\nkwargs...: keyword arguments to spawn.\n\nnote: Note\nUpdating or saving is only done automatically if their intervals are ≥ 1 seconds.\n\n\n\n\n\n","category":"function"},{"location":"api/checkpointing/#Actors.checkpoint","page":"Checkpointing","title":"Actors.checkpoint","text":"checkpoint(cp::Link, key::Symbol, args...)\n\nTell a checkpointing actor to take a checkpoint.\n\nArguments\n\ncp::Link: Link to the checkpointing actor,\nkey::Symbol: key for the checkpoint,\nargs...: variables to save in the checkpoint,\nlevel::Int=1: checkpoint level.\n\n\n\n\n\n","category":"function"},{"location":"api/checkpointing/#Actors.restore","page":"Checkpointing","title":"Actors.restore","text":"restore(cp::Link; key::Symbol)\n\nTell a checkpointing actor to restore the last taken checkpoint.\n\nArguments\n\ncp::Link:  Link to the checkpointing actor,\nkey::Symbol: checkpoint key,\nlevel::Int=1: checkpoint level to restore from.\n\n\n\n\n\n","category":"function"},{"location":"api/checkpointing/#Actors.register_checkpoint","page":"Checkpointing","title":"Actors.register_checkpoint","text":"Register a checkpointing actor to a higher level actor.\n\n\n\n\n\n","category":"function"},{"location":"api/checkpointing/#Actors.@chkey","page":"Checkpointing","title":"Actors.@chkey","text":"@chkey a b c 123\n\nBuild a checkpointing key from the surrounding module and function names and the given arguments. This is intended for easy construction of checkpointing keys.\n\nExample\n\nmodule MyModule\n\nusing Actors\n\nfunction mykey()\n    a = 1\n    b = 2\n    c = 3\n    # do something\n    return @chkey a b c 123\nend\n\nexport mykey\nend # MyModule\n\njulia> using .MyModule\n\njulia> mykey()\n:MyModule_mykey_a_b_c_123\n\n\n\n\n\n","category":"macro"},{"location":"api/checkpointing/#Actors.set_interval","page":"Checkpointing","title":"Actors.set_interval","text":"set_interval(cp::Link; kwargs...)\n\nSet the checkpointing intervals of a checkpointing actor cp.\n\nArguments\n\ncp::Link: Link to a checkpointing actor,\nkwargs...: allowed keyword arguments:\non:Bool: should checkpoints automatically be updated and saved,\nupdate::Int: update interval in seconds ≥ 1,\nsave::Int: saving interval in seconds ≥ 1.\n\n\n\n\n\n","category":"function"},{"location":"api/checkpointing/#Actors.get_interval","page":"Checkpointing","title":"Actors.get_interval","text":"Get the checkpointing intervals of a checkpointing actor.\n\n\n\n\n\n","category":"function"},{"location":"api/checkpointing/#Actors.start_checkpointing","page":"Checkpointing","title":"Actors.start_checkpointing","text":"Start periodic checkpointing.\n\n\n\n\n\n","category":"function"},{"location":"api/checkpointing/#Actors.stop_checkpointing","page":"Checkpointing","title":"Actors.stop_checkpointing","text":"Stop periodic checkpointing.\n\n\n\n\n\n","category":"function"},{"location":"api/checkpointing/#Actors.get_checkpoints","page":"Checkpointing","title":"Actors.get_checkpoints","text":"Tell the checkpointing actor cp to return its stored checkpoint data.\n\n\n\n\n\n","category":"function"},{"location":"api/checkpointing/#Actors.save_checkpoints","page":"Checkpointing","title":"Actors.save_checkpoints","text":"Tell a checkpointing actor cp to save its stored checkpoint data.\n\n\n\n\n\n","category":"function"},{"location":"api/checkpointing/#Actors.load_checkpoints","page":"Checkpointing","title":"Actors.load_checkpoints","text":"Tell a checkpointing actor cp to load checkpointing data from a file\n\n\n\n\n\n","category":"function"},{"location":"manual/fault_tolerance/#Fault-Tolerance","page":"Fault Tolerance","title":"Fault Tolerance","text":"","category":"section"},{"location":"manual/fault_tolerance/","page":"Fault Tolerance","title":"Fault Tolerance","text":"To use the above mechanisms for fault-tolerance successfully, supervisors, monitors or :sticky actors must have behaviors which are unlikely to fail. Therefore actors with complicated and error-prone behaviors should not be made monitors or :sticky.","category":"page"},{"location":"manual/fault_tolerance/","page":"Fault Tolerance","title":"Fault Tolerance","text":"Connections, monitors, supervisors and checkpoints represent quite different protocols. When do you use which?","category":"page"},{"location":"manual/fault_tolerance/","page":"Fault Tolerance","title":"Fault Tolerance","text":"If you want a failure in one actor to terminate others, then use connect.\nIf instead you need to know or take action when some other actor or task exits for any reason, choose a monitor.\nIf you want to restart actors or tasks on failure, use supervisors.\nUse checkpointing if you need to take checkpoints and to start or restart actors or tasks from previously taken ones.","category":"page"},{"location":"manual/fault_tolerance/","page":"Fault Tolerance","title":"Fault Tolerance","text":"The approaches can be combined to realize arbitrary hierarchies or structures of connected, monitored, supervised and checkpointed actors. This will be facilitated by actor framework libraries like Supervisors.jl and Checkpointing.jl.","category":"page"},{"location":"tutorial/tabletennis/#table-tennis","page":"Simulate a Game","title":"Simulate a Game","text":"","category":"section"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"Now we implement a small toy example for concurrency with three actors using only some classic actor primitives:","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"Primitive Brief description\nspawn create an actor from a behavior and return a link,\nself get the link of the current actor,\nsend send a message to an actor.","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"We simulate table-tennis where a player has a name and a capability. If he gets a ball with a difficulty exceeding his capability, he looses it. Players log to a print server actor.","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"using Actors, Printf, Random\nimport Actors: spawn\n\nstruct Player{S,T}\n    name::S  # player's name \n    capa::T  # capabiity\nend\n\nstruct Ball{T,S,L}\n    diff::T  # difficulty\n    name::S  # the server's name\n    from::L  # the server's link\nend\n\nstruct Serve{L}\n    to::L    # the opponent's link\nend","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"We implement Player as a function object which gets the prn print server link as additional acquaintance and knows two message types: Ball and Serve.","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"function (p::Player)(prn, b::Ball)\n    if p.capa ≥ b.diff\n        send(b.from, Ball(rand(), p.name, self()))\n        send(prn, p.name*\" serves \"*b.name)\n    else\n        send(prn, p.name*\" looses ball from \"*b.name)\n    end\nend\nfunction (p::Player)(prn, s::Serve)\n    send(s.to, Ball(rand(), p.name, self()))\n    send(prn, p.name*\" serves \")\nend","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"In order to get reproducible results we initialize our random generator on each thread and assign threads to  players.","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"The print server prn gets an anonymous function as behavior. The two players ping and pong get the print server's link as acquaintance and - for illustration - are started on different threads. We start the game by sending ping a Serve message with the address of pong.","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"@threads for i in 1:nthreads()\n    Random.seed!(2021+threadid())\nend\n\nprn = spawn(s->print(@sprintf(\"%s\\n\", s))) \nping = spawn(Player(\"Ping\", 0.8), prn, thrd=3)\npong = spawn(Player(\"Pong\", 0.75), prn, thrd=4)\n\nsend(ping, Serve(pong))","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"To execute the program we include the file:","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"julia> include(\"examples/pingpong.jl\");\n\nPing serves \nPong serves Ping\nPing serves Pong\nPong serves Ping\nPing serves Pong\nPong looses ball from Ping","category":"page"},{"location":"tutorial/tabletennis/","page":"Simulate a Game","title":"Simulate a Game","text":"Actors are great for simulation.","category":"page"},{"location":"reference/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"CurrentModule = Actors","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Actors have internal data structures controlling their behavior:","category":"page"},{"location":"reference/internals/#Actor-State","page":"Internals","title":"Actor State","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"_ACT\nInfo","category":"page"},{"location":"reference/internals/#Actors._ACT","page":"Internals","title":"Actors._ACT","text":"_ACT\n\nInternal actor status variable.\n\nFields\n\nmode::Symbol: the actor mode,\nbhv::Any:  behavior - a callable object,\ninit::Any: initialization - a callable object, \nterm::Any: termination - a callable object,\nself::Link: the actor's address,\nname::Union{Nothing,Symbol}: the actor's registered name.\nres::Any: the result of the last behavior execution,\nsta::Any: a variable for representing state,\nusr::Any: user variable for plugging in something,\nconn::Array{Connection,1}: connected actors.\n\nsee also: Bhv, Link\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Actors.Info","page":"Internals","title":"Actors.Info","text":"Actor information\n\nmode::Symbol: actor mode,\nbhvf::Any: behavior function,\npid::Int: process identifier,\nthrd::Int: thread,\ntask::Task: actor task address,\ntid::String: proquint identifier based on task address,\nname::Union{Nothing,Symbol}: name under which the actor is   registered, nothing if not registered.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Actor-Mode","page":"Internals","title":"Actor Mode","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"More complex actor behaviors can be realized by changing their mode. Actors uses the following modes:","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"mode brief description\n:default the default actor mode.\n:sticky sticky actors do not exit if they get an Exit signal from a connected actor.\n:system behave as :sticky actors, but are  internal actors _REF and _ROOT.\n:supervisor reserved for actors with supervisor behavior.","category":"page"},{"location":"reference/internals/#Connections","page":"Internals","title":"Connections","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"The error handling between actors is realized by connections between them","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Connection\nPeer\nMonitor\nMonitored\nSuper\nChild","category":"page"},{"location":"reference/internals/#Actors.Connection","page":"Internals","title":"Actors.Connection","text":"Abstract type for connections between actors.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Actors.Peer","page":"Internals","title":"Actors.Peer","text":"Connection to a peer actor\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Actors.Monitor","page":"Internals","title":"Actors.Monitor","text":"Connection to a monitor\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Actors.Monitored","page":"Internals","title":"Actors.Monitored","text":"Connection to a monitored actor or task\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Actors.Super","page":"Internals","title":"Actors.Super","text":"Connection to a supervisor.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Actors.Child","page":"Internals","title":"Actors.Child","text":"Child{L,T}(lk::L, start, info::T)\n\nConnection to a supervised actor or task.\n\nFields\n\nlk::L: Link or Task,\nstart::Any: callable object for restarting it,\ninit::Any: callable object for initialization (this is used   for remote actors),\nname::Union{Nothing,Symbol}: registered actor name, nothing    if not registered,\ninfo::T: named tuple with information about restart   strategies, timeout, pollint ...\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Supervision","page":"Internals","title":"Supervision","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"A supervisor actor has a function object as behavior:","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Supervisor","category":"page"},{"location":"reference/internals/#Actors.Supervisor","page":"Internals","title":"Actors.Supervisor","text":"Supervisor(; strategy=:one_for_one, max_restarts=3, max_seconds=5, kwargs...)\n\nSupervisor functor with data and behavior.\n\nFields (acquaintances)\n\noption::Dict{Symbol,Any}: supervisor option\nchilds::Array{Child,1}: supervised childs,\nrtime::Array{Float64,1}: last restart times.\n\nOptions\n\nstrategy::Symbol: supervision strategy, can be    either :one_for_one, :one_for_all or :rest_for_one.\nmax_restarts::Int: maximum number of restarts allowed in a time frame,\nmax_seconds::Float64: time frame in which max_restarts applies, defaults to 5,\nkwargs...: further option to extend supervisor behavior.\n\n\n\n\n\n","category":"type"},{"location":"manual/supervisors/#Supervisors","page":"Supervisors","title":"Supervisors","text":"","category":"section"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"CurrentModule = Actors","category":"page"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"Our system now looks similar to the following:","category":"page"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"(Image: supervisor)","category":"page"},{"location":"manual/supervisors/#Actor-State-Across-Restarts","page":"Supervisors","title":"Actor State Across Restarts","text":"","category":"section"},{"location":"manual/supervisors/#Termination-and-Restart-Callbacks","page":"Supervisors","title":"Termination and Restart Callbacks","text":"","category":"section"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"There are cases where you want a different user-defined fallback strategy for actor restart, for example to","category":"page"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"restart it with a different algorithm/behavior or data set or\ndo some cleanup before restarting it,\nrestart after a node failure,\nsave and restore a checkpoint.","category":"page"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"For that you can define callback functions invoked at actor termination, restart or initialization:","category":"page"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"callback short description\nterm! term callback; if defined, it is called at actor exit with argument reason (exit reason),\nrestart a given cb argument to supervise, start_actor or start_task is executed by a supervisor to restart an actor/task;\ninit! if defined (and no restart callback is given), the supervisor restarts an actor with the given init behavior.","category":"page"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"User defined callbacks must follow some conventions:","category":"page"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"A restart callback does some initialization and spawns an actor or a task and returns a Link or a Task which  again will be supervised.\nAn init callback is a startup behavior of an actor. It does some initialization or recovery and then switches (with become) to the target behavior. A supervisor spawns a new supervised actor with the given init behavior and triggers it with init().\nA supervisor wants an actor running on a worker process (over a RemoteChannel) to restart on the same or on a spare pid (process id). In that case it calls the restart callback with a pid keyword argument (and the callback must take it).","category":"page"},{"location":"manual/supervisors/#Preserving-actor-links-after-restart","page":"Supervisors","title":"Preserving actor links after restart","text":"","category":"section"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"After restarting an actor, a supervisor updates its link to point to the newly created actor. But other copies of a link won't get updated and may then be out of sync.","category":"page"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"If remote actors on other workers communicate with an actor over RemoteChannels, they have copies of its link on their workers. After actor restart those are out of sync, and a remote actor may try to communicate with an old failed actor. To avoid this situation, you should register those actors and use their registered names to supervise them and communicate with them. The supervisor then will update the registered link.","category":"page"},{"location":"manual/supervisors/#Task-Supervision","page":"Supervisors","title":"Task Supervision","text":"","category":"section"},{"location":"manual/supervisors/#Supervisory-trees","page":"Supervisors","title":"Supervisory trees","text":"","category":"section"},{"location":"manual/supervisors/","page":"Supervisors","title":"Supervisors","text":"For larger applications you may be interested in building a hierarchical structure containing all actors and tasks. This is called a supervisory tree, and there is the Supervisors package facilitating to build that.","category":"page"},{"location":"api/comm/#Communication-primitives","page":"Communication primitives","title":"Communication primitives","text":"","category":"section"},{"location":"api/comm/","page":"Communication primitives","title":"Communication primitives","text":"To receive a reply from an actor there are two possibilities:","category":"page"},{"location":"api/comm/","page":"Communication primitives","title":"Communication primitives","text":"asynchronous bidirectional communication and\nsynchronous bidirectional communication.","category":"page"},{"location":"api/comm/","page":"Communication primitives","title":"Communication primitives","text":"API function brief description\nreceive after a send receive the response asynchronously\nrequest send (implicitly) a message to an actor, block and receive the response synchronously","category":"page"},{"location":"api/comm/#Functions","page":"Communication primitives","title":"Functions","text":"","category":"section"},{"location":"api/comm/","page":"Communication primitives","title":"Communication primitives","text":"receive\nrequest","category":"page"},{"location":"api/comm/#Actors.receive","page":"Communication primitives","title":"Actors.receive","text":"receive(lk; timeout=5.0)\nreceive(lk, from; timeout=5.0)\nreceive(lk, M; timeout=5.0)\nreceive(lk, M, from; timeout=5.0)\n\nReceive a message over a link lk.\n\nIf M or from are provided, receive returns only a  matching message. Other messages in lk are restored to it in their previous order.\n\nParameters\n\nlk::Link: local or remote link over which the message is received,\nM::Type{<:Msg}: Msg type,\nfrom::Link: local or remote link of sender. If from is   provided, only messages with a from field can be matched.\ntimeout::Real=5.0: maximum waiting time in seconds.\nIf timeout==0, lk is scanned only for existing messages.\nSet timeout=Inf if you don't want to timeout. \n\nReturns\n\nreceived message or Timeout().\n\n\n\n\n\n","category":"function"},{"location":"api/comm/#Actors.request","page":"Communication primitives","title":"Actors.request","text":"request(lk::Link, msg::Msg; full=false, timeout::Real=5.0)\nrequest(lk::Link, M::Type{<:Msg}, args...; kwargs...)\n\nSend a message to an actor, block, receive and return the result.\n\nArguments\n\nlk::Link: actor link, or name::Symbol (if registered),\nmsg::Msg: a message,\nMsg::Type{<:Msg}: a message type,\nargs...: optional arguments to Msg, \nfull: if true return the full Response message.\ntimeout::Real=5.0: timeout in seconds after which a    Timeout is returned,\nkwargs...: full or timeout.\n\n\n\n\n\n","category":"function"},{"location":"manual/node_failures/#Node-Failures","page":"Node Failures","title":"Node Failures","text":"","category":"section"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"CurrentModule = Actors","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"In distributed computing node failures can occur. The occurrence of a single node failure is not very likely but node failures can be a problem for long running applications executed on many nodes.","category":"page"},{"location":"manual/node_failures/#Remote-failure-detection","page":"Node Failures","title":"Remote failure detection","text":"","category":"section"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"If an actor with a remote link is put under supervision (under a supervisor running on another worker), the supervisor starts a special child actor (RNFD: remote note failure detection) checking remote links periodically for node failures.","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"If it detects a ProcessExitedException on a supervised RemoteChannel, it sends a NodeFailure signal to the supervisor. The supervisor then handles it as if an actor failure had occurred.","category":"page"},{"location":"manual/node_failures/#Actor-restart-on-spare-nodes","page":"Node Failures","title":"Actor restart on spare nodes","text":"","category":"section"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"Generally a supervisor restarts a failed remote (:transient or :permanent) child actor on the same pid (process id) where it ran before failure. But in case of a worker failure the actors that ran on it are restarted on a spare process. The supervisor determines the spare processes as follows:","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"A supervisor can be started with a spares option like spares = [5,6,7], with given spare pids. For actor restarts after node failures the supervisor chooses first those processes and removes them from the spares list.\nIf there are no spare nodes (left), the supervisor restarts actors on the highest free pid available (that is not used by its child actors).\nIf there is no free pid, the supervisor restarts on a randomly chosen available worker.","category":"page"},{"location":"manual/node_failures/#Example","page":"Node Failures","title":"Example","text":"","category":"section"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"We setup six actors A1-A6 distributed over pids 2-4 and put them under supervision of A10 on pid 1 with two spare workers (pids 5, 6). A10 starts a RFND actor to check the supervised RemoteChannels each second for node failures.","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"julia> using Actors, Distributed\n\njulia> addprocs(5);\n\njulia> @everywhere using Actors\n\njulia> sv = supervisor(name=:A10, spares=[5,6])\nLink{Channel{Any}}(Channel{Any}(32), 1, :supervisor)\n\njulia> for i in 1:6\n           register(Symbol(\"A$i\"), Actors.spawn(+, i*10, pid=(2,2,3,3,4,4)[i]))\n           supervise(:A10, Symbol(\"A$i\"))\n       end\n\njulia> count_children(:A10)\n(all = 7, default = 6, rnfd = 1)\n\njulia> which_children(:A10, true)\n7-element Vector{NamedTuple{(:actor, :bhv, :pid, :thrd, :task, :id, :name, :restart), T} where T<:Tuple}:\n (actor = :default, bhv = +, pid = 2, thrd = 1, task = 0x0000000119a65000, id = \"x-d-dokok-jabab\", name = :A1, restart = :transient)\n (actor = :rnfd, bhv = Actors.RNFD{Link{Channel{Any}}, Vector{Link}, Vector{Int64}}, pid = 1, thrd = 1, task = 0x0000000107cbdee0, id = \"x-d-izar-turob\", name = nothing, restart = :transient)\n (actor = :default, bhv = +, pid = 2, thrd = 1, task = 0x000000011798d990, id = \"x-d-divim-tokib\", name = :A2, restart = :transient)\n (actor = :default, bhv = +, pid = 3, thrd = 1, task = 0x00000001689f5bb0, id = \"x-d-kofiz-jovub\", name = :A3, restart = :transient)\n (actor = :default, bhv = +, pid = 3, thrd = 1, task = 0x0000000116122ed0, id = \"x-d-dimif-furib\", name = :A4, restart = :transient)\n (actor = :default, bhv = +, pid = 4, thrd = 1, task = 0x00000001705e9dd0, id = \"x-d-ladiv-nulib\", name = :A5, restart = :transient)\n (actor = :default, bhv = +, pid = 4, thrd = 1, task = 0x000000011fb7aed0, id = \"x-d-duvul-purib\", name = :A6, restart = :transient)\n\njulia> info(:A3)\nActor    default\nBehavior +\nPid      3, Thread 1\nTask     @0x00000001689f5bb0\nIdent    x-d-kofiz-jovub\nName     A3","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"We registered our remote actors under names :A1…:A6, which keeps them accessible to each other after restart. Our system now looks similar to the following:","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"(Image: supervisor rfd 1)","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"If the worker process with pid 3 fails, the supervisor restarts  actors A3 and A4 on the first spare worker process (pid 5):","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"julia> rmprocs(3);\n┌ Warning: 2021-04-06 17:26:55 A10 supervisor: Process 3 exited!\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n┌ Warning: 2021-04-06 17:26:55 A10 supervisor: restarting child A3 on pid 5\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n┌ Warning: 2021-04-06 17:26:55 A10 supervisor: restarting child A4 on pid 5\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n\njulia> info(:A3)\nActor    default\nBehavior +\nPid      5, Thread 1\nTask     @0x000000011c576ed0\nIdent    x-d-dudil-kurib\nName     A3","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"With other supervision strategies (:one_for_all or :rest_for_one) the supervisor would have shutdown other child actors as well (A1,A2,A5,A6 or A5,A6 respectively) and restarted them on their same pids. The system after actor restart looks as follows:","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"(Image: supervisor rfd 2)","category":"page"},{"location":"manual/node_failures/","page":"Node Failures","title":"Node Failures","text":"pid 3 is gone and the supervisor has one spare worker (pid 6) left.","category":"page"},{"location":"api/connect/#Connections","page":"Connections","title":"Connections","text":"","category":"section"},{"location":"api/connect/","page":"Connections","title":"Connections","text":"CurrentModule = Actors","category":"page"},{"location":"api/connect/","page":"Connections","title":"Connections","text":"Connected actors send each other Exit signals and terminate together unless they are made :sticky with trapExit:","category":"page"},{"location":"api/connect/","page":"Connections","title":"Connections","text":"connect\ndisconnect\ntrapExit","category":"page"},{"location":"api/connect/#Actors.connect","page":"Connections","title":"Actors.connect","text":"connect(lk::Link)\n\nCreate a connection between the calling actor and  the actor represented by lk. \n\nConnected actors will send each other Exit  signals. A connected actor will exit with the signaled reason  unless it is :normal.\n\nNote:\n\nAn actor can be made :sticky with trapExit and then will not exit.\nIf this is called from the Main scope, lk is \n\nconnected to the Actors._ROOT actor.\n\n\n\n\n\n","category":"function"},{"location":"api/connect/#Actors.disconnect","page":"Connections","title":"Actors.disconnect","text":"disconnect(lk::Link)\n\nRemove the connection between the calling actor and the actor represented by lk.\n\nNote: If this is called from the Main scope, lk  is disconnected from the _ROOT actor.\n\n\n\n\n\n","category":"function"},{"location":"api/connect/#Actors.trapExit","page":"Connections","title":"Actors.trapExit","text":"trapExit(lk::Link=self(), mode=:sticky)\n\nChange the mode of an actor.\n\nA :sticky actor does not exit if it receives an Exit  signal from a connected actor and does not propagate it further.  Instead it reports the failure and saves a link to the failed actor. \n\nSee diag for getting links to failed actors  from a :sticky actor.\n\n\n\n\n\n","category":"function"},{"location":"manual/checkpoints/#Checkpointing","page":"Checkpointing","title":"Checkpointing","text":"","category":"section"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"CurrentModule = Actors","category":"page"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"Actors provides a simple mechanism for taking user-defined checkpoints/copies of variables and restoring them on demand. This can be used together with actor and task supervision to restart failed computations from a previously saved state.","category":"page"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"Why do we need checkpointing in addition to supervision? If for example a computing node fails, a supervisor does not receive an error message with the last state of a failed actor. It must be able to restart an actor on another node with a state saved somewhere else.","category":"page"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"note: This is experimental and in active development!\nWe conceive actor-based checkpointing as sending copies of variables over a link (a Channel) to a checkpointing actor. There is no stopping of an actor/task/process/application from the outer system or taking copies of an actors' (shared) state. The user must checkpoint critical variables regularly and restore them within init! and restart callbacks (described in supervision). This enables computations to recover from node failures. We must develop appropriate patterns for using this kind of checkpointing.","category":"page"},{"location":"manual/checkpoints/#Multi-level-Checkpointing","page":"Checkpointing","title":"Multi-level Checkpointing","text":"","category":"section"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"Checkpointing actors can be grouped into a hierarchy of several levels. This allows their subordinated actors or tasks to be restarted from a common state. This is similar a kind of multi-level checkpointing:","category":"page"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"Multi-level checkpointing ... uses multiple types of checkpoints that have different levels of resiliency and cost in a single application run. The slowest but most resilient level writes to the parallel file system, which can withstand a failure of an entire machine. Faster but less resilient checkpoint levels utilize node-local storage, such as RAM, Flash or disk, and apply cross-node redundancy schemes. [1]","category":"page"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"All checkpointing actors have a Dict (in-memory) for checkpoints, which they can save to a file and reload. They are isolated from one another and their location (e.g. a worker pid) can be chosen according to redundancy and efficiency considerations.","category":"page"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"A hierarchy of checkpointing actors may look like the following:","category":"page"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"(Image: checkpointing)","category":"page"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"C1 .. C3 take level 1 checkpoints from connected worker actors A1 .. A17. C4 is at level 2 and updates regularly its dictionary from checkpoints of actors A1 .. A10. C5 updates regularly from C3 and C4. Depending on the failure and the supervisory strategy the system can recover from checkpoints on various levels. Maybe C5 saves its checkpoints to disk. Thus the whole system could be restarted from that.","category":"page"},{"location":"manual/checkpoints/#Level-One","page":"Checkpointing","title":"Level One","text":"","category":"section"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"A checkpointing actor at level=1 operates as server for worker actors or tasks. On checkpoint it stores values from current computations under a key and can restore them on demand. It usually resides on the same node as its clients and can take frequent and inexpensive checkpoints.","category":"page"},{"location":"manual/checkpoints/#Higher-levels","page":"Checkpointing","title":"Higher levels","text":"","category":"section"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"Checkpointing actors at levels > 1 aggregate and save checkpoints from actors below them periodically or at demand. They usually reside on other nodes and save checkpoints to a file system. If desired, the highest level actor can save and serve the checkpoints of an entire distributed application.","category":"page"},{"location":"manual/checkpoints/#Checkpointing-API","page":"Checkpointing","title":"Checkpointing API","text":"","category":"section"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"API function brief description\ncheckpointing start a checkpointing actor,\ncheckpoint tell it to take a checkpoint,\nrestore tell it to restore the last checkpoint,\nregister_checkpoint register it to another higher level one,\n@chkey build a checkpointing key,\nset_interval set the checkpointing periods,\nget_interval get the checkpointing periods,\nstart_checkpointing start periodic checkpointing,\nstop_checkpointing stop the periodic checkpointing,\nget_checkpoints get (a Dict of) all checkpoints,\nsave_checkpoints tell it to save the checkpoints to a file,\nload_checkpoints tell it to load them from a file.","category":"page"},{"location":"manual/checkpoints/","page":"Checkpointing","title":"Checkpointing","text":"[1]: Adam Moody, Greg Bronevetsky, Kathryn Mohror, Bronis R. de Supinski, Design, Modeling, and Evaluation of a Scalable Multi-level Checkpointing System, LLNL-CONF-427742, Supercomputing 2010, New Orleans, LA, November 2010.","category":"page"},{"location":"api/user_api/#User-API","page":"User API","title":"User API","text":"","category":"section"},{"location":"api/user_api/","page":"User API","title":"User API","text":"CurrentModule = Actors","category":"page"},{"location":"api/user_api/","page":"User API","title":"User API","text":"The user API allows you to communicate with actors using the Actors protocol:","category":"page"},{"location":"api/user_api/#Bidirectional-Communication","page":"User API","title":"Bidirectional Communication","text":"","category":"section"},{"location":"api/user_api/","page":"User API","title":"User API","text":"The following functions send a message to an actor causing it to respond:","category":"page"},{"location":"api/user_api/","page":"User API","title":"User API","text":"API function brief description\ncall tell an actor to execute its behavior function and to send the result\nexec tell an actor to execute a function and to send the result\nquery tell an actor's to send one of its internal state variables","category":"page"},{"location":"api/user_api/","page":"User API","title":"User API","text":"Those functions support both asynchronous and synchronous communication.","category":"page"},{"location":"api/user_api/#Actor-Control-(Unidirectional)","page":"User API","title":"Actor Control (Unidirectional)","text":"","category":"section"},{"location":"api/user_api/","page":"User API","title":"User API","text":"Actors can be controlled with the following functions:","category":"page"},{"location":"api/user_api/","page":"User API","title":"User API","text":"API function brief description\nbecome! cause an actor to switch its behavior\ncast cause an actor to execute its behavior function\nexit! cause an actor to terminate\ninit! tell an actor to execute a function at startup\nterm! tell an actor to execute a function when it terminates\nupdate! update an actor's internal state","category":"page"},{"location":"api/user_api/","page":"User API","title":"User API","text":"Actors can also operate on themselves, or rather they send themselves messages:","category":"page"},{"location":"api/user_api/","page":"User API","title":"User API","text":"API function brief description\nbecome an actor switches its own behavior\nstop an actor stops","category":"page"},{"location":"api/user_api/#Functions","page":"User API","title":"Functions","text":"","category":"section"},{"location":"api/user_api/","page":"User API","title":"User API","text":"call\ncast\nexec\nexit!\ninfo\ninit!\nquery\nterm!\nupdate!","category":"page"},{"location":"api/user_api/#Actors.call","page":"User API","title":"Actors.call","text":"call(lk::Link, [from::Link,] args2...; timeout::Real=5.0)\ncall(name::Symbol, ....)\n\nCall an actor to execute its behavior and to send a  Response with the result. \n\nArguments\n\nactor lk::Link (or name::Symbol if registered), \nfrom::Link: sender link, \nargs2...: remaining arguments to the actor.\ntimeout::Real=5.0: timeout in seconds.\n\nNote: If from is omitted, call blocks and returns the result\n\n\n\n\n\n","category":"function"},{"location":"api/user_api/#Actors.cast","page":"User API","title":"Actors.cast","text":"cast(lk::Link, args2...)\ncast(name::Symbol, args2...)\n\nCast args2... to the actor lk (or name if registered)  to execute its behavior with args2... without sending a  response. \n\nNote: you can prompt the returned value with query.\n\n\n\n\n\n","category":"function"},{"location":"api/user_api/#Actors.exec","page":"User API","title":"Actors.exec","text":"exec(lk::Link, from::Link, f, args...; kwargs...)\nexec(lk::Link, f, args...; timeout::Real=5.0, kwargs...)\nexec(name::Symbol, ....)\n\nAsk an actor lk (or name if registered) to execute an  arbitrary function and to send the returned value as  Response.\n\nArguments\n\nactor lk::Link or name::Symbol if registered,\nfrom::Link: the link a Response should be sent to.\nf: a callable object,\nargs...; kwargs...: arguments and keyword arguments to it,\ntimeout::Real=5.0: timeout in seconds. Set timeout=Inf    if you don't want to timeout.\n\nNote: If from is ommitted, exec blocks, waits and  returns the result (with a timeout).\n\n\n\n\n\n","category":"function"},{"location":"api/user_api/#Actors.exit!","page":"User API","title":"Actors.exit!","text":"exit!(lk::Link, reason=:normal)\nexit!(name::Symbol, ....)\n\nTell an actor lk (or name if registered) to stop. If it  has a term function, it calls that with  reason as last argument. \n\n\n\n\n\n","category":"function"},{"location":"api/user_api/#Actors.info","page":"User API","title":"Actors.info","text":"info(lk::Link)\n\nReturn the state of an actor associated with lk:\n\nActors.Info if it is runnable,\n:done if it has finished,\nelse return the failed task. \n\n\n\n\n\n","category":"function"},{"location":"api/user_api/#Actors.init!","page":"User API","title":"Actors.init!","text":"init!(lk::Link, f, args...; kwargs...)\ninit!(name::Symbol, ....)\n\nTell an actor lk to save the callable object f with the given  arguments as an init object in its _ACT variable.  The init object will be called by a supervisor at actor restart.\n\nArguments\n\nactor lk::Link or name::Symbol if registered, \nf: callable object,\nargs...: arguments to f,\nkwargs...: keyword arguments to f.\n\n\n\n\n\n","category":"function"},{"location":"api/user_api/#Actors.query","page":"User API","title":"Actors.query","text":"query(lk::Link, [from::Link,] s::Symbol; timeout::Real=5.0)\nquery(name::Symbol, ....)\n\nQuery an actor about an internal state variable s. \n\nParameters\n\nactor lk::Link or name::Symbol if registered,\nfrom::Link: sender link,\ns::Symbol one of :mode,:bhv,:res,:sta,:usr.\ntimeout::Real=5.0: \n\nNote: If from is omitted, query blocks and returns  the response. In that case there is a timeout.\n\nExamples\n\njulia> f(x, y; u=0, v=0) = x+y+u+v  # implement a behavior\nf (generic function with 1 method)\n\njulia> fact = spawn(Bhv(f, 1))     # start an actor with it\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> query(fact, :mode)           # query the mode\n:default\n\njulia> cast(fact, 1)                # cast a 2nd argument to it\nActors.Cast((1,))\n\njulia> query(fact, :res)            # query the result\n2\n\njulia> query(fact, :sta)            # query the state\n\njulia> query(fact, :bhv)            # query the behavior\nBhv(f, (1,), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), Actors.var\"#2#4\"{Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},typeof(f),Tuple{Int64}}(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), f, (1,)))\n\n\n\n\n\n","category":"function"},{"location":"api/user_api/#Actors.term!","page":"User API","title":"Actors.term!","text":"term!(lk::Link, f, args1...; kwargs...)\nterm!(name::Symbol, ....)\n\nTell an actor lk (or name::Symbol if registered) to  execute f with the given partial arguments and an exit reason when it terminates. \n\nThe exit reason is added by the actor to args1... when it  exits.\n\n\n\n\n\n","category":"function"},{"location":"api/user_api/#Actors.update!","page":"User API","title":"Actors.update!","text":"update!(lk::Link, x; s::Symbol=:sta)\nupdate!(lk::Link, arg::Args)\nupdate!(name::Symbol, ....)\n\nUpdate an actor's internal state s with args....\n\nArguments\n\nactor lk::Link or name::Symbol if registered,\nx: value/variable to update the choosen state with,\narg::Args: arguments to update,\ns::Symbol: one of :arg, :mode, :name, :self, :sta, :usr.\n\nNote: If you want to update the stored arguments to the  behavior function with s=:arg, you must pass an Args  to arg. If Args has keyword arguments, they are merged  with existing keyword arguments to the behavior function.\n\nExample\n\njulia> update!(fact, 5)       # update the state variable\nActors.Update(:sta, 5)\n\njulia> query(fact, :sta)      # query it\n5\n\njulia> update!(fact, Args(0, u=5, v=5));  # update arguments to the behavior \n\njulia> call(fact, 0)          # call the actor with 0\n10\n\n\n\n\n\n","category":"function"},{"location":"api/user_api/#Types","page":"User API","title":"Types","text":"","category":"section"},{"location":"api/user_api/","page":"User API","title":"User API","text":"The following is needed for updating arguments:","category":"page"},{"location":"api/user_api/","page":"User API","title":"User API","text":"Args","category":"page"},{"location":"api/user_api/#Actors.Args","page":"User API","title":"Actors.Args","text":"Args(args...; kwargs...)\n\nA structure for updating arguments to an actor's behavior.\n\n\n\n\n\n","category":"type"},{"location":"manual/basics/#Actor-Model","page":"Actor Model","title":"Actor Model","text":"","category":"section"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"CurrentModule = Actors","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"The Actor Model was originally proposed by Carl Hewitt et. al. in the 70es and since then has evolved into different families [1]. ","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"We focus here on the classical Actor Model described by Gul Agha in Actors [2]. This sees an actor as the universal primitive of concurrent computation:","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"An actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [3]","category":"page"},{"location":"manual/basics/#Actor-Characteristics","page":"Actor Model","title":"Actor Characteristics","text":"","category":"section"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"Actor systems and actors have the following basic characteristics[4] :","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"communication via direct asynchronous messaging,\nactors support finite state machines,\nactors do not share their mutable state,\nlock-free concurrency,\nactors support parallelism,\nactors tend to come in systems.","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"Modern actor implementations extend those by","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"location transparency: this enables actors of different kinds and on different systems to communicate,\nsupervision: actors form a dependency relationship where a parent actor supervises child/subordinate ones. This is used to implement fault tolerant systems.\nactor protocols: there are predefined actors  following a specific message protocol to implement complex behaviors e.g. as generic server, supervisor, router, publish-subscribe ...  ","category":"page"},{"location":"manual/basics/#Actor-Primitives","page":"Actor Model","title":"Actor Primitives","text":"","category":"section"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"The actor machinery is based on only a few basic primitives defined in ActorInterfaces.Classic:","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"Primitive Brief description\nAddr an address identifying an actor,\nself() get the address of the current actor,\nspawn(bhv) create an actor from a behavior and return an address,\nsend(addr, msg) send a message to an actor,\nbecome(bhv) an actor designates a new behavior,","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"A user can write actor programs using only those. His programs should run with minor modifications on other actor libraries supporting the same basic interface.","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"note: The interface needs yet work!\nAt the moment the Actors implementation of the interface in ActorInterfaces.Classic is not complete as it doesn't support context injection with @ctx.","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"[1]: De Koster, Van Cutsem, De Meuter 2016. 43 Years of Actors: A Taxonomy of Actor Models and Their Key Properties.","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"[2]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"[3]: See the Wikipedia entry on the Actor Model.","category":"page"},{"location":"manual/basics/","page":"Actor Model","title":"Actor Model","text":"[4]: Here I follow roughly: Vernon, Vaughn 2016. Reactive messaging patterns with the Actor model: applications and integration in Scala and Akka, Pearson","category":"page"},{"location":"manual/infrastructure/#More-Useful-Stuff","page":"More Useful Stuff","title":"More Useful Stuff","text":"","category":"section"},{"location":"manual/infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"CurrentModule = Actors","category":"page"},{"location":"manual/infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"Actors provides some more functionality going beyond the classical model.","category":"page"},{"location":"manual/infrastructure/#User-Defined-Messages","page":"More Useful Stuff","title":"User Defined Messages","text":"","category":"section"},{"location":"manual/infrastructure/","page":"More Useful Stuff","title":"More Useful Stuff","text":"Often you want to define your own message types. For  defining empty messages you can use the @msg macro.  ","category":"page"},{"location":"tutorial/dictsrv/#dict-server","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"","category":"section"},{"location":"tutorial/dictsrv/","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"This example implements a Dict-server actor that can be used in multi-threaded and distributed Julia code to avoid race conditions when tasks from multiple threads access a Dict concurrently:","category":"page"},{"location":"tutorial/dictsrv/","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"DictSrv simply is a functor containing a link to a server actor.\nDictSrv gets an indexing interface. It forwards the indexing functions getindex and setindex! to the server actor.\nThe server actor's behavior ds takes a Dict variable as acquaintance and executes the communicated functions f with args... on it. If called without arguments it returns a copy of its Dict variable.\ndictsrv creates then a DictSrv functor, which spawns a server actor around a given Dict.","category":"page"},{"location":"tutorial/dictsrv/","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"# examples/mydict.jl\n\nmodule MyDict\nusing Actors\nimport Actors: spawn\n\nstruct DictSrv{L}\n    lk::L\nend\n(ds::DictSrv)(f::Function, args...) = call(ds.lk, f, args...)\n(ds::DictSrv)() = call(ds.lk)\n\n# indexing interface\nBase.getindex(d::DictSrv, key) = call(d.lk, getindex, key)\nBase.setindex!(d::DictSrv, value, key) = call(d.lk, setindex!, value, key)\n\n# dict server behavior\nds(d::Dict, f::Function, args...) = f(d, args...)\nds(d::Dict) = copy(d)\n\n# start dict server\ndictsrv(d::Dict; remote=false) = DictSrv(spawn(ds, d; remote))\n\nexport DictSrv, dictsrv \n\nend","category":"page"},{"location":"tutorial/dictsrv/","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"A DictSrv instance is created with dictsrv. It can be accessed like a Dict, but any access to its interface involves a communication. It shares its data by communicating. Let's try it out:","category":"page"},{"location":"tutorial/dictsrv/","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"julia> include(\"examples/mydict.jl\")\nMain.MyDict\n\njulia> using .MyDict, .Threads\n\njulia> nthreads()\n8\n\njulia> d = dictsrv(Dict{Int,Int}())\nDictSrv{Link{Channel{Any}}}(Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default))\n\njulia> @threads for i in 1:1000\n           d[i] = threadid()  # write concurrently to the Dict\n       end\n\njulia> d()\nDict{Int64,Int64} with 1000 entries:\n  306 => 3\n  29  => 1\n  74  => 1\n  905 => 8\n  176 => 2\n  892 => 8\n  285 => 3\n  318 => 3\n  873 => 7\n  975 => 8\n  ⋮   => ⋮\n\njulia> d[892]\n8","category":"page"},{"location":"tutorial/dictsrv/","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"All available threads did concurrently fill our served dictionary with their thread ids. Actor access to the dictionary happens  behind the scenes.","category":"page"},{"location":"tutorial/dictsrv/","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"Now we try it out with distributed computing:","category":"page"},{"location":"tutorial/dictsrv/","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"julia> using Distributed\n\njulia> addprocs();\n\njulia> nworkers()\n17\n\njulia> @everywhere include(\"examples/mydict.jl\")\n\njulia> @everywhere using .MyDict\n\njulia> d = dictsrv(Dict{Int,Int}(), remote=true)\nDictSrv{Link{RemoteChannel{Channel{Any}}}}(Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 278), 1, :default))\n\njulia> @spawnat :any d[myid()] = rand(Int)\nFuture(4, 1, 279, nothing)\n\njulia> @spawnat 17 d[myid()] = rand(Int)\nFuture(17, 1, 283, nothing)\n\njulia> d()\nDict{Int64,Int64} with 2 entries:\n  4  => -4807958210447734689\n  17 => -8998327833489977098\n\njulia> fetch(@spawnat 10 d())\nDict{Int64,Int64} with 2 entries:\n  4  => -4807958210447734689\n  17 => -8998327833489977098","category":"page"},{"location":"tutorial/dictsrv/","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"The remote DictSrv actor is available on all workers.","category":"page"},{"location":"tutorial/dictsrv/","page":"Implement a thread-safe Dict","title":"Implement a thread-safe Dict","text":"This was just to show how Actors provides powerful abstractions to deal with concurrency.","category":"page"},{"location":"tutorial/install/#Install-and-Use-Actors","page":"Install and Use Actors","title":"Install and Use Actors","text":"","category":"section"},{"location":"tutorial/install/","page":"Install and Use Actors","title":"Install and Use Actors","text":"Actors requires at least Julia 1.6.","category":"page"},{"location":"tutorial/install/","page":"Install and Use Actors","title":"Install and Use Actors","text":"You enter pkg>-mode by typing ] in the Julia REPL. Then you can install the current stable, registered version with","category":"page"},{"location":"tutorial/install/","page":"Install and Use Actors","title":"Install and Use Actors","text":"pkg> add Actors","category":"page"},{"location":"tutorial/install/","page":"Install and Use Actors","title":"Install and Use Actors","text":"The development version is installed with:","category":"page"},{"location":"tutorial/install/","page":"Install and Use Actors","title":"Install and Use Actors","text":"pkg> add \"https://github.com/JuliaActors/Actors.jl\"","category":"page"},{"location":"tutorial/install/","page":"Install and Use Actors","title":"Install and Use Actors","text":"You can then use it for your work:","category":"page"},{"location":"tutorial/install/","page":"Install and Use Actors","title":"Install and Use Actors","text":"using Actors\nActors.version","category":"page"},{"location":"api/types/#Basic-Types","page":"Basic Types","title":"Basic Types","text":"","category":"section"},{"location":"api/types/","page":"Basic Types","title":"Basic Types","text":"CurrentModule = Actors","category":"page"},{"location":"api/types/","page":"Basic Types","title":"Basic Types","text":"The following types are needed for using and extending Actors:","category":"page"},{"location":"api/types/","page":"Basic Types","title":"Basic Types","text":"Msg\nRequest\nResponse\nLink\nBhv","category":"page"},{"location":"api/types/#Actors.Msg","page":"Basic Types","title":"Actors.Msg","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Actors.Request","page":"Basic Types","title":"Actors.Request","text":"Request(x, from::Link)\n\nA generic Msg for user requests.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Actors.Response","page":"Basic Types","title":"Actors.Response","text":"Response(y, from::Link=self())\n\nA Msg representing a response to requests.\n\nFields\n\ny: response content,\nfrom::Link: sender link.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Actors.Link","page":"Basic Types","title":"Actors.Link","text":"Link{C} <: ActorInterfaces.Classic.Addr\nLink(chn::C, pid::Int, type::Symbol) where C\n\nA mailbox for communicating with actors. A concrete type of this must be returned by an actor on creation with spawn.\n\nFields/Parameters\n\nchn::C: C can be any type and characterizes the interface   to an actor,\npid::Int: the pid (worker process identifier) of the actor, \nmode::Symbol: a symbol characterizing the actor mode.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Actors.Bhv","page":"Basic Types","title":"Actors.Bhv","text":"Bhv(func, a...; kw...)(c...)\n\nA callable struct to represent actor behavior. It is executed with parameters from the incoming communication.\n\nParameters\n\nf: a callable object,\na...: stored acquaintance parameters to f,\nkw...: stored keyword arguments,\nc...: parameters from the incoming communication.\n\n\n\n\n\n","category":"type"},{"location":"api/types/","page":"Basic Types","title":"Basic Types","text":"You can create your own message types with","category":"page"},{"location":"api/types/","page":"Basic Types","title":"Basic Types","text":"@msg","category":"page"},{"location":"api/types/#Actors.@msg","page":"Basic Types","title":"Actors.@msg","text":"@msg [Msg] A B C\n\nDefine empty structs as message types. Msg is an existing abstract datatype.\n\nTo call @msg Msg A B C is equivalent to\n\nstruct A <: Msg end\nstruct B <: Msg end\nstruct C <: Msg end\n\nTo call @msg D E F is equivalent to\n\nstruct D end\nstruct E end\nstruct F end\n\n\n\n\n\n","category":"macro"},{"location":"manual/errors/#Error-Handling-Overview","page":"Error Handling Overview","title":"Error Handling Overview","text":"","category":"section"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"CurrentModule = Actors","category":"page"},{"location":"manual/errors/#Errors","page":"Error Handling Overview","title":"Errors","text":"","category":"section"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"Failures in computations are due to hardware, software, and human cause failures. A single cause for such errors is difficult to quantify and depends strongly on circumstances. Therefore we can conclude that ","category":"page"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"failures are in principle unavoidable and that\nwe must take care of all three sources of errors [1].","category":"page"},{"location":"manual/errors/#Error-Handling","page":"Error Handling Overview","title":"Error Handling","text":"","category":"section"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"An actor system consists of computationally separate and concurrent entities. If one actor fails, the system does not crash immediately as do sequentially organized applications. Other actors can continue their tasks as long as they do not try to communicate with the failed one. The system now is in a problematic state, and we must somehow prevent further cascading failures.","category":"page"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"The solution is not to defend against errors but to organize the system such that actors","category":"page"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"monitor each other for failures and\nperform corrective actions if a failure is detected.","category":"page"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"Actors provides the following mechanisms [1][2][3] to handle errors in actors and tasks:","category":"page"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"mechanism brief description\nconnections Actors connect and propagate an Exit to each other.\nmonitors Actors can monitor other actors and tasks.\nsupervisors Actors can be supervised and restarted.\ncheckpointing Actors can save checkpoints to checkpointing actors and restore them.","category":"page"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"","category":"page"},{"location":"manual/errors/#The-_ROOT-Actor","page":"Error Handling Overview","title":"The _ROOT Actor","text":"","category":"section"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"If connect or monitor are called from the REPL or a user script and not from an actor, the given link will be connected to or monitored by the Actors._ROOT actor.","category":"page"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"[1]: Egwutuoha, I.P., Levy, D., Selic, B. et al. A survey of fault tolerance mechanisms and checkpoint/restart implementations for high performance computing systems. J Supercomput 65, 1302–1326 (2013). https://doi.org/10.1007/s11227-013-0884-0","category":"page"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"[2]: An outline of actor-based error handling is Joe Armstrong's dissertation: Making reliable distributed systems in the presence of software errors","category":"page"},{"location":"manual/errors/","page":"Error Handling Overview","title":"Error Handling Overview","text":"[3]: For implementation see also Joe Armstrong 2013. Programming Erlang, 2nd ed: Software for a Concurrent World; Manning, chs. 13 and 23 as well as the Erlang/OTP and Elixir online documentations.","category":"page"},{"location":"reference/glossary/#A-Glossary-of-Actor-Terms","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"","category":"section"},{"location":"reference/glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"Since Gul Agha's actor glossary [1] is very useful, we include here some of his descriptions and some additions or changes (marked with (*)).","category":"page"},{"location":"reference/glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"Actor term brief description\nacquaintance An actor alpha is an acquaintance of an actor beta if beta knows the mail address of alpha.\nactor A computational agent which has an mail address and a behavior. Actors communicate by message-passing and carry out their actions concurrently.\nasynchronous communication Communication is considered to be asynchronous when the sender does not have to wait for the recipient to be ready to accept a communication before the sender can send the communication.\nbehavior (*) The behavior of an actor maps the incoming communication to a three tuple of messages sent, new actors created, and the replacement behavior.\nbehaviour (*) \"A behavior encapsulates common behavioral patterns.\" Armstrong [2] The Erlang world has a more complex view of behaviors. Such more complex behaviors can be realized with a message protocol.\ncommunication The only mechanism by which actors may affect each other's behavior. The content of a message sent by an actor is called a communication.\nconcurrency The potentially parallel execution of actions without a determinate predefined sequence for their actions.\ncustomer A request communication contains the mail address of an actor called the customer to which a reply to the request is to be sent. Customers are dynamically created to carry out the rest of the computation, so that an actor sending a request to another actor can begin processing the next incoming communication without waiting for the subcomputations of the previous communication to complete.\nevent In the actor model, an event is the acceptance of a communication by an actor. In response to accepting a communication, an actor creates other actors, sends communications and specifies a replacement behavior; in an event based semantics these actions are considered a part of the event.\nexternal actor An actor which is external to a configuration but whose mail address is known to some actor within the configuration.\nfuture A future is an actor representing the value of a computation in progress. Futures can speed up computation since they allow subcomputations using references to a value to proceed concurrently with the evaluation of an expression to compute the value. Communications sent to a future are queued until the value has been determined.\nmail address A virtual location by which an actor may be accessed. Each actor has a unique mail address which is invariant, although the behavior of an actor may change over time.\nmail queue The queue of incoming communications sent to a given actor. The mail queue represents the arrival order of communications and provides the means to buffer communications until they are processed by the target actor.\nprotocol (*) An actor follows a protocol if it – when receiving certain messages – executes predefined behaviors other than its current behavior. This is used to implement more complex behaviors and goes beyond the classical model.\nreceptionist An actor to whom communications may be sent from outside the configuration to which it belongs. The set of receptionists evolves dynamically as the mail addresses of various actors may be communicated to actors outside the system.\nreplacement behavior A behavior specified by an actor processing a communication which is used to process the next communication in the mail queue of the actor.\nreply A communication sent in response to a request (see also customers).\nrequest A communication asking for a response to be sent to a customer contained in the request.\nsynchronous communication Communication between two actors requiring the sender to wait until the recipient acknowledges or otherwise responds to the communication before continuing with further processing. Synchronous communication in actors is implemented using customers.","category":"page"},{"location":"reference/glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"[1]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT; Appendix B","category":"page"},{"location":"reference/glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"[2]: Joe Armstrong 2014. Programming Erlang, 2nd Ed., Software for a Concurrent World, Pragmatic Programmers; p. 361","category":"page"},{"location":"manual/monitors/#Monitors","page":"Monitors","title":"Monitors","text":"","category":"section"},{"location":"manual/monitors/","page":"Monitors","title":"Monitors","text":"CurrentModule = Actors","category":"page"},{"location":"manual/monitors/","page":"Monitors","title":"Monitors","text":"An arbitrary actor can be told to monitor other actors or Julia tasks. Monitored actors or tasks send a Down message with an exit reason to their monitor(s) before they terminate. A monitor then gives a warning or executes a specified action dispatched on the received reason.","category":"page"},{"location":"manual/monitors/","page":"Monitors","title":"Monitors","text":"(Image: monitor)","category":"page"},{"location":"manual/monitors/","page":"Monitors","title":"Monitors","text":"Monitors do not forward Down messages. They give warnings or execute specified actions for Down signals (even with reason :normal). Monitoring is not bidirectional. If a monitor fails, the monitored actor gets no notification. Monitoring can be stopped with demonitor. An actor can have several monitors (if that makes sense).","category":"page"},{"location":"manual/monitors/","page":"Monitors","title":"Monitors","text":"You can see a script illustrating monitoring in the How-to section.","category":"page"},{"location":"#Welcome-to-Actors","page":"Introduction","title":"Welcome to Actors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Actors is a Julia library for concurrent computing based on the Actor Model:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"An actor ... in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [1]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Actors make concurrency easy to understand and reason about and integrate well with Julia's multi-threaded and distributed computing. Actors provides a modern API [2] for writing reactive [3] applications, that are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"responsive : react to inputs and events,\nresilient : can cope with failures,\nelastic : can distribute load over multiple threads and  workers,\nmessage-driven : rely on asynchronous message-passing.","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This overview of Actors' documentation [4] will help you know where to look for certain things:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tutorials will help you to learn how to work with actors. Start here if you’re new to Actors.\nHow-to guides are recipes. They guide you through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume some knowledge of how actors work.\nOn Actors discusses key concepts and provides background information and explanation.\nReference contains technical reference for APIs, some examples and internals. It assumes that you have a basic understanding of key concepts.","category":"page"},{"location":"#Links","page":"Introduction","title":"Links","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Actors GitHub repository,\nJuliaActors","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: See the Wikipedia entry on the Actor Model","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[2]: The Actors API is inspired by Erlang/OTP, see OTP Design Principles - User’s Guide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[3]: See The Reactive Manifesto","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[4]: The organization of the docs follows the Diátaxis Framework","category":"page"},{"location":"api/api/#Actors-Module","page":"Actors Module","title":"Actors Module","text":"","category":"section"},{"location":"api/api/","page":"Actors Module","title":"Actors Module","text":"CurrentModule = Actors","category":"page"},{"location":"api/api/","page":"Actors Module","title":"Actors Module","text":"Actors\nActors.version","category":"page"},{"location":"api/api/#Actors.Actors","page":"Actors Module","title":"Actors.Actors","text":"Actors implements the classical Actor Model and is  based on the primitives defined in ActorInterfaces.Classic.  It provides:\n\nbasic primitives for creating actors,   sending messages to them and changing behavior:   spawn, send, become    with Addr and self,\nonmessage, executed by an actor on a    received message,\na message protocol with predefined messages,\nan API based on the protocol with primitives   receive and request and further    API functions become!, call,    cast, exec, exit!,    init!, query, term!,    update!,\nerror handling with actor\nconnections: connect, disconnect, trapExit,\nmonitors: monitor, demonitor,\nsupervisors: supervisor, supervise,    unsupervise, start_actor,    start_task, count_children,    which_children, terminate_child, \nan actor registry: register, unregister,    whereis, registered\n\nand more.\n\nThe current stable, registered version is installed with\n\npkg> add Actors\n\nThe development version is installed with:\n\npkg> add \"https://github.com/JuliaActors/Actors.jl\"\n\n\n\n\n\n","category":"module"},{"location":"api/api/#Actors.version","page":"Actors Module","title":"Actors.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"api/api/","page":"Actors Module","title":"Actors Module","text":"using Actors\nActors.version","category":"page"},{"location":"tutorial/stack/#stack","page":"Implement a Stack","title":"Implement a Stack","text":"","category":"section"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"As an illustration of actor behavior we reproduce Gul Agha's example 3.2.1:","category":"page"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"We implement a stack as a collection of actors with uniform behavior. ... [A] linked list consists of a collection of nodes each of which stores a value and knows the mail address of the \"next\" actor in the chain. ... Two kinds of operations may be requested of a stack-node: a push or a pop. In the first case, the new content to be pushed must be given, and in the second, the customer to which the value stored in the stack-node can be sent. [1]","category":"page"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"Let's first define some types:","category":"page"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"mutable struct StackNode{T,L}  # a stack node object\n    content::T\n    link::L\nend\n\nstruct Pop{L}                  # a pop message\n    customer::L\nend\n\nstruct Push{T}                 # a push message\n    content::T\nend","category":"page"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"The top of the stack is the only receptionist in the stack system and was the only actor of the stack system created externally. It is created with a NIL content which is assumed to be the bottom of the stack marker. Notice that no mail address of a stack node is ever communicated by any node to an external actor. Therefore no actor outside the configuration defined above can effect any of the actors inside the stack except by sending the receptionist a communication. When a pop operation is done, the actor on top of the stack simply becomes a forwarder to the next actor in the link. This means that all communications received by the top of the stack are now forwarded to the next element. [1]","category":"page"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"To implement the stack we use both the functional and the object oriented style for actor behaviors:","category":"page"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"forwarder is just an alias for send which we put together with sn.link into a behavior. After become(forwarder, sn.link) the actor will forward any received message to sn.link.\nStackNode is a function object with two methods for Pop and Push messages.","category":"page"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"const forwarder = send\nfunction (sn::StackNode)(msg::Pop)\n    isnothing(sn.content) || become(forwarder, sn.link)\n    send(msg.customer, sn.content)\nend\n(sn::StackNode)(msg::Push) = become(StackNode(msg.content, spawn(sn)))","category":"page"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"Now we can operate the stack:","category":"page"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"julia> mystack = spawn(StackNode(nothing, newLink())) # create the top of the stack\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> response = newLink()                           # create a response link\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :local)\n\njulia> for i ∈ 1:5\n           send(mystack, Push(i))\n       end\n\njulia> for i ∈ 1:5\n           send(mystack, Pop(response))\n           println(receive(response))\n       end\n5\n4\n3\n2\n1","category":"page"},{"location":"tutorial/stack/","page":"Implement a Stack","title":"Implement a Stack","text":"[1]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT.- p. 34f","category":"page"},{"location":"api/supervision/#Supervisors","page":"Supervisors","title":"Supervisors","text":"","category":"section"},{"location":"api/supervision/","page":"Supervisors","title":"Supervisors","text":"CurrentModule = Actors","category":"page"},{"location":"api/supervision/","page":"Supervisors","title":"Supervisors","text":"Supervisors allow some automation and control of error handling in an actor system. A supervisor actor can restart its children if they should terminate.","category":"page"},{"location":"api/supervision/#strategies","page":"Supervisors","title":"Supervision Strategies","text":"","category":"section"},{"location":"api/supervision/","page":"Supervisors","title":"Supervisors","text":"What a supervisor does if one of its children terminates, is determined by its supervision strategy argument:","category":"page"},{"location":"api/supervision/","page":"Supervisors","title":"Supervisors","text":"strategy brief description\n:one_for_one only the terminated actor is restarted (A4),\n:one_for_all all other child actors are terminated, then all child actors are restarted (A1-A6),\n:rest_for_one the children started after the terminated one are terminated, then all terminated ones are restarted (A4-A6).","category":"page"},{"location":"api/supervision/#restart","page":"Supervisors","title":"Child Restart Options","text":"","category":"section"},{"location":"api/supervision/","page":"Supervisors","title":"Supervisors","text":"Child restart options with supervise allow for yet finer child-specific control of restarting:","category":"page"},{"location":"api/supervision/","page":"Supervisors","title":"Supervisors","text":"restart option brief description\n:permanent the child actor is always restarted,\n:temporary the child is never restarted, regardless of the supervision strategy,\n:transient the child is restarted only if it terminates abnormally, i.e., with an exit reason other than :normal or :shutdown.","category":"page"},{"location":"api/supervision/#Supervision-API","page":"Supervisors","title":"Supervision API","text":"","category":"section"},{"location":"api/supervision/","page":"Supervisors","title":"Supervisors","text":"Supervisors have the following API:","category":"page"},{"location":"api/supervision/","page":"Supervisors","title":"Supervisors","text":"API function brief description\nsupervisor start a supervisor actor,\nsupervise add an actor to a supervisor's child list,\nunsupervise delete an actor or task from a supervisor's child list,\nstart_actor tell a supervisor to start an actor as a child,\nstart_task tell a supervisor to start a task as a child,\nterminate_child tell a supervisor to terminate a child and to remove it from its child list,\nset_strategy tell a supervisor to change its supervision strategy,\ncount_children tell a supervisor to return a children count,\nwhich_children tell a supervisor to return a list of its children.","category":"page"},{"location":"api/supervision/#Functions","page":"Supervisors","title":"Functions","text":"","category":"section"},{"location":"api/supervision/","page":"Supervisors","title":"Supervisors","text":"supervisor\nsupervise\nunsupervise\nset_strategy\nstart_actor\nstart_task\ncount_children\nwhich_children\nterminate_child","category":"page"},{"location":"api/supervision/#Actors.supervisor","page":"Supervisors","title":"Actors.supervisor","text":"supervisor( strategy=:one_for_one, \n            max_restarts::Int=3, \n            max_seconds::Real=5; \n            name=nothing, kwargs...)\n\nSpawn a supervisor actor with an empty child list and return a link to it.\n\nArguments\n\nThe following arguments are mandatory and go into a supervisor's  options:\n\nstrategy=:one_for_one: supervision strategy, can be    either :one_for_one, :one_for_all or :rest_for_one,\nmax_restarts::Int=3: maximum number of restarts    allowed in a time frame,\nmax_seconds::Real=5: time frame in which    max_restarts applies,\n\nKeyword arguments and further options\n\nname=nothing: name (Symbol) under which a supervisor should   be registered, if nothing it doesn't get registered,\nkwargs...: further keyword arguments to the    Supervisor and to spawn. Keyword arguments    not taken by spawn are supervisor options, used to extend a    supervisor's functionality.\n\nReserved options\n\nstrategy, max_restarts, max_seconds, name are reserved,    see above,\nspares=[5,6,7]: spare pids, where you can give spare pids    (e.g. [5,6,7]) to a supervisor used for actor restarts after    node failures.\n\n\n\n\n\n","category":"function"},{"location":"api/supervision/#Actors.supervise","page":"Supervisors","title":"Actors.supervise","text":"supervise(sv, child=self(); cb=nothing, restart::Symbol=:transient)\n\nTell a supervisor sv to supervise the given child actor.\n\nArguments\n\nsv: link or registered name of a supervisor,\nchild: link or registered name of an actor to supervise.\n\nKeyword Arguments\n\ncb=nothing: callback (a callable object), takes the    previous actor behavior as argument and must return    a Link to a new actor; if nothing, the   actor gets restarted with its init! callback    or its previous behavior. \nrestart::Symbol=:transient: restart option, one of    :permanent, :temporary, :transient,\n\n\n\n\n\n","category":"function"},{"location":"api/supervision/#Actors.unsupervise","page":"Supervisors","title":"Actors.unsupervise","text":"unsupervise(sv, lst=self())\n\nTell a supervisor sv to delete ls from its childs list. \n\nArguments\n\nsv: link or registered name of a supervisor,\nlst: link, registered name of an actor or task.\n\n\n\n\n\n","category":"function"},{"location":"api/supervision/#Actors.set_strategy","page":"Supervisors","title":"Actors.set_strategy","text":"set_strategy(sv, strategy::Symbol)\n\nTell a supervisor sv to change its restart strategy.\n\n\n\n\n\n","category":"function"},{"location":"api/supervision/#Actors.start_actor","page":"Supervisors","title":"Actors.start_actor","text":"start_actor(start, sv, cb=nothing, restart::Symbol=:transient; \n            name::Union{Symbol,Nothing}=nothing, kwargs...)\n\nTell a supervisor sv to start an actor, to add  it to its childs list and to return a link to it.\n\nArguments\n\nstart: start behavior of the child, a callable object,\nsv::Link: link to a started supervisor,\ncb=nothing: callback (a callable object, gets the last   actor behavior as argument and must return a Link);     if nothing, the actor gets restarted with its init!    callback or with its last behavior,\nrestart::Symbol=:transient: restart option, one of    :permanent, :temporary, :transient,\nname::Union{Symbol,Nothing}=nothing, name (Symbol) under which   the actor should be registered,\nkwargs...: keyword arguments to spawn.\n\n\n\n\n\n","category":"function"},{"location":"api/supervision/#Actors.start_task","page":"Supervisors","title":"Actors.start_task","text":"start_task(start, sv, cb=nothing; \n           timeout::Real=5.0, pollint::Real=0.1)\n\nSpawn a task with a start behavior and tell the supervisor sv to supervise it (with restart strategy :transient) and return a reference to it.\n\nParameters\n\nstart: must be a callable object (with no arguments),\nsv: link or registered name of a supervisor,\ncb=nothing: callback for restart (a callable object, must    return a Task); if cb=nothing, the task gets restarted    with its start function,\ntimeout::Real=5.0: how long [seconds] should the task    be supervised, \npollint::Real=0.1: polling interval [seconds].\n\n\n\n\n\n","category":"function"},{"location":"api/supervision/#Actors.count_children","page":"Supervisors","title":"Actors.count_children","text":"count_children(sv)\n\nReturn a named tuple containing children counts for the given supervisor sv (link or registered name).\n\n\n\n\n\n","category":"function"},{"location":"api/supervision/#Actors.which_children","page":"Supervisors","title":"Actors.which_children","text":"which_children(sv, info=false)\n\nTell a supervisor sv to return its childs list. \n\nArguments\n\nsv: link or registered name of a supervisor,\ninfo=false: If info=true, return a list of named tuples    with child information.\n\n\n\n\n\n","category":"function"},{"location":"api/supervision/#Actors.terminate_child","page":"Supervisors","title":"Actors.terminate_child","text":"terminate_child(sv, ls)\n\nTell a supervisor sv to remove a child ls from its  childs list and to terminate it with reason :shutdown.\n\nArguments\n\nsv: link or registered name of a supervisor,\nls: link or registered name of a child.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/intro/#Getting-Started-with-Actors","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"CurrentModule = Actors","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"You need to know only a few quite self-explanatory functions to get started with concurrent actor programming:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"API function Brief description\nspawn create an actor with a behavior and get a Link to it,\nsend, receive send and receive messages over an actor Link,\nrequest, call request or call something from an actor (behavior),\ncast cast something to an actor (behavior),\nbecome, become! change the behavior of an actor,\nquery, update! query or update an actor's state.","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"When we introduce those functions, please follow along in your Julia REPL and don't hesitate to try things out.","category":"page"},{"location":"tutorial/intro/#Create-an-actor","page":"Getting Started with Actors","title":"Create an actor","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The basic mechanism to create a new actor is the spawn function. You have to import it explicitly:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"using Actors, .Threads\nimport Actors: spawn, newLink","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"You spawn an actor with a behavior. A behavior is a callable Julia object (a function, functor …) and some parameters to it. We start our first actor with a parameterless threadid behavior, which returns the thread number, where it resides:  ","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"myactor = spawn(threadid)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"That returned an actor Link. Now - as we will discover right away - our actor is responsive and waits for our messages.","category":"page"},{"location":"tutorial/intro/#Actor-Links","page":"Getting Started with Actors","title":"Actor Links","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"A Link is the actor's mail address and its only representation. You use it to send messages to the actor or to use other messaging functions like info. If you call it, you trigger its behavior and get a result back:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"info(myactor)         # get some info from it\ncall(myactor)         # call its behavior function","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Now what happens if you send your actor a message which it cannot understand?","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, :boom)  # cause the actor to fail\ninfo(myactor)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We caused our actor to fail. Ouch!","category":"page"},{"location":"tutorial/intro/#Actor-behavior","page":"Getting Started with Actors","title":"Actor behavior","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Now let's write our own behavior function! We want our actor to execute a given function f on parameters args... and to send the result back to a given address addr:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"calc(addr::Link, f::Function, args...) = send(addr, f(args...))","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"With newLink we create a link, where we can receive the actor's answer. We spawn a new actor with our calc behavior function and give it that newly created link as acquaintance parameter:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"me = newLink()\nmyactor = spawn(calc, me)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Now our actor holds the me link as acquaintance. Its behavior is the calc function together with the me link.","category":"page"},{"location":"tutorial/intro/#send-and-receive-Messages","page":"Getting Started with Actors","title":"send and receive Messages","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We need to send it only the rest of the parameters to cause it to execute its behavior and to send the result back. If we send it a + and some values, it will add them and send the result to the given me link:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, +, 1, 2, 3, 4)\nreceive(me)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Now we did asynchronous communication with our actor. After sending it something, we could have done other work and then received the result later.","category":"page"},{"location":"tutorial/intro/#Change-behavior","page":"Getting Started with Actors","title":"Change behavior","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"If we want our actor to do only multiplication, we can change its behavior with become! to calc with new acquaintances:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"become!(myactor, calc, me, *);","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The actor's new behavior is calc with two acquaintances me and *, and thus it does multiplication only. As before we send it the communication parameters to multiply and receive the result:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, 1,2,3,4)\nreceive(me)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"An actor can change also its own behavior with become inside its behavior function. Instead become! is a call from the outside of an actor. A behavior change is effective for the next message an actor receives.","category":"page"},{"location":"tutorial/intro/#A-communication-failure","page":"Getting Started with Actors","title":"A communication failure","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"What happens if a communication fails? Let's try that out: We cause our actor to fail, so it will not send back anything. Then we try to receive an answer:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, +, 5, \"x\")\nreceive(me)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"After some seconds we got a Timeout().","category":"page"},{"location":"tutorial/intro/#The-actor-protocol","page":"Getting Started with Actors","title":"The actor protocol","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We don't give up with it and start it again, but now we want it to be an adding machine with an offset of 1000:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"myactor = spawn(+, 1000)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Our actor now has no acquaintance of me, neither has its behavior any send instruction. If we send it something, it will only add that to 1000 but not respond anything. The message protocol allows us to communicate with actors even if their behaviors don't send anything. Actors understand messaging patterns.","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The request function is a wrapper for synchronous communication. It will create a link internally and send it with the communication parameters as a Call (or another given message type) to the actor. That sends a Response back to the received link, and request then delivers the response:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"request(myactor, 1,2,3)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"This is synchronous communication since request blocks until it receives the result (or a Timeout()).","category":"page"},{"location":"tutorial/intro/#call,-cast-and-query","page":"Getting Started with Actors","title":"call, cast and query","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Then there are more user API functions.","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We can do asynchronous communication with our actor if we use call with the me link. This sends the given link to the actor and it responds to it. Then we can receive the result asynchronously:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"call(myactor, me, 1000)\nreceive(me).y","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"If we don't provide a return link to call, it will use request and deliver the result synchronously:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"call(myactor, 2000)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Another possibility to communicate asynchronously with an actor is to cast it parameters and then to query the result afterwards.","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"cast(myactor, 3000)\nquery(myactor, :res)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"But this will work fine only if between those two calls to myactor there is not another actor communicating with it. If for example our actor has mutual variables as acquaintances, we can use cast to set parameters or to do anything else where we don't need a response.","category":"page"},{"location":"tutorial/intro/#More-Control:-exec,-update!,-exit!-…","page":"Getting Started with Actors","title":"More Control: exec, update!, exit! …","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"With exec we can tell an actor to execute any function and to deliver the result:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"exec(myactor, broadcast, cos, pi .* (-2:2))","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Actors have internal state variables, which we normally don't need to work with. We can update! those variables. Let's update! the actor's current acquaintance parameter (1000) to 500. Then it adds to 500:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"update!(myactor, Args(500))\ncall(myactor, 500)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"But we could have achieved the same with become!(myactor, +, 500).","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Finally we exit! our actor since we are finished with this introduction:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"exit!(myactor)\nsend(myactor, 500)","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Trying to send it something now throws an exception.","category":"page"},{"location":"tutorial/intro/#Actor-Systems","page":"Getting Started with Actors","title":"Actor Systems","text":"","category":"section"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"For this introduction we have worked with one actor. But there is no point in doing that. Actors come in systems. They can assume different and arbitrary behaviors, create other actors and then compose into systems by communicating via messages. Thus they can represent arbitrary concurrent systems.","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Let's build a minimal actor system. It consists of two actors, a greeter actor for composing a greeting and a sayhello actor for communication:","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"greet(greeting, msg) = greeting*\", \"*msg*\"!\" # a greetings server behavior\nhello(greeter, to) = request(greeter, to)    # a greetings client behavior\ngreeter = spawn(greet, \"Hello\")              # start the server with a greet string\nsayhello = spawn(hello, greeter)             # start the client with a link to the server\nrequest(sayhello, \"World\")                   # request the client\nrequest(sayhello, \"Kermit\")","category":"page"},{"location":"tutorial/intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We could have done that without actors. But, come on, add a third one, saying hello asynchronously. Then you need a forth one to channel the access of the hello actors to the console …","category":"page"},{"location":"howto/register/#How-to-register-an-actor","page":"register actors","title":"How to register an actor","text":"","category":"section"},{"location":"howto/register/","page":"register actors","title":"register actors","text":"CurrentModule = Actors","category":"page"},{"location":"howto/register/","page":"register actors","title":"register actors","text":"If a parent actor or worker process creates a new actor, the link to it is only locally known. It has to be sent to all other actors that want to communicate with it.","category":"page"},{"location":"howto/register/","page":"register actors","title":"register actors","text":"Now let's setup a remote worker and an ident function:","category":"page"},{"location":"howto/register/","page":"register actors","title":"register actors","text":"julia> using Actors, Distributed\n\njulia> import Actors: spawn\n\njulia> addprocs(1);\n\njulia> @everywhere using Actors\n\njulia> @everywhere function ident(id, from)\n           id == from ?\n               (\"local actor\",  id, from) :\n               (\"remote actor\", id, from)\n       end","category":"page"},{"location":"howto/register/","page":"register actors","title":"register actors","text":"An actor (link) can be registered under a name (a Symbol). This name then is known system-wide and any other actor can communicate with it using that name:","category":"page"},{"location":"howto/register/","page":"register actors","title":"register actors","text":"julia> register(:act1, spawn(ident, 1))      # a registered local actor\ntrue\n\njulia> call(:act1, myid())                   # call it locally\n(\"local actor\", 1, 1)\n\njulia> register(:act2, spawn(ident, 2, pid=2)) #  register a remote actor on pid 2\ntrue\n\njulia> call(:act2, myid())                   # call it locally\n(\"remote actor\", 2, 1)\n\njulia> fetch(@spawnat 2 call(:act1, myid())) # call :act1 on pid 2\n(\"remote actor\", 1, 2)\n\njulia> fetch(@spawnat 2 call(:act2, myid())) # call :act2 on pid 2\n(\"local actor\", 2, 2)","category":"page"},{"location":"howto/register/","page":"register actors","title":"register actors","text":"The registry provides three further functions:","category":"page"},{"location":"howto/register/","page":"register actors","title":"register actors","text":"API function brief description\nwhereis return the link of a registered actor\nregistered return an array of all registered actors\nunregister remove a registration","category":"page"},{"location":"howto/register/","page":"register actors","title":"register actors","text":"julia> whereis(:act1)                         # get a link to :act1\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> whereis(:act2)                         # get a link to :act2\nLink{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n\njulia> fetch(@spawnat 2 whereis(:act1))       # get a link to :act1 on pid 2\nLink{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 40), 1, :default)\n\njulia> registered()                           # get a list of registered actors\n2-element Array{Pair{Symbol,Link},1}:\n :act2 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n :act1 => Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> fetch(@spawnat 2 registered())         # get it on pid 2\n2-element Array{Pair{Symbol,Link{RemoteChannel{Channel{Any}}}},1}:\n :act2 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n :act1 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 46), 1, :default)","category":"page"},{"location":"howto/register/","page":"register actors","title":"register actors","text":"The registry works transparently across workers. All workers have access to registered actors on other workers via remote links.","category":"page"},{"location":"howto/failure/#How-to-deal-with-failures","page":"deal with failures","title":"How to deal with failures","text":"","category":"section"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"CurrentModule = Actors","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"Actors adopts Erlang's error handling philosophy [1] and gives you a lot of options to deal with failures and to write fault-tolerant applications.","category":"page"},{"location":"howto/failure/#Let-it-crash","page":"deal with failures","title":"Let it crash","text":"","category":"section"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"In short if an actor fails, don't try to avoid it but","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"let it crash and\nlet some other actor do the error recovery.","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"Therefore as a basic mechanism you want actors to connect with peer, monitor or supervisor actors to signal failures in an actor system and to do something about it.","category":"page"},{"location":"howto/failure/#connect","page":"deal with failures","title":"connect actors","text":"","category":"section"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"If an actor fails, we want other actors that depend on it also actively fail before they get into some undefined state. To achieve that, we can connect dependent actors. Connected actors will propagate a failure to each other until they encounter a :sticky actor. To connect actors, you","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"have arbitrary actors (e.g. A[1] - A[10]),\ntell some of them to connect with each other,\nif needed, make some of them :sticky with trapExit in order to block the failure propagation.","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"julia> using Actors, .Threads\n\njulia> import Actors: spawn\n\njulia> A = map((_)->spawn(threadid), 1:10); # create 10 actors\n\njulia> exec(A[3], connect, A[1]);           # connect A3 - A1\n\njulia> exec(A[3], connect, A[7]);           # connect A3 - A7\n\njulia> exec(A[9], connect, A[7]);           # connect A9 - A7\n\njulia> exec(A[9], connect, A[4]);           # connect A9 - A4\n\njulia> t = map(a->Actors.diag(a, :task), A) # create a task list\n10-element Vector{Task}:\n Task (runnable) @0x000000016e949220\n Task (runnable) @0x000000016e94a100\n Task (runnable) @0x000000016e94a320\n Task (runnable) @0x000000016e94a540\n Task (runnable) @0x000000016e94a760\n Task (runnable) @0x000000016e94a980\n Task (runnable) @0x000000016e94aba0\n Task (runnable) @0x000000016e94adc0\n Task (runnable) @0x000000016e94b0f0\n Task (runnable) @0x000000016e94b310\n\njulia> trapExit(A[3])                       # make A3 a sticky actor\nActors.Update(:mode, :sticky)","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"If one of the connected actors fails, it will send an Exit message to its connected actors. Those will propagate the Exit further to their connected actors and terminate. If you made one :sticky, that will give a warning (and not exit).","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"julia> send(A[9], :boom);                   # cause A9 to fail\n┌ Warning: 2021-02-13 12:08:11 x-d-kupih-pasob: Exit: connected Task (failed) @0x000000016e94b0f0, MethodError(Base.Threads.threadid, (:boom,), 0x0000000000007447)\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n\njulia> t                                    # display the task list again\n10-element Vector{Task}:\n Task (runnable) @0x000000016e949220\n Task (runnable) @0x000000016e94a100\n Task (runnable) @0x000000016e94a320\n Task (done) @0x000000016e94a540\n Task (runnable) @0x000000016e94a760\n Task (runnable) @0x000000016e94a980\n Task (done) @0x000000016e94aba0\n Task (runnable) @0x000000016e94adc0\n Task (failed) @0x000000016e94b0f0\n Task (runnable) @0x000000016e94b310","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"With Actors.diag you can get an error log and access to the failed task from the :sticky actor A[3].","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"You can view a graphical representation and further explanation in the manual.","category":"page"},{"location":"howto/failure/#monitor","page":"deal with failures","title":"monitor actors and tasks","text":"","category":"section"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"We can make an arbitrary actor a monitor that watches other actors and give warnings or execute specified options if they exit.","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"For example we start three actors A1-A3. We make A3 a monitor for A1 and A2. Then it gets a Down signal from its monitored actors if they exit.","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"julia> A = map(_->spawn(threadid), 1:3);\n\njulia> exec(A[3], monitor, A[1]);\n\njulia> exec(A[3], monitor, A[2]);\n\njulia> t = map(a->Actors.diag(a, :task), A)\n3-element Vector{Task}:\n Task (runnable) @0x000000010f8f5000\n Task (runnable) @0x000000010fbb8120\n Task (runnable) @0x000000010fbb8890\n\njulia> exit!(A[1]);\n┌ Warning: 2021-02-13 12:36:32 x-d-uvur-mofib: Down:  normal\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n\njulia> send(A[2], :boom);\n┌ Warning: 2021-02-13 12:36:58 x-d-uvur-mofib: Down:  Task (failed) @0x000000010fbb8120, MethodError(Base.Threads.threadid, (:boom,), 0x000000000000744f)\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n\njulia> t\n3-element Vector{Task}:\n Task (done) @0x000000010f8f5000\n Task (failed) @0x000000010fbb8120\n Task (runnable) @0x000000010fbb8890","category":"page"},{"location":"howto/failure/#supervise-actors","page":"deal with failures","title":"supervise actors","text":"","category":"section"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"By supervision you can restart actors automatically if they fail or if the remote node fails, on which they reside.","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"Please see the","category":"page"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"Supervise Actors tutorial for an introduction,\nSupervisors manual for illustration and explanations,\nNode Failures manual for explanation of supervision of node failures,\nSupervisors API reference for more informations.","category":"page"},{"location":"howto/failure/#take-checkpoints","page":"deal with failures","title":"take checkpoints","text":"","category":"section"},{"location":"howto/failure/#define-exit-and-init-behaviors","page":"deal with failures","title":"define exit and init behaviors","text":"","category":"section"},{"location":"howto/failure/","page":"deal with failures","title":"deal with failures","text":"[1]: See Joe Armstrong's dissertation: Making reliable distributed systems in the presence of software errors, ch. 4.3, pp. 104 ...","category":"page"},{"location":"reference/messages/#Messages","page":"Messages","title":"Messages","text":"","category":"section"},{"location":"reference/messages/","page":"Messages","title":"Messages","text":"CurrentModule = Actors","category":"page"},{"location":"reference/messages/","page":"Messages","title":"Messages","text":"Actors can be called, updated, queried … This is implemented with Julia's multiple dispatch. An actors dispatches the onmessage methods on the incoming messages:","category":"page"},{"location":"reference/messages/","page":"Messages","title":"Messages","text":"onmessage","category":"page"},{"location":"reference/messages/#ActorInterfaces.Classic.onmessage","page":"Messages","title":"ActorInterfaces.Classic.onmessage","text":"onmessage(bhv, msg)\n\nDefault behavior function to execute the current actor  behavior bhv with the message msg. The actor calls bhv(msg) when a message arrives. \n\nParameters\n\nbhv: excutable object (closure or functor) taking   parameters msg,\nmsg: message parameters to bhv.\n\n\n\n\n\nonmessage(A::_ACT, msg)\nonmessage(A::_ACT, mode, msg)\n\nAn actor executes this function when a message arrives.\n\nActor libraries or applications can use this to\n\nplugin the Actors.jl API (first form) or\nextend it to other protocols by using the 2nd form.\n\n\n\n\n\n","category":"function"},{"location":"reference/messages/#Internal-Messages","page":"Messages","title":"Internal Messages","text":"","category":"section"},{"location":"reference/messages/","page":"Messages","title":"Messages","text":"The actor's onmessage methods are dispatched by and do different things with the following internal messages:","category":"page"},{"location":"reference/messages/","page":"Messages","title":"Messages","text":"Become\nCall\nCast\nConnect\nDiag\nDown\nExit\nExec\nInit\nQuery\nTerm\nTimeout\nUpdate","category":"page"},{"location":"reference/messages/#Actors.Become","page":"Messages","title":"Actors.Become","text":"Become(bhv)\n\nAn asynchronous Msg to an actor to change its  behavior to bhv.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Call","page":"Messages","title":"Actors.Call","text":"Call(arg, from::Link)\n\nA synchronous Msg to an actor to execute its  behavior with arg... and to send the result as a Response  message to from.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Cast","page":"Messages","title":"Actors.Cast","text":"Cast(arg)\n\nAn asynchronous Msg to an actor to execute  its behavior with arg... without sending a response.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Connect","page":"Messages","title":"Actors.Connect","text":"Connect(x, remove=false)\n\nA Msg to an actor to connect with x. If  remove=true, an existing connection gets removed.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Diag","page":"Messages","title":"Actors.Diag","text":"Diag(x, from::Link)\n\nA synchronous Msg to an actor to send diagnostic information.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Down","page":"Messages","title":"Actors.Down","text":"Down(from, reason, task)\n\nA Msg to a monitor actor indicating that an error has occurred or a Exit has been received.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Exit","page":"Messages","title":"Actors.Exit","text":"Exit(reason, from, task, state)\n\nA Msg to an actor causing it to terminate.  Exit messages are sent to connected actors  if an error has occurred and then are propagated further. They are not propagated by :sticky actors, see  trapExit.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Exec","page":"Messages","title":"Actors.Exec","text":"Exec(func::Bhv, from::Link)\n\nA synchronous Msg to an actor to execute func and to send a Response message with the return value to from.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Init","page":"Messages","title":"Actors.Init","text":"Init(f::Bhv)\n\nA Msg to an actor to execute the given Bhv and to store it in the _ACT variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Query","page":"Messages","title":"Actors.Query","text":"Query(s::Symbol, from::Link)\n\nA Msg to an actor to send a  Response message with one of its internal state  variables s to from.\n\ns::Symbol can be one of :sta, :res, :bhv, :dsp.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Term","page":"Messages","title":"Actors.Term","text":"Term(x::Bhv)\n\nA Msg to an actor to save the given Bhv  and to execute it upon termination.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Timeout","page":"Messages","title":"Actors.Timeout","text":"Timeout()\n\nA return value to signal that a timeout has occurred.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#Actors.Update","page":"Messages","title":"Actors.Update","text":"Update(s::Symbol, x)\n\nAn asynchronous Msg to an actor to update its  internal state s to x.\n\ns::Symbol can be one of :arg, :self, :sta, :usr.\n\n\n\n\n\n","category":"type"},{"location":"reference/messages/#User-extensions","page":"Messages","title":"User extensions","text":"","category":"section"},{"location":"reference/messages/","page":"Messages","title":"Messages","text":"There are four ways to extend the messaging protocol and the functionality of Actors:","category":"page"},{"location":"reference/messages/","page":"Messages","title":"Messages","text":"If a user defines its own messages of type Msg and sends them to an actor, it passes them on as remaining argument to the behavior function.\nAlternatively a user can extend Actors.onmessage with his own methods to dispatch on those messages and doing user defined things.\nA user can set the actor mode with spawn or change it with update! to something other than :default, e.g. :mymode. If he then implements a method Actors.onmessage(A::_ACT, ::Val{:mymode}, msg::Call) and so on, the actor will dispatch that one when it receives a Call message.\nFinally a user can implement other message types and messaging protocols and extend Actors.onmessage for dispatching on those.","category":"page"},{"location":"manual/connections/#Connections","page":"Connections","title":"Connections","text":"","category":"section"},{"location":"manual/connections/","page":"Connections","title":"Connections","text":"CurrentModule = Actors","category":"page"},{"location":"manual/connections/","page":"Connections","title":"Connections","text":"If you have actors depending on each other, you may want them to exit together if one of them terminates. Therefore you can connect them as peers. Then an actor will send an Exit message to its connected actors. Those propagate the Exit message (caused by a failure, stop or exit!) to their connected actors and then terminate","category":"page"},{"location":"manual/connections/","page":"Connections","title":"Connections","text":"if the exit reason is other than :normal,\nand if they are not :sticky.","category":"page"},{"location":"manual/connections/","page":"Connections","title":"Connections","text":"With trapExit an actor can be made :sticky. When it then receives an Exit message with a reason other than :normal, it will","category":"page"},{"location":"manual/connections/","page":"Connections","title":"Connections","text":"not propagate it and not terminate but\ngive a warning about it and\nstore a link to the failed actor.","category":"page"},{"location":"manual/connections/","page":"Connections","title":"Connections","text":"Connections between actors are always bidirectional and can be disconnected. You can build a chain or network of connected actors that depend on each other and exit together. A :sticky actor operates as a firewall among connected actors.","category":"page"},{"location":"manual/connections/","page":"Connections","title":"Connections","text":"(Image: connection)","category":"page"},{"location":"manual/connections/","page":"Connections","title":"Connections","text":"Assume in an actor system A1-A3-A7-A9-A4 are connected, A3 is a :sticky actor and A9 fails. Before it terminates, it sends an Exit message to A4 and A7. A7 propagates it further to A3. A9, A4 and A7 die together. A3 gives a warning about the failure and saves the link to the failed actor A9. A3 does not propagate the Exit to A1. Both A1 and A3 stay connected and continue to operate. The other actors are separate and are not affected by the failure.","category":"page"},{"location":"manual/connections/","page":"Connections","title":"Connections","text":"See a Julia script illustrating the above system in the How-to section.","category":"page"},{"location":"api/registry/#Actor-Registry","page":"Actor Registry","title":"Actor Registry","text":"","category":"section"},{"location":"api/registry/","page":"Actor Registry","title":"Actor Registry","text":"CurrentModule = Actors","category":"page"},{"location":"api/registry/","page":"Actor Registry","title":"Actor Registry","text":"Actors can be registered with Symbols to a registry. API functions on actors can then be called with their registered names.","category":"page"},{"location":"api/registry/","page":"Actor Registry","title":"Actor Registry","text":"register\nunregister\nwhereis\nregistered","category":"page"},{"location":"api/registry/#Actors.register","page":"Actor Registry","title":"Actors.register","text":"register(name::Symbol, lk::Link)\n\nRegister the actor lk with name. Returns true if the  registration succeeds, false if name is already in use.\n\n\n\n\n\n","category":"function"},{"location":"api/registry/#Actors.unregister","page":"Actor Registry","title":"Actors.unregister","text":"unregister(name::Symbol)\n\nRemove any registrations associated with name.\n\n\n\n\n\n","category":"function"},{"location":"api/registry/#Actors.whereis","page":"Actor Registry","title":"Actors.whereis","text":"whereis(name::Symbol)\n\nFind out whether name is registered. Return the actor link  lk or missing if not found.\n\n\n\n\n\n","category":"function"},{"location":"api/registry/#Actors.registered","page":"Actor Registry","title":"Actors.registered","text":"registered()\n\nReturn an Array of all registered actors in the system.\n\n\n\n\n\n","category":"function"},{"location":"api/registry/","page":"Actor Registry","title":"Actor Registry","text":"The registry works transparently over distributed worker processes such that local links are transformed to remote links when shared between workers.","category":"page"},{"location":"tutorial/supervise/#Supervise-Actors","page":"Supervise Actors","title":"Supervise Actors","text":"","category":"section"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"CurrentModule = Actors","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"A supervisor is an actor looking after child actors and restarting them as necessary when they exit.","category":"page"},{"location":"tutorial/supervise/#Setup-a-supervisor","page":"Supervise Actors","title":"Setup a supervisor","text":"","category":"section"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"We setup a supervisor A10 with the default supervision strategy :one_by_one:","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"julia> using Actor, .Threads\n\njulia> import Actors: spawn\n\njulia> A10 = supervisor()\nLink{Channel{Any}}(Channel{Any}(32), 1, :supervisor)","category":"page"},{"location":"tutorial/supervise/#Supervise-child-actors","page":"Supervise Actors","title":"Supervise child actors","text":"","category":"section"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"We start six actors A1-A6 and supervise them with A10 with default restart arguments. If they fail, they will be restarted with their threadid behavior and  are assumed to be :transient (they get restarted if they terminate abnormally).","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"julia> A = map(_->spawn(threadid), 1:6);    # spawn A1 - A6\n\njulia> t = map(a->Actors.diag(a, :task), A) # A1 - A6 are running\n6-element Vector{Task}:\n Task (runnable) @0x000000016e948560\n Task (runnable) @0x000000016e949660\n Task (runnable) @0x000000016e949880\n Task (runnable) @0x000000016e949bb0\n Task (runnable) @0x000000016e949ee0\n Task (runnable) @0x000000016e94a100\n\njulia> foreach(a->exec(a, supervise, A10), A)","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"One for one: With the default supervision strategy :one_for_one the supervisor restarts a single actor when it fails:","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"julia> send(A[4], :boom);                   # let A4 fail\n┌ Warning: 2021-02-13 12:55:27 x-d-kuhub-dabab: Exit: supervised Task (failed) @0x000000016e949bb0, MethodError(Base.Threads.threadid, (:boom,), 0x0000000000007458)\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n┌ Warning: 2021-02-13 12:55:27 x-d-kuhub-dabab: supervisor: restarting\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n\njulia> t = map(a->Actors.diag(a, :task), A) # look at the tasks\n6-element Vector{Task}:\n Task (runnable) @0x000000016e948560\n Task (runnable) @0x000000016e949660\n Task (runnable) @0x000000016e949880\n Task (runnable) @0x000000010e3b8230\n Task (runnable) @0x000000016e949ee0\n Task (runnable) @0x000000016e94a100","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"A1-A6 have all runnable tasks, but A4 has been restarted.","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"One for all: With the second strategy :one_for_all, all supervised actors/tasks get restarted if one of them fails. That allows to restart a group of equitable actors depending on each other. Normally we would choose the strategy at supervisor start, but now we change the supervision strategy of the running supervisor A10 and let A4 fail again:","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"julia> set_strategy(A10, :one_for_all)      # change restart strategy\n(Actors.Strategy(:one_for_all),)\n\njulia> send(A[4], :boom);                   # let A4 fail again\n┌ Warning: 2021-02-13 12:57:16 x-d-kuhub-dabab: Exit: supervised Task (failed) @0x000000010e3b8230, MethodError(Base.Threads.threadid, (:boom,), 0x0000000000007459)\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n┌ Warning: 2021-02-13 12:57:16 x-d-kuhub-dabab: supervisor: restarting all\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n\njulia> t = map(a->Actors.diag(a, :task), A)\n6-element Vector{Task}:\n Task (runnable) @0x000000010e3b8450\n Task (runnable) @0x000000010e3b8670\n Task (runnable) @0x000000010e3b8890\n Task (runnable) @0x000000010e3b8ab0\n Task (runnable) @0x000000010e3b8cd0\n Task (runnable) @0x000000010e3b9000","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"All actors have been restarted (got new tasks).","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"Rest for one: With :rest_for_one only the failed actor and the actors that registered for supervision after it are restarted. That allows to restart a failed actor and only those other actors depending on it. Again we change A10's strategy and let A4 fail:","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"julia> set_strategy(A10, :rest_for_one)     # change strategy again\n(Actors.Strategy(:rest_for_one),)\n\njulia> send(A[4], :boom);                   # let A4 fail\n┌ Warning: 2021-02-13 12:58:33 x-d-kuhub-dabab: Exit: supervised Task (failed) @0x000000010e3b8ab0, MethodError(Base.Threads.threadid, (:boom,), 0x000000000000745a)\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n┌ Warning: 2021-02-13 12:58:33 x-d-kuhub-dabab: supervisor: restarting rest\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:31\n\njulia> t = map(a->Actors.diag(a, :task), A)\n6-element Vector{Task}:\n Task (runnable) @0x000000010e3b8450\n Task (runnable) @0x000000010e3b8670\n Task (runnable) @0x000000010e3b8890\n Task (runnable) @0x000000010e3b9220\n Task (runnable) @0x000000010e3b9440\n Task (runnable) @0x000000010e3b9770","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"Now A4 - A6 have been restarted.","category":"page"},{"location":"tutorial/supervise/#Further-options","page":"Supervise Actors","title":"Further options","text":"","category":"section"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"With further supervisor options we can limit how often a supervisor tries to restart children in a given timeframe. If it exceeds this limit, it terminates itself and all of its children with a warning.","category":"page"},{"location":"tutorial/supervise/#Query-failed-actors","page":"Supervise Actors","title":"Query failed actors","text":"","category":"section"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"For all failures we got warnings, but we can query the last failures from the supervisor and get more information about them:","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"julia> failed = Actors.diag(A10, :err)      # the three failed tasks can be queried from the supervisor\n3-element Vector{Task}:\n Task (failed) @0x000000016e949bb0\n Task (failed) @0x000000010e3b8230\n Task (failed) @0x000000010e3b8ab0\n\njulia> failed[1]                            # exceptions and stacktraces are available\nTask (failed) @0x000000016e949bb0\nMethodError: no method matching threadid(::Symbol)\n....","category":"page"},{"location":"tutorial/supervise/#Maintain-actor-state-across-restarts","page":"Supervise Actors","title":"Maintain actor state across restarts","text":"","category":"section"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"By default a supervisor restarts an actor with the behavior it had before exiting. An actor thus maintains its state over a restart:","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"julia> sv = supervisor()\nLink{Channel{Any}}(Channel{Any}(32), 1, :supervisor)\n\njulia> incr(xr, by=0) = xr[] += by        # define an accumulator\nincr (generic function with 2 methods)\n\njulia> myactor = spawn(incr, Ref(10))     # start an actor accumulating from 10\nLink{Channel{Any}}(Channel{Any}(32), 1, :default)\n\njulia> exec(myactor, supervise, sv);      # put it under supervision\n\njulia> foreach(x->call(myactor, x), 1:10) # accumulate it\n\njulia> call(myactor)\n65\n\njulia> send(myactor, :boom);              # let it fail\n┌ Warning: 2021-04-19 17:00:17 x-d-kolok-ib Exit: supervised Task (failed) @0x000000016b9d4010, MethodError(+, (65, :boom), 0x00000000000074aa)\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:39\n┌ Warning: 2021-04-19 17:00:17 x-d-kolok-ib supervisor: restarting\n└ @ Actors ~/.julia/dev/Actors/src/logging.jl:39\n\njulia> call(myactor)\n65\n\njulia> info(myactor)\nActor    default\nBehavior incr\nPid      1, Thread 1\nTask     @0x000000016da2ba80\nIdent    x-d-kukof-ropab","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"myactor has maintained its state over failure even if it got a new task.","category":"page"},{"location":"tutorial/supervise/","page":"Supervise Actors","title":"Supervise Actors","text":"note: Actor state recovery after node failures is different!\nIn case of a node failure an actor cannot send its state at failure time to the supervisor. In those cases you can use termination and restart callbacks and checkpointing for recovery.","category":"page"},{"location":"api/diagnosis/#Diagnosis","page":"Diagnosis","title":"Diagnosis","text":"","category":"section"},{"location":"api/diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"CurrentModule = Actors","category":"page"},{"location":"api/diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"diag","category":"page"},{"location":"api/diagnosis/#Actors.diag","page":"Diagnosis","title":"Actors.diag","text":"diag(lk::Link, check::Symbol=:state)\ndiag(name::Symbol, ....)\n\nDiagnose an actor, get a state or stacktrace.\n\nArguments\n\nlk::Link: actor link,\ncheck::Symbol: requested information,\n\n- `:state`: returns `:ok` if the actor is running, \n- `:task`: returns the current actor task,\n- `:tid`: current actor task encoded as a proquint string,\n- `:pid`: process identifier number,\n- `:act`: actor `_ACT` variable,\n- `:info`: actor [`Info`](@ref),\n- `:err`: error log (only monitors or supervisors).\n\nwarning: This is for diagnosis only!\nModifying an actor's state can cause a race condition.\n\n\n\n\n\n","category":"function"},{"location":"reference/interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"CurrentModule = Actors","category":"page"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"warning: The interface is yet experimental!\nMost of the following needs yet work .","category":"page"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"Actors provides a versatile interface to work with other actor libraries in the JuliaActors ecosystem or to allow programmers and users alike to extend its functionality:","category":"page"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"It is written against ActorInterfaces.Classic. Thus it can execute programs written with the primitives in that interface.\nActors from other libraries written with that interface have actor level compatibility. Thus they can exchange messages, use the Actors registry (and upcoming supervision).\nOther libraries written against that interface can plugin the Actors' onmessage protocol and thus inherit the user API functions: call, cast ...\nOther party libraries can start actors in another mode and implement a different onmessage protocol to make their actors do different things.\nUsers can enhance the implemented Msg types and extend the onmessage methods for working with those messages.","category":"page"},{"location":"reference/interface/#Reimplementing-Actor-Primitives","page":"Interface","title":"Reimplementing Actor Primitives","text":"","category":"section"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"On JuliaActors there is a companion library SlowActors to illustrate one use of the interface. This is a completely different implementation of the Actor Model. It doesn't use Julia Channels for message passing and operates without an actor loop. Rather each time a message to a \"slow\" actor is sent, an actor Task is started.","category":"page"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"But in using the common Link type, actors from both libraries can communicate. With actually few lines of code SlowActors plugs in the Actors interface and is able to run the identical examples. It actually only reimplements three primitives: spawn, newLink and send!.","category":"page"},{"location":"reference/interface/#Change-Actor-Mode-and-Behavior","page":"Interface","title":"Change Actor Mode and Behavior","text":"","category":"section"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"Actors provides a mode field in both Link and _ACT, with mode=:default for normal operation.","category":"page"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"Other libraries can spawn their actors with a different mode, e.g. mode=:GenServer. If they then enhance onmessage with e.g.","category":"page"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"Actors.onmessage(A::_ACT, ::Val{:GenServer}, msg::Call) = ...\nActors.onmessage(A::_ACT, ::Val{:GenServer}, msg::Cast) = ...\n....","category":"page"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"... they get for those messages a different actor behavior where they can do callbacks or set state or whatever they want to. Actors spawned with a different mode return a link with the mode field set accordingly.","category":"page"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"Currently there are two libraries capitalizing on this functionality:","category":"page"},{"location":"reference/interface/","page":"Interface","title":"Interface","text":"library brief description\nGuards Actors guarding access to mutable variables.\nGenServers Actors representing generic servers and allowing users to write sequential code to use them.","category":"page"},{"location":"examples/prod_cons/#Producer-Consumer-Problem","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"","category":"section"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"This classic problem describes producers and consumers sharing a buffer with a given capacity. A producer produces an item at a time, puts it into the buffer and starts again. At the same time consumers are consuming the items (i.e. removing them from the buffer). The problem ist to make sure that a producer won't add items to the buffer if it is full and that a consumer won't try to remove them from an empty buffer. ","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"The solution for a producer is to go to sleep if the buffer is full. The next time, a consumer removes an item from the buffer, the buffer notifies the stalled producer, who then starts to replenish the buffer again. In the same way, the consumer can go to waiting if it finds the buffer empty. The next time a producer delivers an item, the buffer notifies the waiting consumer.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"We implement this problem with three kinds of actors for store, producer and consumer.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"The store has a fixed capacity, holds items and queues of stalled producers and waiting customers and a counting variable.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"# examples/prod_cons.jl\n\nusing Actors, Printf\nimport Actors: spawn\n\nconst maxitems = 10\n\nmutable struct Store\n    capacity::Int\n    items::Array{Any,1}\n    prod::Array{Link,1}\n    cons::Array{Link,1}\n    count::Int\n    Store(capacity::Int) = new(capacity, Any[], Link[], Link[], 0)\nend\n\navailable(s::Store) = 0 < length(s.items) < s.capacity\nisfull(s::Store) = length(s.items) ≥ s.capacity\nBase.isempty(s::Store) = isempty(s.items)","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"We implement the store's behavior as a function object receiving two messages Put() and Take().","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"@msg Put Full Done Ok Take Empty Notify\n\nfunction (s::Store)(::Put, prod, item)\n    if isfull(s)\n        send(prod, Full(), item)\n        push!(s.prod, prod)\n    elseif s.count < maxitems\n        push!(s.items, item)\n        s.count += 1\n        s.count == maxitems ?\n            send(prod, Done()) :\n            send(prod, Ok(), item)\n        !isempty(s.cons) && send(popfirst!(s.cons), Notify())\n    else\n        send(prod, Done())\n    end\nend\nfunction (s::Store)(::Take, cons)\n    if isempty(s)\n        send(cons, Empty())\n        push!(s.cons, cons)\n    else\n        send(cons, popfirst!(s.items))\n        !isempty(s.prod) && send(popfirst!(s.prod), Notify())\n    end\nend","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Producers and consumers have a name and a link to the store:","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"struct Prod\n    name::String\n    store::Link\nend\n\nstruct Cons\n    name::String\n    store::Link\nend","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Those are acquaintances of their behavior functions. We have also a print server actor prn as a global variable.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"function prod_start(p::Prod, start)\n    become(producing, p)\n    send(self(), start+1)\n    send(prn, \"producer $(p.name) started\")\nend\nfunction producing(p::Prod, item)\n    sleep(rand())\n    send(p.store, Put(), self(), item)\nend\nfunction producing(p::Prod, ::Ok, item)\n    send(prn, \"producer $(p.name) delivered item $item\")\n    send(self(), item+1)\nend\nfunction producing(p::Prod, ::Full, item)\n    send(prn, \"producer $(p.name) stalled with item $item\")\n    become(stalled, p, item)\nend\nfunction producing(p::Prod, ::Done)\n    send(prn, \"producer $(p.name) done\")\n    stop()\nend\nfunction stalled(p::Prod, item, ::Notify)\n    send(p.store, Put(), self(), item)\n    become(producing, p)\nend\n\nfunction cons_start(c::Cons)\n    become(buying, c)\n    send(c.store, Take(), self())\n    send(prn, \"consumer $(c.name) started\")\nend\nfunction buying(c::Cons, item)\n    become(consuming)\n    send(self(), c)\n    send(prn, \"consumer $(c.name) got item $item\")\nend\nfunction buying(c::Cons, ::Empty)\n    become(waiting, c)\n    send(prn, \"consumer $(c.name) found store empty\")\nend\nfunction consuming(c)\n    sleep(rand())\n    become(buying, c)\n    send(c.store, Take(), self())\nend\nfunction waiting(c::Cons, ::Notify)\n    become(buying, c)\n    send(c.store, Take(), self())\nend","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Finally we start the simulation with a print server, a store, three producers and two consumers.","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"prn = spawn(s->print(@sprintf(\"%s\\n\", s)))\nst = spawn(Store(5))\npr1 = spawn(prod_start, Prod(\"A\", st), 100)\npr2 = spawn(prod_start, Prod(\"B\", st), 200)\npr3 = spawn(prod_start, Prod(\"C\", st), 300)\ncs1 = spawn(cons_start, Cons(\"U\", st))\ncs2 = spawn(cons_start, Cons(\"V\", st))\n\nforeach(x->send(x), (pr1,pr2,pr3,cs1,cs2))","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"Let's see, what happens:","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"julia> include(\"examples/prod_cons.jl\")\n\njulia> producer A started\nconsumer U started\nproducer C started\nproducer B started\nconsumer V started\nconsumer V found store empty\nconsumer U found store empty\nproducer A delivered item 101\nconsumer U got item 101\nproducer B delivered item 201\nconsumer V got item 201\nproducer C delivered item 301\nconsumer V got item 301\nconsumer U found store empty\nproducer C delivered item 302\nconsumer U got item 302\nproducer B delivered item 202\nproducer C delivered item 303\nproducer B delivered item 203\nproducer A delivered item 102\nproducer A delivered item 103\nconsumer U got item 202\nconsumer V got item 303\nproducer A done\nconsumer V got item 203\nproducer C done\nproducer B done\nconsumer V got item 102\nconsumer U got item 103\nconsumer V got item 104\nconsumer U found store empty\nconsumer V found store empty","category":"page"},{"location":"examples/prod_cons/","page":"Producer-Consumer Problem","title":"Producer-Consumer Problem","text":"We had limited the sold items to 10. This is a queueing process.","category":"page"},{"location":"howto/information/#How-to-get-information","page":"get information from actors","title":"How to get information","text":"","category":"section"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"CurrentModule = Actors","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"Actors are implemented as Julia Tasks running asynchronously and are represented by a messaging Link to them or by a registered name.","category":"page"},{"location":"howto/information/#about-an-actor","page":"get information from actors","title":"about an actor","text":"","category":"section"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"You can use an actor's link (or its registered name) to get information about it:","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"julia> using Actors\n\njulia> import Actors: spawn\n\njulia> myBehavior(lk, f, args...) = send(lk, f(args...))\nmyBehavior (generic function with 1 method)\n\njulia> me = newLink()\nLink{Channel{Any}}(Channel{Any}(32), 1, :local)\n\njulia> myactor = spawn(myBehavior, me)\nLink{Channel{Any}}(Channel{Any}(32), 1, :default)\n\njulia> info(myactor)\nActor    default\nBehavior myBehavior\nPid      1, Thread 1\nTask     @0x000000010d944230\nIdent    x-d-ukih-hamub","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"info gives you some information about your actor. The system will on each worker pid identify an actor as a Julia Task. In order make it better identifiable for a human, the task address is also given as a Proquint identifier:","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"julia> using Proquint\n\njulia> quint2uint(\"x-d-ukih-hamub\")\n0x000000010d944230\n\njulia> info(myactor).task\n0x000000010d944230","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"If you register an actor, you can use its registered name to get the information. Then info will show also the actor's name:","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"julia> register(:myname, myactor)\ntrue\n\njulia> info(:myname)\nActor    default\nBehavior myBehavior\nPid      1, Thread 1\nTask     @0x000000010d944230\nIdent    x-d-ukih-hamub\nName     myname","category":"page"},{"location":"howto/information/#about-the-actor's-task","page":"get information from actors","title":"about the actor's task","text":"","category":"section"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"There are two ways to get the Task variable from an actor:","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"you spawn it with a taskref keyword argument or\nyou use Actors.diag.","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"julia> t = Ref(Actors.diag(myactor, :task))\nBase.RefValue{Task}(Task (runnable) @0x000000010d944230)\n\njulia> t[]\nTask (runnable) @0x000000010d944230","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"Note: if an actor is on a worker process (pid > 1), you cannot get access to its Task. Instead you will get a string representation of it.","category":"page"},{"location":"howto/information/#about-a-failed-actor","page":"get information from actors","title":"about a failed actor","text":"","category":"section"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"If an actor fails, info will return the failed Task, which shows a clickable stack-trace in the REPL:","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"julia> send(myactor, :boom)\n(:boom,)\n\njulia> info(myactor)\nTask (failed) @0x000000010d944230\nMethodError: objects of type Symbol are not callable\nStacktrace:\n [1] myBehavior(::Link{Channel{Any}}, ::Symbol)\n....\n\njulia> typeof(ans)\nTask","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"We can get the same information from the Ref{Task}-variable, we created earlier:","category":"page"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"julia> t\nBase.RefValue{Task}(Task (failed) @0x000000010d944230)\n\njulia> t[]\nTask (failed) @0x000000010d944230\nMethodError: objects of type Symbol are not callable\nStacktrace:\n [1] myBehavior(::Link{Channel{Any}}, ::Symbol)\n....","category":"page"},{"location":"howto/information/#about-actor-state","page":"get information from actors","title":"about actor state","text":"","category":"section"},{"location":"howto/information/","page":"get information from actors","title":"get information from actors","text":"For diagnostic purposes it is possible to get access to an actor's state by using Actors.diag. See also Diagnostics.","category":"page"},{"location":"manual/protocol/#Messaging-Protocol","page":"Messaging Protocol","title":"Messaging Protocol","text":"","category":"section"},{"location":"manual/protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"CurrentModule = Actors","category":"page"},{"location":"manual/protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Actors has predefined message types with respective onmessage methods. This gives your actors predefined behaviors going beyond the classical behavior.","category":"page"},{"location":"manual/protocol/#Messaging-Patterns","page":"Messaging Protocol","title":"Messaging Patterns","text":"","category":"section"},{"location":"manual/protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"The actor protocol can be described as a series of messaging patterns. For every predefined message an actor executes a predefined onmessage method. Here is an overview:","category":"page"},{"location":"manual/protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Message pattern brief description\nBecome Tell an actor to change its behavior.\nCall - Response Call an actor to execute its behavior and to respond with the result.\nDiag - Response Call an actor to respond with diagnostic information.\nDown A message to a monitor actor signaling an exit or a failure.\nExit A message causing an actor to exit.\nExec - Response Call an actor to execute a function and to respond with the result.\nInit Tell an actor to execute an initialization function and to store it in its internal state.\nQuery - Response Call an actor to send a status variable/value.\nRequest This triggers the actor's default response to execute its behavior.\nTerm Tell an actor to execute a given behavior upon termination.","category":"page"},{"location":"manual/protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"There are messages for bidirectional and unidirectional communication (the latter for actor control without response).","category":"page"},{"location":"manual/protocol/#User-API-Functions","page":"Messaging Protocol","title":"User API Functions","text":"","category":"section"},{"location":"manual/protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Actors' user API functions provide an interface to those message patterns. ","category":"page"},{"location":"manual/protocol/#Enhancing-the-Protocol","page":"Messaging Protocol","title":"Enhancing the Protocol","text":"","category":"section"},{"location":"manual/protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"The Actors protocol can be enhanced or altered by","category":"page"},{"location":"manual/protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"introducing new messages and onmessage methods,\nswitching the actor mode and writing new onmessage methods for existing messages\nor both.","category":"page"},{"location":"manual/protocol/","page":"Messaging Protocol","title":"Messaging Protocol","text":"Libraries can do this for specific duties and plugin their protocols into Actors. Examples of such libraries are GenServers and Guards.","category":"page"},{"location":"api/primitives/#Actor-Primitives","page":"Actor Primitives","title":"Actor Primitives","text":"","category":"section"},{"location":"api/primitives/","page":"Actor Primitives","title":"Actor Primitives","text":"CurrentModule = Actors","category":"page"},{"location":"api/primitives/","page":"Actor Primitives","title":"Actor Primitives","text":"The following primitives characterize actors in the classical Actor Model:","category":"page"},{"location":"api/primitives/","page":"Actor Primitives","title":"Actor Primitives","text":"Primitive Brief description\nself get the address of the current actor,\nspawn create an actor from a behavior and return an address,\nsend send a message to an actor,\nbecome an actor designates a new behavior,","category":"page"},{"location":"api/primitives/#Functions","page":"Actor Primitives","title":"Functions","text":"","category":"section"},{"location":"api/primitives/","page":"Actor Primitives","title":"Actor Primitives","text":"send\nbecome!\nbecome\nself\nstop","category":"page"},{"location":"api/primitives/#ActorInterfaces.Classic.send","page":"Actor Primitives","title":"ActorInterfaces.Classic.send","text":"send(lk::Link, msg...)\n\nSend a message to an actor. msg... are communication parameters to the actor's behavior function.\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#Actors.become!","page":"Actor Primitives","title":"Actors.become!","text":"become!(lk::Link, func, args1...; kwargs...)\nbecome!(name::Symbol, ....)\n\nCause an actor to change behavior.\n\nArguments\n\nactor lk::Link (or name::Symbol if registered),\nfunc: a callable object,\nargs1...: (partial) arguments to func,\nkwargs...: keyword arguments to func.\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#ActorInterfaces.Classic.become","page":"Actor Primitives","title":"ActorInterfaces.Classic.become","text":"become(func, args...; kwargs...)\n\nCause your actor to take on a new behavior. This can only be called from inside an actor/behavior.\n\nArguments\n\nfunc: a callable object,\nargs...: (partial) arguments to func,\nkwargs...: keyword arguments to func.\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#ActorInterfaces.Classic.self","page":"Actor Primitives","title":"ActorInterfaces.Classic.self","text":"self()\n\nGet the Link of your actor.\n\n\n\n\n\n","category":"function"},{"location":"api/primitives/#Actors.stop","page":"Actor Primitives","title":"Actors.stop","text":"stop(reason=:normal)\n\nCause your actor to stop with a reason.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"CurrentModule = Actors","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"tid","category":"page"},{"location":"api/utils/#Actors.tid","page":"Utilities","title":"Actors.tid","text":"tid(n::Int)\n\nReturn a threadid where an n-th calculation could run.\n\nThis is for emulating a @threads for loop with actors.\n\n\n\n\n\n","category":"function"},{"location":"manual/behaviors/#Actor-Behavior","page":"Actor Behavior","title":"Actor Behavior","text":"","category":"section"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"CurrentModule = Actors","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"An actor embodies the three essential elements of computation: 1) processing, 2) storage and 3) communication[1]. Its behavior therefore can be described as f(a)c,  representing","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"f: a function, processing,\na: acquaintances, storage, data that it has,\nc: communication, a message.","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"It processes an incoming message c with its behavior function f based on its acquaintances a.","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"When an Actor receives a message, it can concurrently:send messages to ... addresses of Actors that it has;\ncreate new Actors;\ndesignate how to handle the next message it receives. [2]","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Gul Agha described the behavior as a ...","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"... function of the incoming communication.Two lists of identifiers are used in a behavior definition. Values for the first list of parameters must be specified when the actor is created. This list is called the acquaintance list. The second list of parameters, called the communication list, gets its bindings from an incoming communication. [3]","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"A behavior then maps the incoming communication to a three tuple of messages sent, new actors created and the replacement behavior:","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"beginarraylrl\nf_i(a_i)c_i  rightarrow mu_umu_v alpha_xalpha_yf_i+1(a_i+1) quad\ntextrmwith  f  textrmbehavior function \n  a  textrmacquaintances \n  c  textrmcommunication \n  mu  textrmmessages sent \n  alpha  textrmactors created \nendarray","category":"page"},{"location":"manual/behaviors/#Behavior-Representation-in-Julia","page":"Actor Behavior","title":"Behavior Representation in Julia","text":"","category":"section"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Actors expresses actor behavior in a functional style. Actors are basically function servers. Their behavior is a partial application of a callable object f(ac) to acquaintances a, that is, a closure over f(a). If the actor receives a communication c, the closure invokes f(ac). The ...-operator allows us to use multiple acquaintance and communication arguments (i.e. lists).","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"f(a, c) = a + c         # define a function\npartial(f, a...; kw...) = (c...) -> f(a..., c...; kw...)\nbhv = partial(f, 1)     # partially apply f to 1, return a closure\nbhv(2)                  # execute f(1,2)","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Similar to the partial above, Bhv is a convenience function to create a partial application ϕ(a...; kw...) with optional keyword arguments, which can be executed with communication arguments c...:","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"using Actors, .Threads\nimport Actors: spawn, newLink\nf(s, t; w=1, x=1) = s + t + w + x   # a function\nbhv = Bhv(f, 2, w=2, x=2);          # create a behavior of f and acquaintances\nbhv(2)                              # execute it with a communication parameter","category":"page"},{"location":"manual/behaviors/#Object-oriented-Style","page":"Actor Behavior","title":"Object-oriented Style","text":"","category":"section"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Alternatively we define an object with some data (acquaintances) and make it callable with communication parameters:","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"struct A                            # define an object \n    s; w; x                         # with acquaintances\nend\n(a::A)(t) = a.s + a.w + a.x + t     # make it a functor, executable with a communication parameter t\nbhv = A(2, 2, 2)                    # create an instance\nbhv(2)                              # execute it with a parameter","category":"page"},{"location":"manual/behaviors/#Actor-Operation","page":"Actor Behavior","title":"Actor Operation","text":"","category":"section"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"When we create an actor with a behavior by using spawn, it is ready to receive communication arguments and to process them:","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"You can create an actor with anything callable as behavior regardless whether it contains acquaintances or not.\nOver its Link you can send it communication arguments and cause the actor to execute its behavior with them. Actors' API functions like call, exec are just wrappers around send and receive using a communication protocol.\nIf an actor receives wrong/unspecified communication arguments, it will fail with a MethodError.\nWith become! and become we can change an actor's behavior.","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"me = newLink()\nmyactor = spawn(()->send(me, threadid()),thrd=2) # create an actor with a parameterless anonymous behavior function\nsend(myactor)                                    # send it an empty tuple\nreceive(me)                                      # receive the result\nbecome!(myactor, threadid)\ncall(myactor)                                    # call it without arguments\nbecome!(myactor, (lk, x, y) -> send(lk, x^y))    # an anonymous function with communication arguments\nsend(myactor, me, 123, 456)                      # send it arguments\nreceive(me)                                      # receive the result","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"In setting actor behavior you are free to mix the functional and object oriented approaches. For example you can give functors further acquaintance parameters (as for the players in the table-tennis example). Of course you can give objects containing acquaintances as parameters to a function and create a partial application with Bhv on them and much more.","category":"page"},{"location":"manual/behaviors/#Actors-Don't-Share-State","page":"Actor Behavior","title":"Actors Don't Share State","text":"","category":"section"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Actors must not share state in order to avoid race conditions. Acquaintance and communication parameters are actor state. Actors does not disallow for an actor to access and to modify mutable variables. It is therefore left to the programmer to exclude race conditions by not sharing them with other actors or tasks and accessing them concurrently. In most cases you can control which variables get passed to an actor and avoid to share them.","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"Note that when working with distributed actors, variables get copied automatically when sent over a Link (a RemoteChannel).","category":"page"},{"location":"manual/behaviors/#Share-Actors-Instead-Of-Memory","page":"Actor Behavior","title":"Share Actors Instead Of Memory","text":"","category":"section"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"But in many cases you want actors or tasks to concurrently use the same variables. You can then thread-safely model those as actors and share their links between actors and tasks alike. Each call to a link is a communication to an actor (instead of a concurrent access to a variable). See How to (not) share variables for a receipt.","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"In the Actors documentation there are many examples on how actors represent variables and get shared between actors and tasks:","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"In the table-tennis example player actors working on different threads share a print server actor controlling access to the stdio variable.\nIn the Dict-server example a Dict variable gets served by an actor to tasks on parallel threads or workers.\nIn the Dining Philosophers problem the shared chopsticks are expressed as actors. This avoids races and starvation between the philosopher actors.\nIn the Producer-Consumer problem producers and consumers share a buffer modeled as an actor.\nYou can wrap mutable variables into a :guard actor, which will manage access to them.\nIn more complicated cases of resource sharing you can use a :genserver actor.","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"To model concurrently shared objects or data as actors is a common and successful pattern in actor programming. It makes it easier to write clear, correct concurrent programs. Unlike common tasks or also shared variables, actors are particularly suitable for this modeling because","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"they are persistent objects like the variables or objects they represent and\nthey can express a behavior of those objects.","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"[1]: Hewitt, Meijer and Szyperski: The Actor Model (everything you wanted to know, but were afraid to ask), Microsoft Channel 9. April 9, 2012.","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"[2]: Carl Hewitt. Actor Model of Computation: Scalable Robust Information Systems.- arXiv:1008.1459.","category":"page"},{"location":"manual/behaviors/","page":"Actor Behavior","title":"Actor Behavior","text":"[3]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT.- p. 30","category":"page"},{"location":"api/monitor/#Monitors","page":"Monitors","title":"Monitors","text":"","category":"section"},{"location":"api/monitor/","page":"Monitors","title":"Monitors","text":"CurrentModule = Actors","category":"page"},{"location":"api/monitor/","page":"Monitors","title":"Monitors","text":"Actors can warn or take actions if their monitored actors or tasks terminate.","category":"page"},{"location":"api/monitor/","page":"Monitors","title":"Monitors","text":"monitor\ndemonitor","category":"page"},{"location":"api/monitor/#Actors.monitor","page":"Monitors","title":"Actors.monitor","text":"monitor(lk::Link, onsignal...)\nmonitor(t::Task, onsignal...; timeout::Real=5.0, pollint::Real=0.1)\n\nStart monitoring the actor represented by lk or the task t and execute onsignal... if it sends Down or if it fails.\n\nParameters\n\nonsignal...: action to take on Down signal: \nif empty, it gives a warning; \nif it is one argument f, it executes with  f(msg.reason); \nif f, args..., it gets executed with  f(args..., msg.reason).\ntimeout::Real=5.0: how many seconds should a task    be monitored? After that a Down with   reason :timed_out is sent.\npollint::Real=0.1: polling interval in seconds for   task monitoring.\n\n\n\n\n\n","category":"function"},{"location":"api/monitor/#Actors.demonitor","page":"Monitors","title":"Actors.demonitor","text":"demonitor(lk::Link)\n\nRemove the monitoring for the given link lk.\n\n\n\n\n\n","category":"function"},{"location":"manual/actors/#Actors-and-Julia","page":"Actors and Julia","title":"Actors and Julia","text":"","category":"section"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"CurrentModule = Actors","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"In one of his later papers (2010) Carl Hewitt wrote:","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"It is important to distinguish the following:modeling arbitrary computational systems using Actors. It is difficult to find physical computational systems (regardless of how idiosyncratic) that cannot be modeled using Actors.\nsecurely implementing practical computational applications using Actors remains an active area of research and development. [1]","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"We focus on the second point, namely on practical computational applications.","category":"page"},{"location":"manual/actors/#Julia-is-Well-Suited-for-Actors","page":"Actors and Julia","title":"Julia is Well Suited for Actors","text":"","category":"section"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors uses Julia's Tasks to execute functions concurrently and Channels to let them communicate. An actor has a Julia function or callable object as behavior. That gets parametrized with the arguments given to the actor at startup (acquaintances). The other arguments are delivered via messages (communication). Then an actor executes its behavior. Actors incorporate processing, storage and communication. Functions thus become responsive and composable in new ways.","category":"page"},{"location":"manual/actors/#Actors-Complement-Julia","page":"Actors and Julia","title":"Actors Complement Julia","text":"","category":"section"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors give Julia users additional ways to deal with concurrency. Sutter and Larus justified that as follows:","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"We need higher-level language abstractions, including evolutionary extensions to current imperative languages, so that existing applications can incrementally become concurrent. The programming model must make concurrency easy to understand and reason about, not only during initial development but also during maintenance. [2]","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors support clear, correct concurrent programs and are an alternative to sharing memory in concurrent computing:","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Share by communicating [3] to functions and\nuse functions to localize variables and\nmake actors serve mutable variables without using locks.","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"You can use actors in common multi-threading or distributed Julia code.","category":"page"},{"location":"manual/actors/#Multi-threading","page":"Actors and Julia","title":"Multi-threading","text":"","category":"section"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Julia's manual encourages the use of locks [4] in order to ensure data-race freedom. But be aware that","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"they are not composable. You can’t take two correct lock-based pieces of code, combine them, and know that the result is still correct. Modern software development relies on the ability to compose libraries into larger programs, and so it is a serious difficulty that we cannot build on lock-based components without examining their implementations. [5]","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"An actor controlling the access to a variable or to another resource is lock-free and there are no limits to composability. Therefore if you write multi-threaded programs which should be composable or maybe used by other programs within a lock, you might consider using Actors.","category":"page"},{"location":"manual/actors/#Distributed-Computing","page":"Actors and Julia","title":"Distributed Computing","text":"","category":"section"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors are location transparent. You can share their links across workers to access the same actor on different workers. If local links are sent to a remote actor, they are automatically converted to remote links.","category":"page"},{"location":"manual/actors/#Fault-Tolerance","page":"Actors and Julia","title":"Fault Tolerance","text":"","category":"section"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors provides explicit methods for fault tolerant computing used mainly in telecommunications and internet services with Erlang/OTP [6]:","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"group actors and force them to fail together,\nmonitor tasks and actors and take action if they fail or time out,\nsupervise tasks and actors and restart them if a failure occurs.","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Based on that checkpoint and restore as used for  fault-tolerance in high performance computing (HPC) can be implemented.","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"note: This is currently work in progress!\nThose features should be considered experimental!","category":"page"},{"location":"manual/actors/#Actor-Isolation","page":"Actors and Julia","title":"Actor Isolation","text":"","category":"section"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"In order to avoid race conditions actors have to be strongly isolated from each other:","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"they do not share state,\nthey must not share mutable variables.","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"An actor stores the behavior function and arguments to it, results of computations and more. Thus it has state and this influences how it behaves.","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"But it does not share its state variables with its environment (only for diagnostic purposes). The user API functions functions are a safe way to access actor state via messaging.","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Mutable variables in Julia can be sent over local channels without being copied. Accessing those variables from multiple threads can cause race conditions. The programmer has to be careful to avoid those situations either by","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"not sharing them between actors,\ncopying them when sending them to actors or\nrepresenting them by an actor.","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"When sending mutable variables over remote links, they are automatically copied.","category":"page"},{"location":"manual/actors/#Actor-Local-Dictionary","page":"Actors and Julia","title":"Actor Local Dictionary","text":"","category":"section"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Since actors are Julia tasks, they have a local dictionary in which you can store values. You can use task_local_storage to access it in behavior functions. But normally argument passing should be enough to handle values in actors.","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[1]: Carl Hewitt. Actor Model of Computation: Scalable Robust Information Systems.- arXiv:1008.1459","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[2]: H. Sutter and J. Larus. Software and the concurrency revolution. ACM Queue, 3(7), 2005.","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[3]: \"Do not communicate by sharing memory; instead, share memory by communicating.\" see Effective Go: Share by Communicating","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[4]: see Data race freedom in the Julia manual.","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[5]: H. Sutter and J. Larus. see above","category":"page"},{"location":"manual/actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[6]: see Joe Armstrong, 2003: Making reliable distributed systems in the presence of software errors","category":"page"},{"location":"api/starting/#Starting-Actors,-creating-links","page":"Starting Actors, creating links","title":"Starting Actors, creating links","text":"","category":"section"},{"location":"api/starting/","page":"Starting Actors, creating links","title":"Starting Actors, creating links","text":"CurrentModule = Actors","category":"page"},{"location":"api/starting/","page":"Starting Actors, creating links","title":"Starting Actors, creating links","text":"Actors.jl doesn't export its functions to start actors and to create links. Thus other libraries building on it can implement their own actors and links.","category":"page"},{"location":"api/starting/","page":"Starting Actors, creating links","title":"Starting Actors, creating links","text":"To use Actors's actors and links you import them explicitly:","category":"page"},{"location":"api/starting/","page":"Starting Actors, creating links","title":"Starting Actors, creating links","text":"using Actors\nimport Actors: spawn, newLink","category":"page"},{"location":"api/starting/","page":"Starting Actors, creating links","title":"Starting Actors, creating links","text":"Then you can create them with the following functions:","category":"page"},{"location":"api/starting/","page":"Starting Actors, creating links","title":"Starting Actors, creating links","text":"spawn\nnewLink","category":"page"},{"location":"api/starting/#ActorInterfaces.Classic.spawn","page":"Starting Actors, creating links","title":"ActorInterfaces.Classic.spawn","text":"spawn(f, args...; \n      pid=myid(), thrd=false, sticky=false, \n      taskref=nothing, remote=false, mode=:default)\n\nCreate an actor with a behavior f(args...) and return  a Link to it.\n\nParameters\n\nf: callable object (function, closure or functor)   to execute when a message arrives,\nargs...: (partial) arguments to it,\npid=nothing: pid of worker process the actor should be started on,   if nothing the actor is started on myid(),\nthrd=false: thread number the actor should be started on or false,\nsticky=false: if true the actor is started on the current thread,\ntaskref=nothing: if a Ref{Task}() is given here, it gets the started Task,\nremote=false: if true, a remote channel is created,\nmode=:default: mode, the actor should operate in.\n\nNote: If you need keyword arguments kwargs... to  f, you can do spawn(Bhv(f, args...; kwargs...)).\n\n\n\n\n\n","category":"function"},{"location":"api/starting/#Actors.newLink","page":"Starting Actors, creating links","title":"Actors.newLink","text":"newLink(size=32; remote=false, pid=myid(), mode=nothing)\n\nCreate a local Link with a buffered Channel size ≥ 1.\n\nParameters\n\nsize=32: the size of the channel buffer,\nremote=false: should a remote link be created,\npid=myid(): optional pid of the remote worker,\nmode=nothing: if mode==nothing the mode is automatically   set to :local or :remote.\n\n\n\n\n\n","category":"function"},{"location":"howto/spawn/#How-to-spawn-actors","page":"spawn actors","title":"How to spawn actors","text":"","category":"section"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"CurrentModule = Actors","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"You create an actor by spawning it with a behavior. A behavior is","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"a callable Julia object and (if it accepts arguments)\nthe actors acquaintance parameters.","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"You must either import spawn explicitly or call it as Actors.spawn:","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"using Actors\nimport Actors: spawn\nmyactor = spawn(println, \"Hello \")","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"We spawned the actor with a println behavior function and \"Hello \" as an acquaintance parameter on an available thread. The returned Link can be used to send a message (a communication parameter) to the actor:","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"send(myactor, \"World!\");","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"Our actor then executed println(\"Hello \", \"World!\"). It continues to wait for messages.","category":"page"},{"location":"howto/spawn/#with-a-user-defined-behavior","page":"spawn actors","title":"with a user-defined behavior","text":"","category":"section"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"We can write our own behavior function. Thereby we must consider, which arguments the actor should work with. As we have seen, an actor can have acquaintance parameters and it gets its communication parameters with an incoming communication. The behavior function must accept both those as arguments. In the following example we let that open and write a behavior function thrd_println which can be invoked with arbitrary args...:","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"using .Threads\nfunction thrd_println(args...)\n    println(args..., \" from thread \", threadid())\nend","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"In order to try that out, we want to start our actor on a given thread.","category":"page"},{"location":"howto/spawn/#on-a-thread","page":"spawn actors","title":"on a thread","text":"","category":"section"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"We can start an actor on a specific thread by using the thrd keyword argument:","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"nthreads()\nmyactor = spawn(thrd_println, \"Hello \", \"my \", thrd=2)","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"As before we can send the communication parameter to the actor and it will now call our user-defined behavior with it:","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"send(myactor, \"world\");\n\nHello my world from thread 2","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"Note that this works only if we have started Julia with the -t or --threads flag or the JULIA_NUM_THREADS environment variable set.","category":"page"},{"location":"howto/spawn/#on-a-distributed-worker","page":"spawn actors","title":"on a distributed worker","text":"","category":"section"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"If we have distributed worker processes available either by starting Julia with the -p or --procs flag or by starting them explicitly with addprocs, we can create actors on those by using the pid keyword argument to spawn:","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"julia> using Distributed\n\njulia> worker = addprocs(2);      # start worker processes\n\njulia> @everywhere using Actors   # make Actors available everywhere\n\njulia> myactor = spawn(println, \"Hello \", pid=worker[2])\nLink{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(3, 1, 351), 3, :default)","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"Now spawn returned a Link with a RemoteChannel to the actor and we can send it communication parameters as usual:","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"julia> send(myactor, \"World!\");\n\n       From worker 3:    Hello World!","category":"page"},{"location":"howto/spawn/","page":"spawn actors","title":"spawn actors","text":"Actors are location-transparent and actors residing on different threads, processes and machines can communicate with each other by using their links.","category":"page"},{"location":"examples/dining_phil/#Dining-Philosophers","page":"Dining Philosophers","title":"Dining Philosophers","text":"","category":"section"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"This is a classic problem to illustrate challenges with concurrency. We will give here a solution based on Dale Schumacher's blogpost [1]. First some initial definitions:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"using Actors\nimport Actors: spawn\n\nconst eating_time = 5\nconst thinking_time = 10\nconst speedup = 100\n\nmutable struct Phil{L}\n    left::L\n    right::L\n    eaten::Float64\nend\n\ndelay(time, msg, cust) = async() do \n    sleep(time/speedup)\n    send(cust, msg)\nend\n\n@msg Take Taken Busy Put Eat Think","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"The first part of an actor based solution is that each chopstick between the philosophers is an actor. So only one access to a chopstick is possible at a time. And the philosophers will have to communicate with the chopsticks to take them:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"mutable struct Chopstick\n    idle::Bool\n    Chopstick() = new(true)\nend\n\nfunction (c::Chopstick)(cust, ::Take)\n    if c.idle\n        send(cust, self(), Taken())\n        c.idle = false\n    else\n        send(cust, self(), Busy())\n    end\nend\n(c::Chopstick)(::Put) = c.idle = true","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"We have modeled a chopstick actor as a function object with two message arguments, Take and Put.","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"Now the philosophers! We model them with behavior functions representing their state, the respective philosopher as an acquaintance and state transitions with become. So a philosopher is modeled as a finite state machine:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"function thinking(p::Phil, ::Eat)\n    send(p.left, self(), Take())\n    send(p.right, self(), Take())\n    become(hungry, p)\nend\nfunction hungry(p::Phil, chop, ::Taken)\n    chop == p.left ?\n        become(right_waiting, p) :\n        become(left_waiting,  p)\nend\nhungry(p::Phil, chop, ::Busy) = become(denied, p)\nfunction denied(p::Phil, other, ::Taken)\n    send(other, Put())\n    become(thinking, p)\n    send(self(), Eat())\nend\nfunction denied(p::Phil, chop, ::Busy)\n    become(thinking, p)\n    send(self(), Eat())\nend\nfunction right_waiting(p::Phil, chop, ::Taken)\n    if chop == p.right \n        become(eating, p)\n        p.eaten += te = randn()+eating_time\n        delay(te, Think(), self())\n    end\nend\nfunction right_waiting(p::Phil, chop, ::Busy)\n    send(p.left, Put())\n    become(thinking, p)\n    send(self(), Eat())\nend\nfunction left_waiting(p::Phil, chop, ::Taken)\n    if chop == p.left\n        become(eating, p)\n        p.eaten += te = randn()+eating_time\n        delay(te, Think(), self())\n    end\nend\nfunction left_waiting(p::Phil, chop, ::Busy)\n    send(p.right, Put())\n    become(thinking, p)\n    send(self(), Eat())\nend\nfunction eating(p::Phil, ::Think)\n    send(p.left, Put())\n    send(p.right, Put())\n    become(thinking, p)\n    delay(randn()+thinking_time, Eat(), self())\nend","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"The crucial step in preventing a deadlock is that a philosopher puts down his chopstick if he is  right_waiting or left_waiting and gets a :busy or if he is denied and gets a :taken message. Then he switches again to thinking and sends a message to himself to :eat. So he can try again.","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"We need a stats function for eating time and we setup everything:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"eaten(phils...) = Tuple(round(Int, query(p, :bhv).a[1].eaten) for p in phils)\n\nc1 = spawn(Chopstick())\nc2 = spawn(Chopstick())\nc3 = spawn(Chopstick())\nc4 = spawn(Chopstick())\nc5 = spawn(Chopstick())\n\ndescartes = spawn(thinking, Phil(c1,c2,0.0))\nnietzsche = spawn(thinking, Phil(c2,c3,0.0))\nkant      = spawn(thinking, Phil(c3,c4,0.0))\nhume      = spawn(thinking, Phil(c4,c5,0.0))\nplato     = spawn(thinking, Phil(c5,c1,0.0))\n\nfor p in (descartes, nietzsche, kant, hume, plato)\n    delay(thinking_time, Eat(), p)\nend","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"To get some stats we print the eaten times every second:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"julia > for i in 1:5\n            sleep(1)\n            println(i, \"s: \", eaten(descartes, nietzsche, kant, hume, plato))\n        end\n1s: (24, 34, 32, 31, 31)\n2s: (57, 70, 61, 62, 65)\n3s: (86, 101, 89, 96, 100)\n4s: (119, 129, 123, 124, 132)\n5s: (151, 162, 155, 155, 162)","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"So they are happy thinking and eating asynchronously. Since we have a speedup of 100, we can conclude that in 500 time units our philosophers eat around 155 (much more than programmers). We stop the whole thing in order to prevent overconsumption:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"julia > foreach(a->exit!(a), (descartes, nietzsche, kant, hume, plato, c1, c2, c3, c4, c5))","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"Actually Gul Agha proposed something else. He reasoned about to let philosophers talk to each other:","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"An actor is free and able to figure out a deadlock situation by querying other actors as to their local state. ... While these philosophers may be \"busy\" eating or looking for a chopstick, they nevertheless accept communications sent to them. [2]","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"We did not go this road in order to avoid philosophical debates about local state. But you can try for yourself.","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"[1]: Dale Schumacher. It's Actors All The Way Down, 2010: \"Dining Philosophers\" in Humus","category":"page"},{"location":"examples/dining_phil/","page":"Dining Philosophers","title":"Dining Philosophers","text":"[2]: Gul Agha, 1986. Actors: A Model of Concurrent Computation in Distributed Systems, MIT,- p. 95","category":"page"},{"location":"howto/share/#How-to-(not)-share-variables","page":"(not) share variables","title":"How to (not) share variables","text":"","category":"section"},{"location":"howto/share/","page":"(not) share variables","title":"(not) share variables","text":"Problem: When actors or tasks alike share objects concurrently they must avoid data races. Locks have serious disadvantages. How can we make data sharing safe without using locks?","category":"page"},{"location":"howto/share/#share-actors-instead-of-variables","page":"(not) share variables","title":"share actors instead of variables","text":"","category":"section"},{"location":"howto/share/","page":"(not) share variables","title":"(not) share variables","text":"Solution: Don't share memory. Instead define an actor that serves the object to its clients. Start it and share the actor link and its interface. Thus you share memory by communicating.","category":"page"},{"location":"howto/share/#define-a-message-API","page":"(not) share variables","title":"define a message API","text":"","category":"section"},{"location":"howto/share/#write-a-behavior","page":"(not) share variables","title":"write a behavior","text":"","category":"section"},{"location":"howto/share/#share-the-actor-link-or-name","page":"(not) share variables","title":"share the actor link or name","text":"","category":"section"},{"location":"howto/share/#use-actor-infrastructure-libraries","page":"(not) share variables","title":"use actor infrastructure libraries","text":"","category":"section"},{"location":"howto/share/","page":"(not) share variables","title":"(not) share variables","text":"There are Actors infrastructure libraries which can ease your use of such servers:","category":"page"},{"location":"howto/share/","page":"(not) share variables","title":"(not) share variables","text":"Guards: Actors guarding access to mutable variables and\nGenServers: Abstracting out concurrency to generic servers.","category":"page"}]
}
