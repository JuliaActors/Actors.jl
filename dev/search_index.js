var documenterSearchIndex = {"docs":
[{"location":"api/#Actor-API","page":"Actor API","title":"Actor API","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"CurrentModule = Actors","category":"page"},{"location":"api/#Installation","page":"Actor API","title":"Installation","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors\nActors.version","category":"page"},{"location":"api/#Actors.Actors","page":"Actor API","title":"Actors.Actors","text":"Actors\n\nA Julia library implementing the classical Actor Model.\n\nThe current stable, registered version is installed with\n\npkg> add Actors\n\nThe development version is installed with:\n\npkg> add \"https://github.com/JuliaActors/Actors.jl\"\n\n\n\n\n\n","category":"module"},{"location":"api/#Actors.version","page":"Actor API","title":"Actors.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Types","page":"Actor API","title":"Types","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Msg\nRequest\nResponse\nLink\nFunc\n_ACT","category":"page"},{"location":"api/#Actors.Msg","page":"Actor API","title":"Actors.Msg","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Request","page":"Actor API","title":"Actors.Request","text":"Request(x, from::Link)\n\nA generic Msg for user requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Response","page":"Actor API","title":"Actors.Response","text":"Response(y, from::Link=self())\n\nA Msg representing a response to requests.\n\nFields\n\ny: response content,\nfrom::Link: sender link.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Link","page":"Actor API","title":"Actors.Link","text":"Link{C}(chn::C, pid::Int, type::Symbol)\n\nA mailbox for communicating with actors. A concrete type of this must be returned by an actor on creation with spawn.\n\nFields/Parameters\n\nchn::C: C can be any type and characterizes the interface   to an actor,\npid::Int: the pid of the actor, \ntype::Symbol: an arbitrary symbol characterizing the actor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Func","page":"Actor API","title":"Actors.Func","text":"Func(f, args...; kwargs...)\n\nA structure for passing a function f and its arguments to an actor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors._ACT","page":"Actor API","title":"Actors._ACT","text":"_ACT()\n\nInternal actor status variable.\n\nFields\n\nbhv::Func : the behavior function and its internal arguments,\ninit::Func: the init function and its arguments,\nterm::Func: the terminate function and its arguments,\nself::Link: the actor's (local or remote) self,\nname::Symbol: the actor's registered name.\nres::Any: the result of the last behavior execution,\nusr::Any: user variable for plugging in something.\n\nsee also: Func, Link\n\n\n\n\n\n","category":"type"},{"location":"api/#Starting-Actors,-creating-links","page":"Actor API","title":"Starting Actors, creating links","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors.jl doesn't export its functions to start actors and to create links. Thereby other libraries building on it can implement their own actors and links.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"If you want to use standard actors and links, you can import them explicitly:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"using Actors\nimport Actors: spawn, newLink","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Then you can create them as follows:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"spawn\nnewLink","category":"page"},{"location":"api/#Actors.spawn","page":"Actor API","title":"Actors.spawn","text":"spawn(bhv::Func; pid=myid(), thrd=false, sticky=false, taskref=nothing)\nspawn(m::Val(:Actors), args...; kwargs...)\nspawn(m::Module, args...; kwargs...)\n\nStart a function bhv as an actor and return a Link to it.\n\nParameters\n\nbhv::Func: behavior function,\npid=myid(): pid of worker process the actor should be started on,\nthrd=false: thread number the actor should be started on or false,\nsticky=false: if true the actor is started on the current thread,\ntaskref=nothing: if a Ref{Task}() is given here, it gets the started Task,\nm::Module: the Module implementing spawn.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.newLink","page":"Actor API","title":"Actors.newLink","text":"newLink(size=32; remote=false)\n\nCreate a local Link with a buffered Channel size â‰¥ 1.\n\nParameters\n\nsize=32: the size of the channel buffer,\nremote=false: should a remote link be created,\npid=myid(): optional pid of the remote worker.\n\n\n\n\n\n","category":"function"},{"location":"api/#Primitives","page":"Actor API","title":"Primitives","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"send!\nbecome!\nbecome\nself\nstop\nonmessage","category":"page"},{"location":"api/#Actors.send!","page":"Actor API","title":"Actors.send!","text":"send!(lk::Link, msg)\n\nSend a message to an actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.become!","page":"Actor API","title":"Actors.become!","text":"become!(lk::Link, bhv::Func)\n\nTell an actor lk to assume the behavior function bhv.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.become","page":"Actor API","title":"Actors.become","text":"become(bhv::Function, args...; kwargs...)\n\nCause your actor to take on a new behavior. This can only be called from inside an actor/behavior.\n\nArguments\n\nbhv::Function: function implementing the new behavior,\nargs...: arguments to bhv (without msg),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.self","page":"Actor API","title":"Actors.self","text":"self()\n\nGet the Link of your actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.stop","page":"Actor API","title":"Actors.stop","text":"stop(reason::Symbol)\n\nCause your actor to stop with a reason.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.onmessage","page":"Actor API","title":"Actors.onmessage","text":"onmessage(A::_ACT, msg)\n\nAn actor executes this function when a message arrives. An application can extend this by further methods and use  it to plugin the Actors.jl API.\n\n\n\n\n\n","category":"function"},{"location":"api/#User-API","page":"Actor API","title":"User API","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"receive!\nrequest!","category":"page"},{"location":"api/#Actors.receive!","page":"Actor API","title":"Actors.receive!","text":"receive!(lk; timeout=5.0)\nreceive!(lk, from; timeout=5.0)\nreceive!(lk, M; timeout=5.0)\nreceive!(lk, M, from; timeout=5.0)\n\nReceive a message over a link lk.\n\nIf M or from are provided, receive! returns only a  matching message. Other messages in lk are restored to it in their previous order.\n\nParameters\n\nlk::Link: local or remote link over which the message is received,\nM::Type{<:Msg}: Msg type,\nfrom::Link: local or remote link of sender. If from is   provided, only messages with a from field can be matched.\ntimeout::Real=5.0: maximum waiting time in seconds.\nIf timeout==0, lk is scanned only for existing messages.\nSet timeout=Inf if you don't want to timeout. \n\nReturns\n\nreceived message or Timeout().\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.request!","page":"Actor API","title":"Actors.request!","text":"request!(lk::Link, msg::Msg; full=false, timeout::Real=5.0)\nrequest!(lk::Link, M::Type{<:Msg}, args...; kwargs...)\n\nSend a message to an actor, block, receive and return the result.\n\nArguments\n\nlk::Link: actor link, or name::Symbol (if registered),\nmsg::Msg: a message,\nMsg::Type{<:Msg}: a message type,\nargs...: optional arguments to Msg, \nfull: if true return the full Response message.\ntimeout::Real=5.0: timeout in seconds after which a    Timeout is returned,\nkwargs...: full or timeout.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Messages","page":"Actor API","title":"Internal Messages","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Become\nCall\nDiag\nExit\nUpdate\nTimeout","category":"page"},{"location":"api/#Actors.Become","page":"Actor API","title":"Actors.Become","text":"Become(x::Func)\n\nAn asynchronous Msg to an actor to change its  behavior.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Call","page":"Actor API","title":"Actors.Call","text":"Call(arg, from::Link)\n\nA synchronous Msg to an actor to execute its  behavior with arg... and to send the result as a Response  message to from.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Diag","page":"Actor API","title":"Actors.Diag","text":"Diag(from::Link)\n\nA synchronous Msg to an actor to send a  Response message with its internal _ACT variable to from.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Exit","page":"Actor API","title":"Actors.Exit","text":"Exit(reason, stack)\n\nA Msg causing an actor to stop with an exit code. If present, it calls its term! function with code as last argument.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Update","page":"Actor API","title":"Actors.Update","text":"Update(s::Symbol, x)\n\nAn asynchronous Msg to an actor to update its  internal state s to x.\n\ns::Symbol can be one of :arg, :self, :usr.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Timeout","page":"Actor API","title":"Actors.Timeout","text":"Timeout()\n\nA return value to signal that a timeout has occurred.\n\n\n\n\n\n","category":"type"},{"location":"api/#Diagnosis","page":"Actor API","title":"Diagnosis","text":"","category":"section"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Actors","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This example shows the basic primitives of Actors:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"spawn: create an actor and get a Link to it,\nsend!: send it a message,\nbecome!: cause it to change its behavior.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> using Actors, Printf\n\njulia> import Actors: spawn                 # this has to be imported\n\njulia> function pr(msg)                     # define two functions for printing a message\n           print(@sprintf(\"%s\\n\", msg))\n           become(pr, \"Next\") # change behavior\n       end\npr (generic function with 1 method)\n\njulia> pr(info, msg) = print(@sprintf(\"%s: %s\\n\", info, msg))\npr (generic function with 2 methods)\n\njulia> calc(op, x, y) = op(x, y)            # a function for doing arithmetic\ncalc (generic function with 1 method)\n\njulia> myactor = spawn(Func(pr))            # start an actor with the first behavior\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :local)\n\njulia> send!(myactor, \"My first actor\");    # send a message to it\nMy first actor\n\njulia> send!(myactor, \"Something else\")     # send again a message\nNext: Something else\n\njulia> become!(myactor, pr, \"New behavior\");# change the behavior to another one\n\njulia> send!(myactor, \"bla bla bla\")        # and send again a message\nNew behavior: bla bla bla\n\njulia> become!(myactor, calc, +, 10);       # become a machine for adding to 10\n\njulia> request!(myactor, 5)                 # send a request to add 5\n15\n\njulia> become!(myactor, ^);                 # become a exponentiation machine\n\njulia> request!(myactor, 123, 456)          # try it\n2409344748064316129","category":"page"},{"location":"actors/#Actors","page":"Actors","title":"Actors","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"CurrentModule = Actors","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors implements the classical Actor Model [1]. Actors are created as Julia tasks running on a computer or in a network and are represented by links over which they can send messages [2]. If they receive a message, they execute a behavior function. ","category":"page"},{"location":"actors/#Start","page":"Actors","title":"Start","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"To create an actor we spawn it with a behavior function:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"using Actors, .Threads\nimport Actors: spawn\nact1 = spawn(Func(threadid))             # start an actor which returns its threadid\nrequest!(act1)                           # call it\nusing Distributed\naddprocs(1);\n@everywhere using Actors\nact2 = spawn(Func(println), pid=2)       # start a remote actor on pid 2 with a println behavior\nrequest!(act2, \"Tell me where you are!\") # and call it with an argument","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors are created with a behavior function and eventually partial arguments to it. We can then send them the remaining arguments later.","category":"page"},{"location":"actors/#Links","page":"Actors","title":"Links","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"The actor returned a Link over which it can receive messages. This is its only representation.","category":"page"},{"location":"actors/#Messages","page":"Actors","title":"Messages","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors act and communicate asynchronously. There are only two functions to interact with them:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"send!: send a message to an actor,\nreceive!: receive a message from an actor.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors follow a message protocol if they get a message of type Msg. This can be extended by a user.","category":"page"},{"location":"actors/#Behavior","page":"Actors","title":"Behavior","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"When an actor receives a message, it combines any partial arguments known to it with the message arguments and executes its behavior function.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"julia> mystack = spawn(Func(stack_node, StackNode(nothing, Link()))); # create an actor with a partial argument","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"mystack represents an actor with a stack_node behavior and a partial argument StackNode(nothing, Link()). When it eventually receives a message ...","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"julia> send!(mystack, Push(1))        # push 1 on the stack","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"..., it executes stack_node(StackNode(nothing, Link()), Push(1)).","category":"page"},{"location":"actors/#Actor-Control","page":"Actors","title":"Actor Control","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors can be controlled with the following functions:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become!: cause an actor to switch its behavior,\n...","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Those functions are wrappers to internal messages and to send!.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors can also operate on themselves, or rather they send messages to themselves:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become: an actor switches its own behavior,\nself: an actor gets a link to itself,\nstop: an actor stops.","category":"page"},{"location":"actors/#Bidirectional-Messages","page":"Actors","title":"Bidirectional Messages","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"What if you want to receive a reply from an actor? Then there are two possibilities:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"send! a message to an actor and then receive! the Response asynchronously,\nrequest!: send a message to an actor, block and receive the result synchronously.","category":"page"},{"location":"actors/#Using-the-API","page":"Actors","title":"Using the API","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"The API functions allow to work with actors without using messages explicitly:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"using Actors, .Threads # hide\nact4 = spawn(Func(+, 4))       # start an actor adding to 4\nrequest!(act4, 4)","category":"page"},{"location":"actors/#Actor-Registry","page":"Actors","title":"Actor Registry","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"...","category":"page"},{"location":"actors/#Actor-Supervision","page":"Actors","title":"Actor Supervision","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"...","category":"page"},{"location":"actors/#Actor-Isolation","page":"Actors","title":"Actor Isolation","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"In order to avoid race conditions actors have to be strongly isolated from each other:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"they do not share state,\nthey must not share mutable variables.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"An actor stores the behavior function and arguments to it, results of computations and more. Thus it has state and this influences how it behaves.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"But it does not share its state variables with its environment (only for diagnostic purposes). The API functions above are a safe way to access actor state via messaging.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Mutable variables in Julia can be sent over local channels without being copied. Accessing those variables from multiple threads can cause race conditions. The programmer has to be careful to avoid those situations either by","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"not sharing them between actors,\ncopying them when sending them to actors or\nacquiring a lock around any access to data that can be observed from multiple threads. [3]","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"When sending mutable variables over remote links, they are automatically copied.","category":"page"},{"location":"actors/#Actor-Local-Dictionary","page":"Actors","title":"Actor Local Dictionary","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Since actors are Julia tasks, they have a local dictionary in which you can store values. You can use task_local_storage to access it in behavior functions. But normally argument passing should be enough to handle values in actors.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[1]: See: The Actor Model on Wikipedia and 43 Years of Actors.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[2]: They build on Julia's concurrency primitives  Task and Channel.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[3]: see Data race freedom in the Julia manual.","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"On JuliaActors there is a companion library SlowActors to illustrate the use of the interface. This is a completely different implementation of the Actor Model. It doesn't use Julia Channels for message passing and operates without an actor loop. Rather each time a message to a \"slow\" actor is sent, an actor Task is started.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"But in using the common Link type, actors from both libraries can communicate. With actually few lines of code SlowActors plugs in the Actors interface and is able to run the identical examples. It actually only reimplements three primitives: spawn, newLink and send!.","category":"page"},{"location":"protocol/#Message-Protocol","page":"Message Protocol","title":"Message Protocol","text":"","category":"section"},{"location":"behaviors/#Behaviors","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"CurrentModule = Actors","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"A behavior is a ...","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"... function to express what an actor does when it processes a message. [1]","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Behaviors can be set with spawn and changed with become!. Inside a behavior function an actor can change its own behavior with become. In both cases no arguments, partial or full arguments and keyword arguments can be specified with the behavior. ","category":"page"},{"location":"behaviors/#Partial-Arguments","page":"Behaviors","title":"Partial Arguments","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Partial arguments can fix the behavior function to work with given variables, e.g. a certain database, a state variable, a user request ... This is very useful.","category":"page"},{"location":"behaviors/#dispatch","page":"Behaviors","title":"Behavior Dispatch","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"If additional arguments arrive with a message, an actor composes the previously set partial arguments with the new arguments and dispatches the behavior function with them. The arguments are composed from left to right, first the partial arguments, then the received ones.","category":"page"},{"location":"behaviors/#Keyword-Arguments","page":"Behaviors","title":"Keyword Arguments","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Keyword arguments are not dispatched on but they too can represent state and therefore can change the behavior.","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"[1]: see the Actor Model on Wikipedia.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"see the examples in the repository.","category":"page"},{"location":"#Actors.jl","page":"Home","title":"Actors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Concurrent programming in Julia with the Actor model.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A quick introduction to Actors,\nHow to use actors,\nHow to use behaviors,\nActors API: detailed documentation,\nInternals\nThe actor protocol,\nInterface for Julia actor libraries.","category":"page"},{"location":"#JuliaActors","page":"Home","title":"JuliaActors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Actors is part of the Julia GitHub group JuliaActors.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paul Bayer","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Actors is licensed under the MIT License.","category":"page"}]
}
