var documenterSearchIndex = {"docs":
[{"location":"infrastructure/#Infrastructure","page":"Infrastructure","title":"Infrastructure","text":"","category":"section"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"CurrentModule = Actors","category":"page"},{"location":"infrastructure/#Actor-Tasks","page":"Infrastructure","title":"Actor Tasks","text":"","category":"section"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"Actor tasks execute one computation, mostly without communicating with other actors. They can be used to compute values asynchronously.","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"You can start actor tasks with async and get their result with await.","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"using Actors\nt = async(Bhv(^, 123, 456));\nawait(t)","category":"page"},{"location":"infrastructure/#Actor-Registry","page":"Infrastructure","title":"Actor Registry","text":"","category":"section"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"If a parent actor or worker process creates a new actor, the link to it is only locally known. It has to be sent to all other actors that want to communicate with it.","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"Alternatively an actor link can be registered under a name (a Symbol). Then any actor in the system can communicate with it using that name.","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"julia> using Actors, Distributed\n\njulia> import Actors: spawn\n\njulia> addprocs(1);\n\njulia> @everywhere using Actors\n\njulia> @everywhere function ident(id, from)\n           id == from ?\n               (\"local actor\",  id, from) :\n               (\"remote actor\", id, from)\n       end\n\njulia> register(:act1, spawn(Bhv(ident, 1))) # a registered local actor\ntrue\n\njulia> call(:act1, myid())                   # call it\n(\"local actor\", 1, 1)\n\njulia> register(:act2, spawn(Bhv(ident, 2), pid=2)) # a registered remote actor on pid 2\ntrue\n\njulia> call(:act2, myid())                   # call it\n(\"remote actor\", 2, 1)\n\njulia> fetch(@spawnat 2 call(:act1, myid())) # call :act1 on pid 2\n(\"remote actor\", 1, 2)\n\njulia> fetch(@spawnat 2 call(:act2, myid())) # call :act2 on pid 2\n(\"local actor\", 2, 2)\n\njulia> whereis(:act1)                         # get a link to :act1\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> whereis(:act2)                         # get a link to :act2\nLink{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n\njulia> fetch(@spawnat 2 whereis(:act1))       # get a link to :act1 on pid 2\nLink{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 40), 1, :default)\n\njulia> registered()                           # get a list of registered actors\n2-element Array{Pair{Symbol,Link},1}:\n :act2 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n :act1 => Link{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> fetch(@spawnat 2 registered())         # get it on pid 2\n2-element Array{Pair{Symbol,Link{RemoteChannel{Channel{Any}}}},1}:\n :act2 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(2, 1, 16), 2, :default)\n :act1 => Link{RemoteChannel{Channel{Any}}}(RemoteChannel{Channel{Any}}(1, 1, 46), 1, :default)","category":"page"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"The registry works transparently across workers. All workers have access to registered actors on other workers via remote links.","category":"page"},{"location":"infrastructure/#Actor-Supervision","page":"Infrastructure","title":"Actor Supervision","text":"","category":"section"},{"location":"infrastructure/","page":"Infrastructure","title":"Infrastructure","text":"...","category":"page"},{"location":"actors/#Actors-and-Julia","page":"Actors and Julia","title":"Actors and Julia","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"CurrentModule = Actors","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors implements the Actor model using Julia's concurrency primitives:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Actors are implemented as Tasks.\nThey communicate over Channels.","category":"page"},{"location":"actors/#Multi-threading","page":"Actors and Julia","title":"Multi-threading","text":"","category":"section"},{"location":"actors/#Distributed-Computing","page":"Actors and Julia","title":"Distributed Computing","text":"","category":"section"},{"location":"actors/#Actor-Isolation","page":"Actors and Julia","title":"Actor Isolation","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"In order to avoid race conditions actors have to be strongly isolated from each other:","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"they do not share state,\nthey must not share mutable variables.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"An actor stores the behavior function and arguments to it, results of computations and more. Thus it has state and this influences how it behaves.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"But it does not share its state variables with its environment (only for diagnostic purposes). The API functions above are a safe way to access actor state via messaging.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Mutable variables in Julia can be sent over local channels without being copied. Accessing those variables from multiple threads can cause race conditions. The programmer has to be careful to avoid those situations either by","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"not sharing them between actors,\ncopying them when sending them to actors or\nacquiring a lock around any access to data that can be observed from multiple threads. [1]","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"When sending mutable variables over remote links, they are automatically copied.","category":"page"},{"location":"actors/#Actor-Local-Dictionary","page":"Actors and Julia","title":"Actor Local Dictionary","text":"","category":"section"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"Since actors are Julia tasks, they have a local dictionary in which you can store values. You can use task_local_storage to access it in behavior functions. But normally argument passing should be enough to handle values in actors.","category":"page"},{"location":"actors/","page":"Actors and Julia","title":"Actors and Julia","text":"[1]: see Data race freedom in the Julia manual.","category":"page"},{"location":"protocol/#The-Actors-Protocol","page":"The Actors Protocol","title":"The Actors Protocol","text":"","category":"section"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"CurrentModule = Actors","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Actors has predefined message types with respective onmessage methods. This gives your actors predefined behaviors going beyond the classical behavior. API functions provide an interface to that messaging protocol and facilitate actor control and message exchange.","category":"page"},{"location":"protocol/#Actor-Control","page":"The Actors Protocol","title":"Actor Control","text":"","category":"section"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Actors can be controlled with the following functions:","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"API function brief description\nbecome! cause an actor to switch its behavior\ncast cause an actor to execute its behavior function\nexit! cause an actor to terminate\ninit! tell an actor to execute a function at startup\nterm! tell an actor to execute a function when it terminates\nupdate! update an actor's internal state","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Actors can also operate on themselves, or rather they send themselves messages:","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"API function brief description\nbecome an actor switches its own behavior\nself an actor gets a link to itself\nstop an actor stops","category":"page"},{"location":"protocol/#Bidirectional-Messages","page":"The Actors Protocol","title":"Bidirectional Messages","text":"","category":"section"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"To receive a reply from an actor there are two possibilities:","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"API function brief description\nreceive after a send receive the Response asynchronously\nrequest send (implicitly) a message to an actor, block and receive the result synchronously","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"The following functions do that for specific duties:","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"API function brief description\ncall tell an actor to execute its behavior function and to send the result\nexec tell an actor to execute a function and to send the result\nquery tell an actor's to send one of its internal state variables","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Those functions support both asynchronous and synchronous communication..","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"The following example shows the use of the API functions to control an actor in a REPL session:","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"using Actors, .Threads\nimport Actors: spawn\nact4 = spawn(Bhv(+, 4))       # start an actor adding to 4\nexec(act4, Bhv(threadid))     # ask it its threadid\ncast(act4, 4)                 # cast it 4\nquery(act4, :res)             # query the result\nbecome!(act4, *, 4);          # switch the behavior to *\ncall(act4, 4)                 # call it with 4\nexec(act4, Bhv(broadcast, cos, pi .* (-2:2))) # tell it to exec any function\nActors.diag(act4)             # check it\nexit!(act4)                   # stop it\nact4.chn.state\nActors.diag(act4)             # try to check it again","category":"page"},{"location":"protocol/#Enhancing-the-Protocol","page":"The Actors Protocol","title":"Enhancing the Protocol","text":"","category":"section"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Actor protocols can be enhanced or altered by","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"introducing new messages and onmessage methods,\nswitching the actor mode and writing new onmessage methods for existing messages\nor both.","category":"page"},{"location":"protocol/","page":"The Actors Protocol","title":"The Actors Protocol","text":"Libraries can do this for specific duties and plugin their protocols into Actors. Examples of such libraries are GenServers and Guards.","category":"page"},{"location":"errors/#Error-Handling","page":"Error Handling","title":"Error Handling","text":"","category":"section"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"Actors follows Erlang's philosophy to let actors fail.","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"The error handling based on this has yet to be implemented:","category":"page"},{"location":"errors/","page":"Error Handling","title":"Error Handling","text":"grouping of actors\nmonitoring\nsystem actors (for supervision)","category":"page"},{"location":"basics/#Actor-Model","page":"Actor Model","title":"Actor Model","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"CurrentModule = Actors","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"The Actor Model was originally proposed by Carl Hewitt et. al. in the 70es and since then has evolved into different families [1]. ","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"We focus here on the classical Actor Model described by Gul Agha in Actors [2]. This sees an actor as the universal primitive of concurrent computation:","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"An actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [3]","category":"page"},{"location":"basics/#Actor-Characteristics","page":"Actor Model","title":"Actor Characteristics","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Actor systems and actors have the following basic characteristics[4] :","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"communication via direct asynchronous messaging,\nactors support finite state machines,\nactors do not share their mutable state,\nlock-free concurrency,\nactors support parallelism,\nactors tend to come in systems.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Modern actor implementations extend those by","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"location transparency: this enables actors of different kinds and on different systems to communicate,\nsupervision: actors form a dependency relationship where a parent actor supervises child/subordinate ones. This is used to implement fault tolerant systems.\nactor protocols: there are predefined actors  following a specific message protocol to implement complex behaviors e.g. as generic server, supervisor, router, publish-subscribe ...  ","category":"page"},{"location":"basics/#Actor-Primitives","page":"Actor Model","title":"Actor Primitives","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"The actor machinery is based on only a few basic primitives defined in ActorInterfaces.Classic:","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Primitive Brief description\nAddr an address identifying an actor,\nself() get the address of the current actor,\nspawn(bhv) create an actor from a behavior and return an address,\nsend(addr, msg) send a message to an actor,\nbecome(bhv) an actor designates a new behavior,\nonmessage(bhv, msg) is executed by the actor when a message arrives.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"A user can write actor programs using only those basic primitives. If onmessage method definitions are marked with @ctx, this injects a ctx (context) argument into calls to self, spawn ... This allows a program to work with different implementations of ActorInterfaces.Classic.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"Actors provides methods for those primitives and extends them with further functionality. On a basic level Actors is compatible with other libraries by building on the same basic interface.","category":"page"},{"location":"basics/#A-Classic-Example","page":"Actor Model","title":"A Classic Example","text":"","category":"section"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[1]: De Koster, Van Cutsem, De Meuter 2016. 43 Years of Actors: A Taxonomy of Actor Models and Their Key Properties.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[2]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[3]: See the Wikipedia entry on the Actor Model.","category":"page"},{"location":"basics/","page":"Actor Model","title":"Actor Model","text":"[4]: Here I follow roughly: Vernon, Vaughn 2016. Reactive messaging patterns with the Actor model: applications and integration in Scala and Akka, Pearson","category":"page"},{"location":"messages/#Messages","page":"Messages","title":"Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"CurrentModule = Actors","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Actors can be called, updated, queried … To do it they follow a onmessage protocol on the following internal messages.","category":"page"},{"location":"messages/#Internal-Messages","page":"Messages","title":"Internal Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"Become\nCall\nCast\nDiag\nExit\nExec\nInit\nQuery\nTerm\nTimeout\nUpdate","category":"page"},{"location":"messages/#Actors.Become","page":"Messages","title":"Actors.Become","text":"Become(bhv)\n\nAn asynchronous Msg to an actor to change its  behavior to bhv.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Call","page":"Messages","title":"Actors.Call","text":"Call(arg, from::Link)\n\nA synchronous Msg to an actor to execute its  behavior with arg... and to send the result as a Response  message to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Cast","page":"Messages","title":"Actors.Cast","text":"Cast(arg)\n\nAn asynchronous Msg to an actor to execute  its behavior with arg... without sending a response.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Diag","page":"Messages","title":"Actors.Diag","text":"Diag(x, from::Link)\n\nA synchronous Msg to an actor to send diagnostic information.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Exit","page":"Messages","title":"Actors.Exit","text":"Exit(reason=:ok, stack=nothing)\n\nA Msg causing an actor to stop with an exit reason. If present, it calls its term!  function with reason as last argument.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Exec","page":"Messages","title":"Actors.Exec","text":"Exec(func::Bhv, from::Link)\n\nA synchronous Msg to an actor to execute func and to send a Response message with the return value to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Init","page":"Messages","title":"Actors.Init","text":"Init(f::Bhv)\n\nA Msg to an actor to execute the given Bhv and to register it in the _ACT variable.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Query","page":"Messages","title":"Actors.Query","text":"Query(s::Symbol, from::Link)\n\nA Msg to an actor to send a  Response message with one of its internal state  variables s to from.\n\ns::Symbol can be one of :sta, :res, :bhv, :dsp.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Term","page":"Messages","title":"Actors.Term","text":"Term(x::Bhv)\n\nA Msg to an actor to save the given Bhv  and to execute it upon termination.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Timeout","page":"Messages","title":"Actors.Timeout","text":"Timeout()\n\nA return value to signal that a timeout has occurred.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Actors.Update","page":"Messages","title":"Actors.Update","text":"Update(s::Symbol, x)\n\nAn asynchronous Msg to an actor to update its  internal state s to x.\n\ns::Symbol can be one of :arg, :self, :sta, :usr.\n\n\n\n\n\n","category":"type"},{"location":"messages/#User-extensions","page":"Messages","title":"User extensions","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"There are four ways to extend the messaging protocol and the functionality of Actors:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"If a user defines its own messages of type Msg and sends them to an actor, it passes them on as remaining argument to the behavior function.\nAlternatively a user can extend Actors.onmessage with his own methods to dispatch on those messages and doing user defined things.\nA user can set the actor mode with spawn or change it with update! to something other than :default, e.g. :mymode. If he then implements a method Actors.onmessage(A::_ACT, ::Val{:mymode}, msg::Call) and so on, the actor will dispatch that one when it receives a Call message.\nFinally a user can implement other message types and messaging protocols and extend Actors.onmessage for dispatching on those.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"CurrentModule = Actors","category":"page"},{"location":"intro/#Getting-Started-with-Actors","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"You may have heard about the Actor Model, but here we present actors as practical things, which you can spawn, send messages to, receive or request messages from, call, cast to them, query and update! them. Please follow along in your Julia REPL and don't hesitate to try things out.","category":"page"},{"location":"intro/#Creation:-spawn","page":"Getting Started with Actors","title":"Creation: spawn","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The basic mechanism to create a new actor is the spawn function. You have to import it explicitly:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"using Actors\nimport Actors: spawn, newLink","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"You spawn an actor with a behavior. A behavior is a callable Julia object.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"myactor = spawn(Threads.threadid)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"spawn returned an actor link.","category":"page"},{"location":"intro/#Actor-Links","page":"Getting Started with Actors","title":"Actor Links","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"A Link is the actor's mail address and its only representation. Over the returned link it is possible to send messages to the actor or to use other messaging functions. For example if you call or request it, you send a Call or Request message to the actor to execute its behavior and to respond with the result:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"call(myactor)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Now what happens if you send your actor a message which it cannot understand?","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, \"Boom\")\nActors.info(myactor)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We caused our actor to fail. Ouch!","category":"page"},{"location":"intro/#Behaviors:-become-and-become!","page":"Getting Started with Actors","title":"Behaviors: become and become!","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We want our actor to do something more meaningful! Let's write our own behavior. We want our actor to calculate something and to send the result back to a given address:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"function calc(addr::Link, f::Function, args...)\n    send(addr, f(args...))\nend","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"With newLink we create a link for ourselves, spawn a new actor with a calc behavior and give it that newly created link as acquaintance parameter:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"me = newLink()\nmyactor = spawn(calc, me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We applied our calc function partially to me. Now our actor holds the me link as acquaintance and we need to send it only the rest of the parameters to cause it to execute the given function f on some parameters and to send the result back:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, +, 1, 2, 3, 4)\nreceive(me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"If we want our actor to do only multiplication, we can change its behavior with become! to calc with new acquaintances:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"become!(myactor, calc, me, *);","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The actor's new behavior is calc with two acquaintances me and *, and thus it does multiplication only. As before we send it the communication parameters to multiply and receive the result:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, 1,2,3,4)\nreceive(me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"An actor can change also its own behavior with become. Since an actor does what its behavior tells it to do, you use become inside a behavior function to cause the actor to switch to a new behavior. Instead become! is a call from the outside of an actor. A behavior change is effective for the next message an actor receives.","category":"page"},{"location":"intro/#Communication:-send-and-receive","page":"Getting Started with Actors","title":"Communication: send and receive","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"When we used send and receive in our experiments so far, we did asynchronous communication with our actor. After sending something  we could have done other work and then receive the result later.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"What happens if we try to receive something from a failed actor?","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"send(myactor, 5, \"x\")\nreceive(me)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"After some seconds we got a Timeout().","category":"page"},{"location":"intro/#Synchronous-Communication:-request","page":"Getting Started with Actors","title":"Synchronous Communication: request","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We don't give up with it and start it again, but now we want an adding machine with an offset of 1000:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"myactor = spawn(+, 1000)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Our actor now has no acquaintance of me, neither has its behavior any send instruction. If we send it something, it will only add that to 1000 but not respond anything.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Here the actor protocol comes to our rescue. It allows us to communicate with actors even if their behaviors don't send anything. Actors understand messaging patterns.  For example if we send an actor a Request, it knows that it must send a Response message.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"The request function is a wrapper for that. It will create a link internally and send it and the communication parameters as a Request to the actor. The actor sends a Response back to the received link and the request function then delivers the response:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"request(myactor, 1,2,3)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"This is synchronous communication. request blocks until it receives the result (or a Timeout()).","category":"page"},{"location":"intro/#More-Control:-call,-cast,-exec,-query,-update!-...","page":"Getting Started with Actors","title":"More Control: call, cast, exec, query, update! ...","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"There are more such actor protocols and API functions. ","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"We can do asynchronous communication with our actor if we use call with the me link. This sends the given link to the actor and it responds to it. Then we can receive the result asynchronously:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"call(myactor, me, 1000)\nreceive(me).y","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"If we don't provide a return link to call, it will use request and deliver the result synchronously:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"call(myactor, 2000)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Another possibility to communicate asynchronously with an actor is to cast it parameters and then to query the result afterwards.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"cast(myactor, 3000)\nquery(myactor, :res)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"But this will work fine only if between those two calls to myactor there is not another actor communicating with it. If for example our actor has mutual variables as acquaintances, we can use cast to set parameters or to do anything else where we don't need a response.","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"With exec we can tell an actor to execute any function and to deliver the result:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"exec(myactor, broadcast, cos, pi .* (-2:2))","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Actors have internal state variables which we normally don't need to work with. We can update! those variables. One example for such a use is to update! the actor's current acquaintance parameter (1000) to 500. Then it adds to 500:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"update!(myactor, Args(500))\ncall(myactor, 500)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"But we could have achieved the same with become!(myactor, +, 500).","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Finally we exit! the actor since we are finished with this introduction:","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"exit!(myactor)\nsend(myactor, 500)","category":"page"},{"location":"intro/","page":"Getting Started with Actors","title":"Getting Started with Actors","text":"Trying to send it something now throws an exception.","category":"page"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"CurrentModule = Actors","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"warning: The interface is yet experimental!\nMost of the following needs yet work and will be demonstrable with the upcoming v0.2 release.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Actors provides a versatile interface to work with other actor libraries in the JuliaActors ecosystem or to allow programmers and users alike to extend its functionality:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"It is written against ActorInterfaces.Classic. Thus it can execute programs written with the primitives in that interface.\nActors from other libraries written with that interface have actor level compatibility. Thus they can exchange messages, use the Actors registry (and upcoming supervision).\nOther libraries written against that interface can plugin the Actors' onmessage protocol and thus inherit the user API functions: call, cast ...\nOther party libraries can start actors in another mode and implement a different onmessage protocol to make their actors do different things.\nUsers can enhance the [Msg] types implemented and extend the onmessage methods for working with those messages.","category":"page"},{"location":"interface/#Different-actor-primitives","page":"Interface","title":"Different actor primitives","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"On JuliaActors there is a companion library SlowActors to illustrate the use of the interface. This is a completely different implementation of the Actor Model. It doesn't use Julia Channels for message passing and operates without an actor loop. Rather each time a message to a \"slow\" actor is sent, an actor Task is started.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"But in using the common Link type, actors from both libraries can communicate. With actually few lines of code SlowActors plugs in the Actors interface and is able to run the identical examples. It actually only reimplements three primitives: spawn, newLink and send!.","category":"page"},{"location":"interface/#Different-actor-mode-and-behavior","page":"Interface","title":"Different actor mode and behavior","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Actors provides a mode field in both Link and _ACT, with mode=:default for normal operation.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Other libraries can spawn their actors with a different mode, e.g. mode=:GenServer. If they then enhance onmessage with e.g.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Actors.onmessage(A::_ACT, ::Val{:GenServer}, msg::Call) = ...\nActors.onmessage(A::_ACT, ::Val{:GenServer}, msg::Cast) = ...\n....","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"... they get for those messages a different actor behavior where they can do callbacks or set state or whatever they want to.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Actors spawned with a different mode return a link with the mode field set accordingly.","category":"page"},{"location":"glossary/#A-Glossary-of-Actor-Terms","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"","category":"section"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"Since Gul Agha's actor glossary [1] is very useful, we include here some of his descriptions and some additions.","category":"page"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"Actor term brief description\nacquaintance An actor alpha is an acquaintance of an actor beta if beta knows the mail address of alpha.\nactor A computational agent which has an mail address and a behavior. Actors communicate by message-passing and carry out their actions concurrently.\nasynchronous communication Communication is considered to be asynchronous when the sender does not have to wait for the recipient to be ready to accept a communication before the sender can send the communication.\nbehavior The behavior of an actor maps the incoming communication to a three tuple of tasks created, new actors created, and the replacement behavior.\nbehaviour \"A behavior encapsulates common behavioral patterns.\" Armstrong [2] The Erlang world has a more complex view of behaviors. Such more complex behaviors can be realized with a message protocol.\ncommunication The only mechanism by which actors may affect each other's behavior. The content of a message sent by an actor is called a communication.\nconcurrency The potentially parallel execution of actions without a determinate predefined sequence for their actions.\ncustomer A request communication contains the mail address of an actor called the customer to which a reply to the request is to be sent. Customers are dynamically created to carry out the rest of the computation, so that an actor sending a request to another actor can begin processing the next incoming communication without waiting for the subcomputations of the previous communication to complete.\nevent In the actor model, an event is the acceptance of a communication by an actor. In response to accepting a communication, an actor creates other actors, sends communications and specifies a replacement behavior; in an event based semantics these actions are considered a part of the event.\nexternal actor An actor which is external to a configuration but whose mail address is known to some actor within the configuration.\nfuture A future is an actor representing the value of a computation in progress. Futures can speed up computation since they allow subcomputations using references to a value to proceed concurrently with the evaluation of an expression to compute the value. Communications sent to a future are queued until the value has been determined.\nmail address A virtual location by which an actor may be accessed. Each actor has a unique mail address which is invariant, although the behavior of an actor may change over time.\nmail queue The queue of incoming communications sent to a given actor. The mail queue represents the arrival order of communications and provides the means to buffer communications until they are processed by the target actor.\nprotocol An actor follows a protocol if it – when receiving certain messages – executes predefined behaviors other than its current behavior. This is used to implement more complex behaviors and goes beyond the classical model.\nreceptionist An actor to whom communications may be sent from outside the configuration to which it belongs. The set of receptionists evolves dynamically as the mail addresses of various actors may be communicated to actors outside the system.\nreplacement behavior A behavior specified by an actor processing a communication which is used to process the next communication in the mail queue of the actor.\nreply A communication sent in response to a request (see also customers).\nrequest A communication asking for a response to be sent to a customer contained in the request.\nsynchronous communication Communication between two actors requiring the sender to wait until the recipient acknowledges or otherwise responds to the communication before continuing with further processing. Synchronous communication in actors is implemented using customers.","category":"page"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"[1]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT; Appendix B","category":"page"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"[2]: Joe Armstrong 2014. Programming Erlang, 2nd Ed.,","category":"page"},{"location":"glossary/","page":"A Glossary of Actor Terms","title":"A Glossary of Actor Terms","text":"Software for a Concurrent World, Pragmatic Programmers; p. 361","category":"page"},{"location":"api/#Actor-API","page":"API","title":"Actor API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Actors","category":"page"},{"location":"api/","page":"API","title":"API","text":"Actors\nActors.version","category":"page"},{"location":"api/#Actors.Actors","page":"API","title":"Actors.Actors","text":"Actors implements the classical Actor Model and is  based on the interface defined in ActorInterfaces.Classic.  It provides\n\nbasic primitives for creating actors,   sending messages to them and changing behavior:   spawn, send, become    with Addr and self,\nonmessage, executed by an actor on a    received message,\na Msg message protocol with onmessage and    predefined messages,\nan actor API based on the protocol with primitives   receive and request and further    API functions become!, call,    cast, exec, exit!,    init!, query, term!,    update!,\nactor tasks with async and await,\nan actor registry and more.\n\nThe current stable, registered version is installed with\n\npkg> add Actors\n\nThe development version is installed with:\n\npkg> add \"https://github.com/JuliaActors/Actors.jl\"\n\n\n\n\n\n","category":"module"},{"location":"api/#Actors.version","page":"API","title":"Actors.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"api/","page":"API","title":"API","text":"using Actors\nActors.version","category":"page"},{"location":"api/#Basic-Types","page":"API","title":"Basic Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following types are needed for using and extending Actors:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Msg\nRequest\nResponse\nLink\nBhv\n_ACT","category":"page"},{"location":"api/#Actors.Msg","page":"API","title":"Actors.Msg","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Request","page":"API","title":"Actors.Request","text":"Request(x, from::Link)\n\nA generic Msg for user requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Response","page":"API","title":"Actors.Response","text":"Response(y, from::Link=self())\n\nA Msg representing a response to requests.\n\nFields\n\ny: response content,\nfrom::Link: sender link.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Link","page":"API","title":"Actors.Link","text":"Link{C} <: ActorInterfaces.Classic.Addr\nLink(chn::C, pid::Int, type::Symbol) where C\n\nA mailbox for communicating with actors. A concrete type of this must be returned by an actor on creation with spawn.\n\nFields/Parameters\n\nchn::C: C can be any type and characterizes the interface   to an actor,\npid::Int: the pid (worker process identifier) of the actor, \nmode::Symbol: a symbol characterizing the actor mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.Bhv","page":"API","title":"Actors.Bhv","text":"Bhv(func, a...; kw...)(c...)\n\nA callable struct to represent actor behavior. It is executed with parameters from the incoming communication.\n\nParameters\n\nf::Function: a function,\na...: stored acquaintance parameters to f,\nkw...: stored keyword arguments,\nc...: parameters from the incoming communication.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors._ACT","page":"API","title":"Actors._ACT","text":"_ACT\n\nInternal actor status variable.\n\nFields\n\nmode::Symbol: the actor mode,\nbhv::AbstractBehavior: a partial function or a function object,\ninit::Union{Nothing,Function}: the init function and its arguments,\nterm::Union{Nothing,Function}: the terminate function and its arguments,\nself::Link: the actor's address,\nname::Union{Nothing,Symbol}: the actor's registered name.\nres::Any: the result of the last behavior execution,\nsta::Any: a variable for representing state,\nusr::Any: user variable for plugging in something.\n\nsee also: Bhv, Link\n\n\n\n\n\n","category":"type"},{"location":"api/#Starting-Actors,-creating-links","page":"API","title":"Starting Actors, creating links","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Actors.jl doesn't export its functions to start actors and to create links. Thus other libraries building on it can implement their own actors and links.","category":"page"},{"location":"api/","page":"API","title":"API","text":"To use Actors's actors and links you import them explicitly:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Actors\nimport Actors: spawn, newLink","category":"page"},{"location":"api/","page":"API","title":"API","text":"Then you can create them with the following functions:","category":"page"},{"location":"api/","page":"API","title":"API","text":"spawn\nnewLink","category":"page"},{"location":"api/#ActorInterfaces.Classic.spawn","page":"API","title":"ActorInterfaces.Classic.spawn","text":"spawn(bhv; pid=myid(), thrd=false, sticky=false, taskref=nothing, mode=:default)\nspawn(f, args...; kwargs...)\n\nCreate an actor with a behavior bhv and return a Link to it.\n\nParameters\n\nbhv: behavior, callable object (closure or functor)   to execute when a message arrives,\nf: a function,\nargs...: (partial) arguments to it,\npid=myid(): pid of worker process the actor should be started on,\nthrd=false: thread number the actor should be started on or false,\nsticky=false: if true the actor is started on the current thread,\ntaskref=nothing: if a Ref{Task}() is given here, it gets the started Task,\nmode=:default: mode, the actor should operate in.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.newLink","page":"API","title":"Actors.newLink","text":"newLink(size=32; remote=false, pid=myid(), mode=nothing)\n\nCreate a local Link with a buffered Channel size ≥ 1.\n\nParameters\n\nsize=32: the size of the channel buffer,\nremote=false: should a remote link be created,\npid=myid(): optional pid of the remote worker,\nmode=nothing: if mode==nothing the mode is automatically   set to :local or :remote.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actor-Primitives","page":"API","title":"Actor Primitives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following primitives characterize actors in the classical Actor Model:","category":"page"},{"location":"api/","page":"API","title":"API","text":"send\nbecome!\nbecome\nself\nstop\nonmessage","category":"page"},{"location":"api/#ActorInterfaces.Classic.send","page":"API","title":"ActorInterfaces.Classic.send","text":"send(lk::Link, msg)\n\nSend a message to an actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.become!","page":"API","title":"Actors.become!","text":"become!(lk::Link, bhv::Bhv)\nbecome!(lk::Link, func, args1...; kwargs...)\nbecome!(name::Symbol, ....)\n\nCause an actor to change behavior.\n\nArguments\n\nactor lk::Link (or name::Symbol if registered),\nbhv: a Bhv or a functor implementing the new behavior,\nfunc::Function: a function,\nargs1...: (partial) arguments to func,\nkwargs...: keyword arguments to func.\n\n\n\n\n\n","category":"function"},{"location":"api/#ActorInterfaces.Classic.become","page":"API","title":"ActorInterfaces.Classic.become","text":"become(bhv)\nbecome(func::F, args...; kwargs...) where F<:Function\n\nCause your actor to take on a new behavior. This can only be called from inside an actor/behavior.\n\nArguments\n\nbhv: a callable object implementing the new behavior,\nfunc::F: callable object,\nargs1...: (partial) arguments to func,\nkwargs...: keyword arguments to func.\n\n\n\n\n\n","category":"function"},{"location":"api/#ActorInterfaces.Classic.self","page":"API","title":"ActorInterfaces.Classic.self","text":"self()\n\nGet the Link of your actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.stop","page":"API","title":"Actors.stop","text":"stop(reason::Symbol)\n\nCause your actor to stop with a reason.\n\n\n\n\n\n","category":"function"},{"location":"api/#ActorInterfaces.Classic.onmessage","page":"API","title":"ActorInterfaces.Classic.onmessage","text":"onmessage(bhv, msg...)\n\nDefault behavior function to execute the current actor  behavior bhv with the message msg. The actor calls bhv(msg) when a message arrives. \n\nParameters\n\nbhv: excutable object (closure or functor) taking   parameters msg,\nmsg: message parameters to bhv.\n\n\n\n\n\nonmessage(A::_ACT, msg)\nonmessage(A::_ACT, mode, msg)\n\nAn actor executes this function when a message arrives.\n\nActor libraries or applications can use this to\n\nplugin the Actors.jl API (first form) or\nextend it to other protocols by using the 2nd form.\n\n\n\n\n\n","category":"function"},{"location":"api/#API-Primitives","page":"API","title":"API Primitives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"To receive messages from actors the following two functions for synchronous and asynchronous communication are useful:","category":"page"},{"location":"api/","page":"API","title":"API","text":"receive\nrequest","category":"page"},{"location":"api/#Actors.receive","page":"API","title":"Actors.receive","text":"receive(lk; timeout=5.0)\nreceive(lk, from; timeout=5.0)\nreceive(lk, M; timeout=5.0)\nreceive(lk, M, from; timeout=5.0)\n\nReceive a message over a link lk.\n\nIf M or from are provided, receive returns only a  matching message. Other messages in lk are restored to it in their previous order.\n\nParameters\n\nlk::Link: local or remote link over which the message is received,\nM::Type{<:Msg}: Msg type,\nfrom::Link: local or remote link of sender. If from is   provided, only messages with a from field can be matched.\ntimeout::Real=5.0: maximum waiting time in seconds.\nIf timeout==0, lk is scanned only for existing messages.\nSet timeout=Inf if you don't want to timeout. \n\nReturns\n\nreceived message or Timeout().\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.request","page":"API","title":"Actors.request","text":"request(lk::Link, msg::Msg; full=false, timeout::Real=5.0)\nrequest(lk::Link, M::Type{<:Msg}, args...; kwargs...)\n\nSend a message to an actor, block, receive and return the result.\n\nArguments\n\nlk::Link: actor link, or name::Symbol (if registered),\nmsg::Msg: a message,\nMsg::Type{<:Msg}: a message type,\nargs...: optional arguments to Msg, \nfull: if true return the full Response message.\ntimeout::Real=5.0: timeout in seconds after which a    Timeout is returned,\nkwargs...: full or timeout.\n\n\n\n\n\n","category":"function"},{"location":"api/#User-API","page":"API","title":"User API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Actors has a user interface allowing you to control actors:","category":"page"},{"location":"api/","page":"API","title":"API","text":"call\ncast\nexec\nexit!\nquery\nupdate!","category":"page"},{"location":"api/#Actors.call","page":"API","title":"Actors.call","text":"call(lk::Link, [from::Link,] args2...; timeout::Real=5.0)\ncall(name::Symbol, ....)\n\nCall an actor to execute its behavior and to send a  Response with the result. \n\nArguments\n\nactor lk::Link (or name::Symbol if registered), \nfrom::Link: sender link, \nargs2...: remaining arguments to the actor.\ntimeout::Real=5.0: timeout in seconds.\n\nNote: If from is omitted, call blocks and returns the result\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.cast","page":"API","title":"Actors.cast","text":"cast(lk::Link, args2...)\ncast(name::Symbol, args2...)\n\nCast args2... to the actor lk (or name if registered)  to execute its behavior with args2... without sending a  response. \n\nNote: you can prompt the returned value with query.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.exec","page":"API","title":"Actors.exec","text":"exec(lk::Link, from::Link, f::Function, args...; kwargs...)\nexec(lk::Link, from::Link, func)\nexec(lk::Link, func; timeout::Real=5.0)\nexec(lk::Link, f::Function, args...; timeout::Real=5.0)\nexec(name::Symbol, ....)\n\nAsk an actor lk (or name if registered) to execute an  arbitrary function and to send the returned value as  Response.\n\nArguments\n\nactor lk::Link or name::Symbol if registered,\nfrom::Link: the link a Response should be sent to.\nfunc: a callable object,\nf::Function: a function,\nargs...; kwargs...: arguments and keyword arguments to it,\nfu::Bhv: a Bhv with a callable object and   its arguments,\ntimeout::Real=5.0: timeout in seconds. Set timeout=Inf    if you don't want to timeout.\n\nNote: If from is ommitted, exec blocks, waits and  returns the result (with a timeout).\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.exit!","page":"API","title":"Actors.exit!","text":"exit!(lk::Link, reason=:ok)\nexit!(name::Symbol, ....)\n\nTell an actor lk (or name if registered) to exit. If it  has a term function, it calls it with  reason as last argument. \n\nnote: This behavior is not yet fully implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.query","page":"API","title":"Actors.query","text":"query(lk::Link, [from::Link,] s::Symbol; timeout::Real=5.0)\nquery(name::Symbol, ....)\n\nQuery an actor about an internal state variable s. \n\nParameters\n\nactor lk::Link or name::Symbol if registered,\nfrom::Link: sender link,\ns::Symbol one of :mode,:bhv,:res,:sta,:usr.\ntimeout::Real=5.0: \n\nNote: If from is omitted, query blocks and returns  the response. In that case there is a timeout.\n\nExamples\n\njulia> f(x, y; u=0, v=0) = x+y+u+v  # implement a behavior\nf (generic function with 1 method)\n\njulia> fact = spawn(Bhv(f, 1))     # start an actor with it\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> query(fact, :mode)           # query the mode\n:default\n\njulia> cast(fact, 1)                # cast a 2nd argument to it\nActors.Cast((1,))\n\njulia> query(fact, :res)            # query the result\n2\n\njulia> query(fact, :sta)            # query the state\n\njulia> query(fact, :bhv)            # query the behavior\nBhv(f, (1,), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), Actors.var\"#2#4\"{Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},typeof(f),Tuple{Int64}}(Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}(), f, (1,)))\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.update!","page":"API","title":"Actors.update!","text":"update!(lk::Link, x; s::Symbol=:sta)\nupdate!(lk::Link, arg::Args)\nupdate!(name::Symbol, ....)\n\nUpdate an actor's internal state s with args....\n\nArguments\n\nactor lk::Link or name::Symbol if registered,\nx: value/variable to update the choosen state with,\narg::Args: arguments to update,\ns::Symbol: one of :arg,:mode,:name,:self,:sta,:usr.\n\nNote: If you want to update the stored arguments to the  behavior function with s=:arg, you must pass an Args  to arg. If Args has keyword arguments, they are merged  with existing keyword arguments to the behavior function.\n\nExample\n\njulia> update!(fact, 5)       # update the state variable\nActors.Update(:sta, 5)\n\njulia> query(fact, :sta)      # query it\n5\n\njulia> update!(fact, Args(0, u=5, v=5));  # update arguments to the behavior \n\njulia> call(fact, 0)          # call the actor with 0\n10\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The following is needed for updating arguments:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Args","category":"page"},{"location":"api/#Actors.Args","page":"API","title":"Actors.Args","text":"Args(args...; kwargs...)\n\nA structure for updating arguments to an actor's behavior.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actor-Tasks","page":"API","title":"Actor Tasks","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ATask\nasync\nawait","category":"page"},{"location":"api/#Actors.ATask","page":"API","title":"Actors.ATask","text":"The actor task type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Actors.async","page":"API","title":"Actors.async","text":"async(func::Bhv; pid=myid(), thrd=false, sticky=false, taskref=nothing)\n\nStart a task to execute func and return an ATask  variable.\n\nAn actor task sends its result to the back link  of the ATask variable and exits immediately.\n\nParameters\n\nfunc::Bhv: \npid=myid(): \nthrd=false: \nsticky=false: \ntaskref=nothing: \n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.await","page":"API","title":"Actors.await","text":"await(t::ATask; timeout::Real=5.0)\n\nAwait a task reply and return it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actor-Registry","page":"API","title":"Actor Registry","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Actors can be registered with Symbols to a registry. API functions on actors can then be called with their registered names.","category":"page"},{"location":"api/","page":"API","title":"API","text":"register\nunregister\nwhereis\nregistered","category":"page"},{"location":"api/#Actors.register","page":"API","title":"Actors.register","text":"register(name::Symbol, lk::Link)\n\nRegister the actor lk with name. Returns true if the  registration succeeds, false if name is already in use.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.unregister","page":"API","title":"Actors.unregister","text":"unregister(name::Symbol)\n\nRemove any registrations associated with name.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.whereis","page":"API","title":"Actors.whereis","text":"whereis(name::Symbol)\n\nFind out whether name is registered. Return the actor link  lk or missing if not found.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.registered","page":"API","title":"Actors.registered","text":"registered()\n\nReturn an Array of all registered actors in the system.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The registry works transparently over distributed worker processes such that local links are transformed to remote links when shared between workers.","category":"page"},{"location":"api/#Actor-Supervision","page":"API","title":"Actor Supervision","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This is not yet implemented.","category":"page"},{"location":"api/","page":"API","title":"API","text":"init!\nterm!","category":"page"},{"location":"api/#Actors.init!","page":"API","title":"Actors.init!","text":"init!(lk::Link, func, args...; kwargs...)\ninit!(name::Symbol, ....)\n\nTell an actor lk to save the func with the given  arguments as an init function and to execute  it.\n\nThe init function will be called at actor restart.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Actors.term!","page":"API","title":"Actors.term!","text":"term!(lk::Link, func, args...; kwargs...)\nterm!(name::Symbol, ....)\n\nTell an actor lk (or name::Symbol if registered) to  execute func with the given partial arguments and an exit reason when it terminates. \n\nThe exit reason is added by the actor to args1... when it  exits.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#Diagnosis","page":"API","title":"Diagnosis","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In order to develop actor programs, it is useful to have access to the actor tasks and eventually to their stack traces. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"istaskfailed(::Link)\ninfo","category":"page"},{"location":"api/#Base.istaskfailed-Tuple{Link}","page":"API","title":"Base.istaskfailed","text":"istaskfailed(lk::Link)\n\nReturns true if a task associated with lk has failed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Actors.info","page":"API","title":"Actors.info","text":"info(lk::Link)\n\nReturn the state (eventually the stacktrace) of a task associated  with lk.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"For diagnostic purposes it is possible to get access to the actor's ACT variable:","category":"page"},{"location":"api/","page":"API","title":"API","text":"diag","category":"page"},{"location":"api/#Actors.diag","page":"API","title":"Actors.diag","text":"diag(lk::Link, check=0)\ndiag(name::Symbol, ....)\n\nGive an actor state or stacktrace.\n\nIf check != 0 return the internal _ACT variable of the  actor. This is for diagnosis and testing only!\n\n\n\n\n\n","category":"function"},{"location":"behaviors/#Behaviors","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"CurrentModule = Actors","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"A behavior is a ...","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"... function to express what an actor does when it processes a message. [1]The behavior of an actor maps the incoming communication to a three tuple of tasks created, new actors created, and the replacement behavior. [2]","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"beginarraylrl\nf_i(a_i c_i)  rightarrow f_i+1(a_i+1)tau_utau_v alpha_xalpha_y quad\ntextrmwith  f  textrmbehavior function \n  a  textrmacquaintances \n  c  textrmcommunication \n  tau  textrmtasks created \n  alpha  textrmactors created \nendarray","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"The behavior thus can be seen as a partial application of a function f to acquaintances a (variables or values the actor knows of). If a communication c arrives, the behavior executes f(ac):","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"f(a, c) = a + c         # define a function\ng(f, a) = (c)->f(a, c)  # a function to build a behavior\nbhv = g(f, 1)           # partially apply f to 1\nbhv(2)                  # execute f(1,2)","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Actor behavior can be represented in a functional or in an object-oriented style. Both are interchangeable.","category":"page"},{"location":"behaviors/#Functional-Style","page":"Behaviors","title":"Functional Style","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"We represent a behavior as a function f together with acquaintance arguments a... and kw... (keyword arguments) to it. Bhv creates a partial application (a closure) ϕ(a...; kw...) which then can be executed with the communication arguments c...:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"using Actors\nf(s, t, u, v; w=1, x=1) = s + t + u + v + w + x   # a function\nbhv = Bhv(f, 1, 1, w=2, x=2);  # create a Bhv with f and acquaintances\nbhv(1, 1)                      # execute it with communication parameters","category":"page"},{"location":"behaviors/#Object-oriented-Style","page":"Behaviors","title":"Object-oriented Style","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Alternatively we put the acquaintance parameters in an object which we make executable (e.g. a functor) with communication parameters:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"struct Acqu                    # define an object with acquaintances\n    s; t; w; x\nend\n(a::Acqu)(u, v) = a.s + a.t + u + v + a.w + a.x  # make it executable with communication parameters\nbhv = Acqu(1,1,2,2)            # create an instance\nbhv(1,1)                       # execute it with communication parameters","category":"page"},{"location":"behaviors/#Freestyle","page":"Behaviors","title":"Freestyle","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"With being callable the only hard requirement for a behavior, you can pass anything callable as behavior to an actor regardless whether it contains acquaintances or not:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"using Actors, .Threads\nimport Actors: spawn, newLink\nmyactor = spawn(threadid)                     # a parameterless function\ncall(myactor)\nbecome!(myactor, (lk, x, y) -> send(lk, x^y)) # an anonymous function with communication arguments\nme = newLink()\nsend(myactor, me, 123, 456)\nreceive(me)","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Of course you can give objects containing acquaintances as parameters to a function and create a partial application with Bhv on them and much more. Be my guest!","category":"page"},{"location":"behaviors/#Agha's-Stack-example","page":"Behaviors","title":"Agha's Stack example","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Now more realistically for actor behavior we reproduce Agha's example 3.2.1 [3]:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"using Actors\nimport Actors: spawn, newLink\n\nmutable struct StackNode{T,L}  # a stack node object\n    content::T\n    link::L\nend\n\nstruct Pop{L}                  # a pop message\n    customer::L\nend\n\nstruct Push{T}                 # a push message\n    content::T\nend\n\n# now three behavior methods\nforwarder = send\nfunction (sn::StackNode)(msg::Pop)\n    isnothing(sn.content) || become(forwarder, sn.link)\n    send(msg.customer, Response(sn.content))\nend\n(sn::StackNode)(msg::Push) = become(StackNode(msg.content, spawn(sn)))","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Here we use both the functional and the object oriented approach:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"forwarder is a function which we put together with sn.link into a Bhv,\nStackNode is an object, which gets two methods.","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"Now we can operate the stack:","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"julia> mystack = spawn(StackNode(nothing, newLink()))\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :default)\n\njulia> response = newLink()\nLink{Channel{Any}}(Channel{Any}(sz_max:32,sz_curr:0), 1, :local)\n\njulia> for i ∈ 1:5\n           send(mystack, Push(i))\n       end\n\njulia> for i ∈ 1:5\n           send(mystack, Pop(response))\n           println(receive(response).y)\n       end\n5\n4\n3\n2\n1","category":"page"},{"location":"behaviors/#Setting-and-Changing-Behavior","page":"Behaviors","title":"Setting and Changing Behavior","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"An actor's behavior is set with spawn and gets changed with become!. Inside a behavior function an actor can change its own behavior with become. In both cases a callable object together with acquaintance arguments can be specified as new behavior. This is effective when the next message gets processed.","category":"page"},{"location":"behaviors/#Be-Careful-with-Mutable-Variables","page":"Behaviors","title":"Be Careful with Mutable Variables","text":"","category":"section"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"As you have seen, you are very free in how you define behaviors, but you must be very careful in passing mutable variables as acquaintances to actors as they could be accessed by other actors on other threads concurrently causing race conditions. If that's the case, you can wrap mutable variables into a :guard actor, which will manage access to them. ","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"[1]: see the Actor Model on Wikipedia.","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"[2]: Gul Agha 1986. Actors. a model of concurrent computation in distributed systems, MIT.- p. 30","category":"page"},{"location":"behaviors/","page":"Behaviors","title":"Behaviors","text":"[3]: ibid. p. 34","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"see the examples in the repository.","category":"page"},{"location":"#Actors-Documentation","page":"Actors Documentation","title":"Actors Documentation","text":"","category":"section"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors implements the Actor model using Julia's concurrency primitives.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"An actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [1]","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors enhances Julia's capabilities for concurrent computing. It can be used together with other Julia functionality for multi-threading and distributed computing.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors builds on the classical Actor model. Its actors have Julia functions as behaviors and can be controlled and interact with a modern API (inspired by Erlang/Elixir/OTP).","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors can interface with other actor libraries and can be extended by them using actor protocols.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"Actors is in active development. If you want to contribute, please join JuliaActors.","category":"page"},{"location":"","page":"Actors Documentation","title":"Actors Documentation","text":"[1]: See the Wikipedia entry on the Actor Model.","category":"page"}]
}
