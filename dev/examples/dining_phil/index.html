<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dining Philosophers · Actors.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Actors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Actors.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Actors Documentation</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro/">Getting Started with Actors</a></li><li><a class="tocitem" href="../../basics/">Actor Model</a></li><li><a class="tocitem" href="../../actors/">Actors and Julia</a></li><li><a class="tocitem" href="../../behaviors/">Actor Behavior</a></li><li><a class="tocitem" href="../../protocol/">Messaging Protocol</a></li><li><a class="tocitem" href="../../errors/">Error Handling</a></li><li><a class="tocitem" href="../../infrastructure/">More Useful Stuff</a></li><li><a class="tocitem" href="../../glossary/">A Glossary of Actor Terms</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Dining Philosophers</a></li><li><a class="tocitem" href="../prod_cons/">Producer-Consumer Problem</a></li><li><a class="tocitem" href="../examples/">Further Examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../diag/">Diagnostics</a></li><li><a class="tocitem" href="../../internals/">Internals</a></li><li><a class="tocitem" href="../../messages/">Messages</a></li><li><a class="tocitem" href="../../interface/">Interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Dining Philosophers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dining Philosophers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaActors/Actors.jl/blob/master/docs/src/examples/dining_phil.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dining-Philosophers"><a class="docs-heading-anchor" href="#Dining-Philosophers">Dining Philosophers</a><a id="Dining-Philosophers-1"></a><a class="docs-heading-anchor-permalink" href="#Dining-Philosophers" title="Permalink"></a></h1><p>This is a <a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">classic problem</a> to illustrate challenges with concurrency. We will give here a solution based on Dale Schumacher&#39;s blogpost <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. First some initial definitions:</p><pre><code class="language-julia">using Actors
import Actors: spawn

const eating_time = 5
const thinking_time = 10
const speedup = 100

mutable struct Phil{L}
    left::L
    right::L
    eaten::Float64
end

delay(time, msg, cust) = async() do 
    sleep(time/speedup)
    send(cust, msg)
end

@msg Take Taken Busy Put Eat Think</code></pre><p>The first part of an actor based solution is that each chopstick between the philosophers is an actor. So only one access to a chopstick is possible at a time. And the philosophers will have to communicate with the chopsticks to take them:</p><pre><code class="language-julia">mutable struct Chopstick
    idle::Bool
    Chopstick() = new(true)
end

function (c::Chopstick)(cust, ::Take)
    if c.idle
        send(cust, self(), Taken())
        c.idle = false
    else
        send(cust, self(), Busy())
    end
end
(c::Chopstick)(::Put) = c.idle = true</code></pre><p>We have modeled a chopstick actor as a function object with two message arguments, <code>Take</code> and <code>Put</code>.</p><p>Now the philosophers! We model them with behavior functions representing their state, the respective philosopher as an acquaintance and state transitions with <code>become</code>. So a philosopher is modeled as a finite state machine:</p><pre><code class="language-julia">function thinking(p::Phil, ::Eat)
    send(p.left, self(), Take())
    send(p.right, self(), Take())
    become(hungry, p)
end
function hungry(p::Phil, chop, ::Taken)
    chop == p.left ?
        become(right_waiting, p) :
        become(left_waiting,  p)
end
hungry(p::Phil, chop, ::Busy) = become(denied, p)
function denied(p::Phil, other, ::Taken)
    send(other, Put())
    become(thinking, p)
    send(self(), Eat())
end
function denied(p::Phil, chop, ::Busy)
    become(thinking, p)
    send(self(), Eat())
end
function right_waiting(p::Phil, chop, ::Taken)
    if chop == p.right 
        become(eating, p)
        p.eaten += te = randn()+eating_time
        delay(te, Think(), self())
    end
end
function right_waiting(p::Phil, chop, ::Busy)
    send(p.left, Put())
    become(thinking, p)
    send(self(), Eat())
end
function left_waiting(p::Phil, chop, ::Taken)
    if chop == p.left
        become(eating, p)
        p.eaten += te = randn()+eating_time
        delay(te, Think(), self())
    end
end
function left_waiting(p::Phil, chop, ::Busy)
    send(p.right, Put())
    become(thinking, p)
    send(self(), Eat())
end
function eating(p::Phil, ::Think)
    send(p.left, Put())
    send(p.right, Put())
    become(thinking, p)
    delay(randn()+thinking_time, Eat(), self())
end</code></pre><p>The crucial step in preventing a deadlock is that a philosopher puts down his chopstick if he is  <code>right_waiting</code> or <code>left_waiting</code> and gets a <code>:busy</code> or if he is <code>denied</code> and gets a <code>:taken</code> message. Then he switches again to <code>thinking</code> and sends a message to himself to <code>:eat</code>. So he can try again.</p><p>We need a stats function for eating time and we setup everything:</p><pre><code class="language-julia">eaten(phils...) = Tuple(round(Int, query(p, :bhv).a[1].eaten) for p in phils)

c1 = spawn(Chopstick())
c2 = spawn(Chopstick())
c3 = spawn(Chopstick())
c4 = spawn(Chopstick())
c5 = spawn(Chopstick())

descartes = spawn(thinking, Phil(c1,c2,0.0))
nietzsche = spawn(thinking, Phil(c2,c3,0.0))
kant      = spawn(thinking, Phil(c3,c4,0.0))
hume      = spawn(thinking, Phil(c4,c5,0.0))
plato     = spawn(thinking, Phil(c5,c1,0.0))

for p in (descartes, nietzsche, kant, hume, plato)
    delay(thinking_time, Eat(), p)
end</code></pre><p>To get some stats we print the eaten times every second:</p><pre><code class="language-julia">julia &gt; for i in 1:5
            sleep(1)
            println(i, &quot;s: &quot;, eaten(descartes, nietzsche, kant, hume, plato))
        end
1s: (24, 34, 32, 31, 31)
2s: (57, 70, 61, 62, 65)
3s: (86, 101, 89, 96, 100)
4s: (119, 129, 123, 124, 132)
5s: (151, 162, 155, 155, 162)</code></pre><p>So they are happy thinking and eating asynchronously. Since we have a speedup of 100, we can conclude that in 500 time units our philosophers eat around 155 (much more than programmers). We stop the whole thing in order to prevent overconsumption:</p><pre><code class="language-julia">julia &gt; foreach(a-&gt;exit!(a), (descartes, nietzsche, kant, hume, plato, c1, c2, c3, c4, c5))</code></pre><p>Actually Gul Agha proposed something else. He reasoned about to let philosophers talk to each other:</p><blockquote><p>An actor is free and able to figure out a deadlock situation by querying other actors as to their local state. ... While these philosophers may be &quot;busy&quot; eating or looking for a chopstick, they nevertheless accept communications sent to them. <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></p></blockquote><p>We did not go this road in order to avoid philosophical debates about local state. But you can try for yourself.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Dale Schumacher. It&#39;s Actors All The Way Down, 2010: <a href="http://www.dalnefre.com/wp/2010/08/dining-philosophers-in-humus/">&quot;Dining Philosophers&quot; in Humus</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Gul Agha, 1986. Actors: A Model of Concurrent Computation in Distributed Systems, MIT,- p. 95</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../api/">« API</a><a class="docs-footer-nextpage" href="../prod_cons/">Producer-Consumer Problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 11 February 2021 17:14">Thursday 11 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
